library gtk.gdart;

import "gdart.dart";

import "dart:async";

import "pango.dart" hide Alignment, Style, Variant, Layout, Context, initLibrary, Rectangle, Color, Gravity;
import "pango.dart" as pango;
import "gobject.dart" hide initLibrary;
import "xlib.dart" as xlib;
import "cairo.dart" hide initLibrary, FontFace;
import "gdk.dart" hide Window, initLibrary;
import "gdk.dart" as gdk;
import "gio.dart" hide Application, ActionGroup, Menu, MountOperation, initLibrary;
import "gio.dart" as gio;
import "atk.dart" hide Image, Action, Value, Table, Window, initLibrary, Rectangle;
import "atk.dart" as atk;
import "gdkpixbuf.dart" hide initLibrary;
import "glib.dart" hide initLibrary;

class AboutDialog extends Dialog with ImplementorIface, Buildable {
  AboutDialog.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AboutDialog');

  static const String ARTISTS_PROPERTY = 'artists';
  static const String AUTHORS_PROPERTY = 'authors';
  static const String COMMENTS_PROPERTY = 'comments';
  static const String COPYRIGHT_PROPERTY = 'copyright';
  static const String DOCUMENTERS_PROPERTY = 'documenters';
  static const String LICENSE_PROPERTY = 'license';
  static const String LICENSE_TYPE_PROPERTY = 'license-type';
  static const String LOGO_PROPERTY = 'logo';
  static const String LOGO_ICON_NAME_PROPERTY = 'logo-icon-name';
  static const String PROGRAM_NAME_PROPERTY = 'program-name';
  static const String TRANSLATOR_CREDITS_PROPERTY = 'translator-credits';
  static const String VERSION_PROPERTY = 'version';
  static const String WEBSITE_PROPERTY = 'website';
  static const String WEBSITE_LABEL_PROPERTY = 'website-label';
  static const String WRAP_LICENSE_PROPERTY = 'wrap-license';
  factory AboutDialog() => _staticInfo.callStatic('new', []);
  void addCreditSection(String sectionName, List<String> people) => _staticInfo.callMethodOnReceiver('add_credit_section', this, [sectionName, people]);
  List<String> get artists => _staticInfo.callMethodOnReceiver('get_artists', this, []);
  List<String> get authors => _staticInfo.callMethodOnReceiver('get_authors', this, []);
  String get comments => _staticInfo.callMethodOnReceiver('get_comments', this, []);
  String get copyright => _staticInfo.callMethodOnReceiver('get_copyright', this, []);
  List<String> get documenters => _staticInfo.callMethodOnReceiver('get_documenters', this, []);
  String get license => _staticInfo.callMethodOnReceiver('get_license', this, []);
  License get licenseType => _staticInfo.callMethodOnReceiver('get_license_type', this, []);
  Pixbuf get logo => _staticInfo.callMethodOnReceiver('get_logo', this, []);
  String get logoIconName => _staticInfo.callMethodOnReceiver('get_logo_icon_name', this, []);
  String get programName => _staticInfo.callMethodOnReceiver('get_program_name', this, []);
  String get translatorCredits => _staticInfo.callMethodOnReceiver('get_translator_credits', this, []);
  String get version => _staticInfo.callMethodOnReceiver('get_version', this, []);
  String get website => _staticInfo.callMethodOnReceiver('get_website', this, []);
  String get websiteLabel => _staticInfo.callMethodOnReceiver('get_website_label', this, []);
  bool get wrapLicense => _staticInfo.callMethodOnReceiver('get_wrap_license', this, []);
  void set artists(List<String> artists) => _staticInfo.callMethodOnReceiver('set_artists', this, [artists]);
  void set authors(List<String> authors) => _staticInfo.callMethodOnReceiver('set_authors', this, [authors]);
  void set comments(String comments) => _staticInfo.callMethodOnReceiver('set_comments', this, [comments]);
  void set copyright(String copyright) => _staticInfo.callMethodOnReceiver('set_copyright', this, [copyright]);
  void set documenters(List<String> documenters) => _staticInfo.callMethodOnReceiver('set_documenters', this, [documenters]);
  void set license(String license) => _staticInfo.callMethodOnReceiver('set_license', this, [license]);
  void set licenseType(License licenseType) => _staticInfo.callMethodOnReceiver('set_license_type', this, [licenseType]);
  void set logo(Pixbuf logo) => _staticInfo.callMethodOnReceiver('set_logo', this, [logo]);
  void set logoIconName(String iconName) => _staticInfo.callMethodOnReceiver('set_logo_icon_name', this, [iconName]);
  void set programName(String name) => _staticInfo.callMethodOnReceiver('set_program_name', this, [name]);
  void set translatorCredits(String translatorCredits) => _staticInfo.callMethodOnReceiver('set_translator_credits', this, [translatorCredits]);
  void set version(String version) => _staticInfo.callMethodOnReceiver('set_version', this, [version]);
  void set website(String website) => _staticInfo.callMethodOnReceiver('set_website', this, [website]);
  void set websiteLabel(String websiteLabel) => _staticInfo.callMethodOnReceiver('set_website_label', this, [websiteLabel]);
  void set wrapLicense(bool wrapLicense) => _staticInfo.callMethodOnReceiver('set_wrap_license', this, [wrapLicense]);
  int _connectToActivateLink(bool after, bool func(String uri)) => signalConnect('activate-link', func, after);
  Stream<AboutDialogActivateLinkEvent> get onActivateLink {
    int signalId;
    StreamController<AboutDialogActivateLinkEvent> controller;
    controller = new StreamController<AboutDialogActivateLinkEvent>(
      onListen: () {
          signalId = _connectToActivateLink(false, (String uri) {
              var result = new AboutDialogActivateLinkEvent(uri);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<AboutDialogActivateLinkEvent> get afterActivateLink {
    int signalId;
    StreamController<AboutDialogActivateLinkEvent> controller;
    controller = new StreamController<AboutDialogActivateLinkEvent>(
      onListen: () {
          signalId = _connectToActivateLink(true, (String uri) {
              var result = new AboutDialogActivateLinkEvent(uri);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class AboutDialogActivateLinkEvent {
  final String uri;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  AboutDialogActivateLinkEvent(this.uri);
}

class AccelFlags extends GEnumBase {
  const AccelFlags(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AccelFlags');

  static const AccelFlags NULL = const AccelFlags(0);
  static const AccelFlags VISIBLE = const AccelFlags(1);
  bool get visible => (index & 1) == 1;
  static const AccelFlags LOCKED = const AccelFlags(2);
  bool get locked => (index & 2) == 2;
  static const AccelFlags MASK = const AccelFlags(7);
  bool get mask => (index & 7) == 7;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'AccelFlags.VISIBLE';
      case 2: return 'AccelFlags.LOCKED';
      default: return 'new AccelFlags($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'AccelFlags.NULL';
    }
    List codes = [];
    for (var i=1; i <= 4; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  AccelFlags operator|(AccelFlags other) =>
    new AccelFlags(index | other.index);
  AccelFlags operator&(AccelFlags other) =>
    new AccelFlags(index & other.index);
}

class AccelGroup extends GObjectObject {
  AccelGroup.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AccelGroup');

  static const String IS_LOCKED_PROPERTY = 'is-locked';
  static const String MODIFIER_MASK_PROPERTY = 'modifier-mask';
  factory AccelGroup() => _staticInfo.callStatic('new', []);
  static AccelGroup fromAccelClosure(Closure closure) => _staticInfo.callStatic('from_accel_closure', [closure]);
  bool activate(int accelQuark, GObjectObject acceleratable, int accelKey, ModifierType accelMods) => _staticInfo.callMethodOnReceiver('activate', this, [accelQuark, acceleratable, accelKey, accelMods]);
  void connect(int accelKey, ModifierType accelMods, AccelFlags accelFlags, Closure closure) => _staticInfo.callMethodOnReceiver('connect', this, [accelKey, accelMods, accelFlags, closure]);
  void connectByPath(String accelPath, Closure closure) => _staticInfo.callMethodOnReceiver('connect_by_path', this, [accelPath, closure]);
  bool disconnect(Closure closure) => _staticInfo.callMethodOnReceiver('disconnect', this, [closure]);
  bool disconnectKey(int accelKey, ModifierType accelMods) => _staticInfo.callMethodOnReceiver('disconnect_key', this, [accelKey, accelMods]);
  AccelKey find(AccelGroupFindFunc findFunc) => _staticInfo.callMethodOnReceiver('find', this, [findFunc]);
  bool get isLocked => _staticInfo.callMethodOnReceiver('get_is_locked', this, []);
  ModifierType get modifierMask => _staticInfo.callMethodOnReceiver('get_modifier_mask', this, []);
  void lock() => _staticInfo.callMethodOnReceiver('lock', this, []);
  List<AccelGroupEntry> query(int accelKey, ModifierType accelMods) => _staticInfo.callMethodOnReceiver('query', this, [accelKey, accelMods]);
  void unlock() => _staticInfo.callMethodOnReceiver('unlock', this, []);
  int _connectToAccelActivate(bool after, bool func(GObjectObject acceleratable, int keyval, ModifierType modifier)) => signalConnect('accel-activate', func, after);
  Stream<AccelGroupAccelActivateEvent> get onAccelActivate {
    int signalId;
    StreamController<AccelGroupAccelActivateEvent> controller;
    controller = new StreamController<AccelGroupAccelActivateEvent>(
      onListen: () {
          signalId = _connectToAccelActivate(false, (GObjectObject acceleratable, int keyval, ModifierType modifier) {
              var result = new AccelGroupAccelActivateEvent(acceleratable, keyval, modifier);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<AccelGroupAccelActivateEvent> get afterAccelActivate {
    int signalId;
    StreamController<AccelGroupAccelActivateEvent> controller;
    controller = new StreamController<AccelGroupAccelActivateEvent>(
      onListen: () {
          signalId = _connectToAccelActivate(true, (GObjectObject acceleratable, int keyval, ModifierType modifier) {
              var result = new AccelGroupAccelActivateEvent(acceleratable, keyval, modifier);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToAccelChanged(bool after, void func(int keyval, ModifierType modifier, Closure accelClosure)) => signalConnect('accel-changed', func, after);
  Stream<AccelGroupAccelChangedEvent> get onAccelChanged {
    int signalId;
    StreamController<AccelGroupAccelChangedEvent> controller;
    controller = new StreamController<AccelGroupAccelChangedEvent>(
      onListen: () {
          signalId = _connectToAccelChanged(false, (int keyval, ModifierType modifier, Closure accelClosure) {
              var result = new AccelGroupAccelChangedEvent(keyval, modifier, accelClosure);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<AccelGroupAccelChangedEvent> get afterAccelChanged {
    int signalId;
    StreamController<AccelGroupAccelChangedEvent> controller;
    controller = new StreamController<AccelGroupAccelChangedEvent>(
      onListen: () {
          signalId = _connectToAccelChanged(true, (int keyval, ModifierType modifier, Closure accelClosure) {
              var result = new AccelGroupAccelChangedEvent(keyval, modifier, accelClosure);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class AccelGroupAccelActivateEvent {
  final GObjectObject acceleratable;
  final int keyval;
  final ModifierType modifier;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  AccelGroupAccelActivateEvent(this.acceleratable, this.keyval, this.modifier);
}

class AccelGroupAccelChangedEvent {
  final int keyval;
  final ModifierType modifier;
  final Closure accelClosure;

  AccelGroupAccelChangedEvent(this.keyval, this.modifier, this.accelClosure);
}

typedef bool AccelGroupActivate(AccelGroup accelGroup, GObjectObject acceleratable, int keyval, ModifierType modifier);
class AccelGroupEntry extends GObjectBase {
  AccelGroupEntry.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AccelGroupEntry');

  AccelKey get key => getFieldOfObject('key', 0);
  void set key(AccelKey value) => setFieldOfObject('key', 0, value);
  Closure get closure => getFieldOfObject('closure', 1);
  void set closure(Closure value) => setFieldOfObject('closure', 1, value);
  int get accelPathQuark => getFieldOfObject('accel_path_quark', 2);
  void set accelPathQuark(int value) => setFieldOfObject('accel_path_quark', 2, value);
}

typedef bool AccelGroupFindFunc(AccelKey key, Closure closure);
class AccelKey extends GObjectBase {
  AccelKey.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AccelKey');

  int get accelKey => getFieldOfObject('accel_key', 0);
  void set accelKey(int value) => setFieldOfObject('accel_key', 0, value);
  ModifierType get accelMods => getFieldOfObject('accel_mods', 1);
  void set accelMods(ModifierType value) => setFieldOfObject('accel_mods', 1, value);
  int get accelFlags => getFieldOfObject('accel_flags', 2);
  void set accelFlags(int value) => setFieldOfObject('accel_flags', 2, value);
}

class AccelLabel extends Label with ImplementorIface, Buildable {
  AccelLabel.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AccelLabel');

  Closure get accelClosure => _staticInfo.getGPropertyOnReceiver('accel-closure', this);
  static const String ACCEL_CLOSURE_PROPERTY = 'accel-closure';
  static const String ACCEL_WIDGET_PROPERTY = 'accel-widget';
  factory AccelLabel(String string) => _staticInfo.callStatic('new', [string]);
  void getAccel() => _staticInfo.callMethodOnReceiver('get_accel', this, []);
  Widget get accelWidget => _staticInfo.callMethodOnReceiver('get_accel_widget', this, []);
  int getAccelWidth() => _staticInfo.callMethodOnReceiver('get_accel_width', this, []);
  bool refetch() => _staticInfo.callMethodOnReceiver('refetch', this, []);
  void setAccel(int acceleratorKey, ModifierType acceleratorMods) => _staticInfo.callMethodOnReceiver('set_accel', this, [acceleratorKey, acceleratorMods]);
  void set accelClosure_(Closure accelClosure) => _staticInfo.callMethodOnReceiver('set_accel_closure', this, [accelClosure]);
  void set accelWidget(Widget accelWidget) => _staticInfo.callMethodOnReceiver('set_accel_widget', this, [accelWidget]);
}

class AccelMap extends GObjectObject {
  AccelMap.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AccelMap');

  static void addEntry(String accelPath, int accelKey, ModifierType accelMods) => _staticInfo.callStatic('add_entry', [accelPath, accelKey, accelMods]);
  static void addFilter(String filterCairoPattern) => _staticInfo.callStatic('add_filter', [filterCairoPattern]);
  static bool changeEntry(String accelPath, int accelKey, ModifierType accelMods, bool replace) => _staticInfo.callStatic('change_entry', [accelPath, accelKey, accelMods, replace]);
  static void foreach(dynamic data /* this will fail */, AccelMapForeach foreachFunc) => _staticInfo.callStatic('foreach', [data, foreachFunc]);
  static void foreachUnfiltered(dynamic data /* this will fail */, AccelMapForeach foreachFunc) => _staticInfo.callStatic('foreach_unfiltered', [data, foreachFunc]);
  static AccelMap get_() => _staticInfo.callStatic('get', []);
  static void load(String fileName) => _staticInfo.callStatic('load', [fileName]);
  static void loadFd(int fd) => _staticInfo.callStatic('load_fd', [fd]);
  static void loadScanner(Scanner scanner) => _staticInfo.callStatic('load_scanner', [scanner]);
  static void lockPath(String accelPath) => _staticInfo.callStatic('lock_path', [accelPath]);
  static bool lookupEntry(String accelPath) => _staticInfo.callStatic('lookup_entry', [accelPath]);
  static void save(String fileName) => _staticInfo.callStatic('save', [fileName]);
  static void saveFd(int fd) => _staticInfo.callStatic('save_fd', [fd]);
  static void unlockPath(String accelPath) => _staticInfo.callStatic('unlock_path', [accelPath]);
  int _connectToChanged(bool after, void func(String accelPath, int accelKey, ModifierType accelMods)) => signalConnect('changed', func, after);
  Stream<AccelMapChangedEvent> get onChanged {
    int signalId;
    StreamController<AccelMapChangedEvent> controller;
    controller = new StreamController<AccelMapChangedEvent>(
      onListen: () {
          signalId = _connectToChanged(false, (String accelPath, int accelKey, ModifierType accelMods) {
              var result = new AccelMapChangedEvent(accelPath, accelKey, accelMods);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<AccelMapChangedEvent> get afterChanged {
    int signalId;
    StreamController<AccelMapChangedEvent> controller;
    controller = new StreamController<AccelMapChangedEvent>(
      onListen: () {
          signalId = _connectToChanged(true, (String accelPath, int accelKey, ModifierType accelMods) {
              var result = new AccelMapChangedEvent(accelPath, accelKey, accelMods);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class AccelMapChangedEvent {
  final String accelPath;
  final int accelKey;
  final ModifierType accelMods;

  AccelMapChangedEvent(this.accelPath, this.accelKey, this.accelMods);
}

typedef void AccelMapForeach(dynamic data /* this will fail */, String accelPath, int accelKey, ModifierType accelMods, bool changed);
class Accessible extends AtkObject {
  Accessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Accessible');

  static const String WIDGET_PROPERTY = 'widget';
  void connectWidgetDestroyed() => _staticInfo.callMethodOnReceiver('connect_widget_destroyed', this, []);
  Widget get widget => _staticInfo.callMethodOnReceiver('get_widget', this, []);
  void set widget(Widget widget) => _staticInfo.callMethodOnReceiver('set_widget', this, [widget]);
}

class Action extends GObjectObject with Buildable {
  Action.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Action');

  ActionGroup get actionGroup => _staticInfo.getGPropertyOnReceiver('action-group', this);
  void set actionGroup(ActionGroup value) => _staticInfo.setGPropertyOnReceiver('action-group', this, value);
  static const String ACTION_GROUP_PROPERTY = 'action-group';
  static const String ALWAYS_SHOW_IMAGE_PROPERTY = 'always-show-image';
  static const String GICON_PROPERTY = 'gicon';
  bool get hideIfEmpty => _staticInfo.getGPropertyOnReceiver('hide-if-empty', this);
  void set hideIfEmpty(bool value) => _staticInfo.setGPropertyOnReceiver('hide-if-empty', this, value);
  static const String HIDE_IF_EMPTY_PROPERTY = 'hide-if-empty';
  static const String ICON_NAME_PROPERTY = 'icon-name';
  static const String IS_IMPORTANT_PROPERTY = 'is-important';
  static const String LABEL_PROPERTY = 'label';
  void set name(String value) => _staticInfo.setGPropertyOnReceiver('name', this, value);
  static const String NAME_PROPERTY = 'name';
  static const String SENSITIVE_PROPERTY = 'sensitive';
  static const String SHORT_LABEL_PROPERTY = 'short-label';
  static const String STOCK_ID_PROPERTY = 'stock-id';
  static const String TOOLTIP_PROPERTY = 'tooltip';
  static const String VISIBLE_PROPERTY = 'visible';
  static const String VISIBLE_HORIZONTAL_PROPERTY = 'visible-horizontal';
  bool get visibleOverflown => _staticInfo.getGPropertyOnReceiver('visible-overflown', this);
  void set visibleOverflown(bool value) => _staticInfo.setGPropertyOnReceiver('visible-overflown', this, value);
  static const String VISIBLE_OVERFLOWN_PROPERTY = 'visible-overflown';
  static const String VISIBLE_VERTICAL_PROPERTY = 'visible-vertical';
  factory Action(String name, String label, String tooltip, String stockId) => _staticInfo.callStatic('new', [name, label, tooltip, stockId]);
  void activate() => _staticInfo.callMethodOnReceiver('activate', this, []);
  void blockActivate() => _staticInfo.callMethodOnReceiver('block_activate', this, []);
  void connectAccelerator() => _staticInfo.callMethodOnReceiver('connect_accelerator', this, []);
  Widget createIcon(int iconSize) => _staticInfo.callMethodOnReceiver('create_icon', this, [iconSize]);
  Widget createMenu() => _staticInfo.callMethodOnReceiver('create_menu', this, []);
  Widget createMenuItem() => _staticInfo.callMethodOnReceiver('create_menu_item', this, []);
  Widget createToolItem() => _staticInfo.callMethodOnReceiver('create_tool_item', this, []);
  void disconnectAccelerator() => _staticInfo.callMethodOnReceiver('disconnect_accelerator', this, []);
  Closure getAccelClosure() => _staticInfo.callMethodOnReceiver('get_accel_closure', this, []);
  String getAccelPath() => _staticInfo.callMethodOnReceiver('get_accel_path', this, []);
  bool get alwaysShowImage => _staticInfo.callMethodOnReceiver('get_always_show_image', this, []);
  Icon get gicon => _staticInfo.callMethodOnReceiver('get_gicon', this, []);
  String get iconName => _staticInfo.callMethodOnReceiver('get_icon_name', this, []);
  bool get isImportant => _staticInfo.callMethodOnReceiver('get_is_important', this, []);
  String get label => _staticInfo.callMethodOnReceiver('get_label', this, []);
  String get name_ => _staticInfo.callMethodOnReceiver('get_name', this, []);
  SList /* this will fail */ getProxies() => _staticInfo.callMethodOnReceiver('get_proxies', this, []);
  bool get sensitive => _staticInfo.callMethodOnReceiver('get_sensitive', this, []);
  String get shortLabel => _staticInfo.callMethodOnReceiver('get_short_label', this, []);
  String get stockId => _staticInfo.callMethodOnReceiver('get_stock_id', this, []);
  String get tooltip => _staticInfo.callMethodOnReceiver('get_tooltip', this, []);
  bool get visible => _staticInfo.callMethodOnReceiver('get_visible', this, []);
  bool get visibleHorizontal => _staticInfo.callMethodOnReceiver('get_visible_horizontal', this, []);
  bool get visibleVertical => _staticInfo.callMethodOnReceiver('get_visible_vertical', this, []);
  bool isSensitive() => _staticInfo.callMethodOnReceiver('is_sensitive', this, []);
  bool isVisible() => _staticInfo.callMethodOnReceiver('is_visible', this, []);
  void setAccelGroup(AccelGroup accelGroup) => _staticInfo.callMethodOnReceiver('set_accel_group', this, [accelGroup]);
  void setAccelPath(String accelPath) => _staticInfo.callMethodOnReceiver('set_accel_path', this, [accelPath]);
  void set alwaysShowImage(bool alwaysShow) => _staticInfo.callMethodOnReceiver('set_always_show_image', this, [alwaysShow]);
  void set gicon(Icon icon) => _staticInfo.callMethodOnReceiver('set_gicon', this, [icon]);
  void set iconName(String iconName) => _staticInfo.callMethodOnReceiver('set_icon_name', this, [iconName]);
  void set isImportant(bool isImportant) => _staticInfo.callMethodOnReceiver('set_is_important', this, [isImportant]);
  void set label(String label) => _staticInfo.callMethodOnReceiver('set_label', this, [label]);
  void set sensitive(bool sensitive) => _staticInfo.callMethodOnReceiver('set_sensitive', this, [sensitive]);
  void set shortLabel(String shortLabel) => _staticInfo.callMethodOnReceiver('set_short_label', this, [shortLabel]);
  void set stockId(String stockId) => _staticInfo.callMethodOnReceiver('set_stock_id', this, [stockId]);
  void set tooltip(String tooltip) => _staticInfo.callMethodOnReceiver('set_tooltip', this, [tooltip]);
  void set visible(bool visible) => _staticInfo.callMethodOnReceiver('set_visible', this, [visible]);
  void set visibleHorizontal(bool visibleHorizontal) => _staticInfo.callMethodOnReceiver('set_visible_horizontal', this, [visibleHorizontal]);
  void set visibleVertical(bool visibleVertical) => _staticInfo.callMethodOnReceiver('set_visible_vertical', this, [visibleVertical]);
  void unblockActivate() => _staticInfo.callMethodOnReceiver('unblock_activate', this, []);
  int _connectToActivate(bool after, void func()) => signalConnect('activate', func, after);
  Stream get onActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ActionBar extends Bin with ImplementorIface, Buildable {
  ActionBar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ActionBar');

  factory ActionBar() => _staticInfo.callStatic('new', []);
  Widget getCenterWidget() => _staticInfo.callMethodOnReceiver('get_center_widget', this, []);
  void packEnd(Widget child) => _staticInfo.callMethodOnReceiver('pack_end', this, [child]);
  void packStart(Widget child) => _staticInfo.callMethodOnReceiver('pack_start', this, [child]);
  void setCenterWidget(Widget centerWidget) => _staticInfo.callMethodOnReceiver('set_center_widget', this, [centerWidget]);
}

class ActionBarPrivate extends GObjectBase {
  ActionBarPrivate.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ActionBarPrivate');

}

class ActionEntry extends GObjectBase {
  ActionEntry.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ActionEntry');

  String get name => getFieldOfObject('name', 0);
  void set name(String value) => setFieldOfObject('name', 0, value);
  String get stockId => getFieldOfObject('stock_id', 1);
  void set stockId(String value) => setFieldOfObject('stock_id', 1, value);
  String get label => getFieldOfObject('label', 2);
  void set label(String value) => setFieldOfObject('label', 2, value);
  String get accelerator => getFieldOfObject('accelerator', 3);
  void set accelerator(String value) => setFieldOfObject('accelerator', 3, value);
  String get tooltip => getFieldOfObject('tooltip', 4);
  void set tooltip(String value) => setFieldOfObject('tooltip', 4, value);
  Callback get callback => getFieldOfObject('callback', 5);
  void set callback(Callback value) => setFieldOfObject('callback', 5, value);
}

class ActionGroup extends GObjectObject with Buildable {
  ActionGroup.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ActionGroup');

  static const String ACCEL_GROUP_PROPERTY = 'accel-group';
  void set name(String value) => _staticInfo.setGPropertyOnReceiver('name', this, value);
  static const String NAME_PROPERTY = 'name';
  static const String SENSITIVE_PROPERTY = 'sensitive';
  static const String VISIBLE_PROPERTY = 'visible';
  factory ActionGroup(String name) => _staticInfo.callStatic('new', [name]);
  void addAction(Action action) => _staticInfo.callMethodOnReceiver('add_action', this, [action]);
  void addActionWithAccel(Action action, String accelerator) => _staticInfo.callMethodOnReceiver('add_action_with_accel', this, [action, accelerator]);
  AccelGroup get accelGroup => _staticInfo.callMethodOnReceiver('get_accel_group', this, []);
  Action getAction(String actionName) => _staticInfo.callMethodOnReceiver('get_action', this, [actionName]);
  String get name_ => _staticInfo.callMethodOnReceiver('get_name', this, []);
  bool get sensitive => _staticInfo.callMethodOnReceiver('get_sensitive', this, []);
  bool get visible => _staticInfo.callMethodOnReceiver('get_visible', this, []);
  GLibList /* this will fail */ listActions() => _staticInfo.callMethodOnReceiver('list_actions', this, []);
  void removeAction(Action action) => _staticInfo.callMethodOnReceiver('remove_action', this, [action]);
  void set accelGroup(AccelGroup accelGroup) => _staticInfo.callMethodOnReceiver('set_accel_group', this, [accelGroup]);
  void set sensitive(bool sensitive) => _staticInfo.callMethodOnReceiver('set_sensitive', this, [sensitive]);
  void setTranslateFunc(TranslateFunc func) => _staticInfo.callMethodOnReceiver('set_translate_func', this, [func]);
  void setTranslationDomain(String domain) => _staticInfo.callMethodOnReceiver('set_translation_domain', this, [domain]);
  void set visible(bool visible) => _staticInfo.callMethodOnReceiver('set_visible', this, [visible]);
  String translateString(String string) => _staticInfo.callMethodOnReceiver('translate_string', this, [string]);
  int _connectToConnectProxy(bool after, void func(Action action, Widget proxy)) => signalConnect('connect-proxy', func, after);
  Stream<ActionGroupConnectProxyEvent> get onConnectProxy {
    int signalId;
    StreamController<ActionGroupConnectProxyEvent> controller;
    controller = new StreamController<ActionGroupConnectProxyEvent>(
      onListen: () {
          signalId = _connectToConnectProxy(false, (Action action, Widget proxy) {
              var result = new ActionGroupConnectProxyEvent(action, proxy);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ActionGroupConnectProxyEvent> get afterConnectProxy {
    int signalId;
    StreamController<ActionGroupConnectProxyEvent> controller;
    controller = new StreamController<ActionGroupConnectProxyEvent>(
      onListen: () {
          signalId = _connectToConnectProxy(true, (Action action, Widget proxy) {
              var result = new ActionGroupConnectProxyEvent(action, proxy);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDisconnectProxy(bool after, void func(Action action, Widget proxy)) => signalConnect('disconnect-proxy', func, after);
  Stream<ActionGroupDisconnectProxyEvent> get onDisconnectProxy {
    int signalId;
    StreamController<ActionGroupDisconnectProxyEvent> controller;
    controller = new StreamController<ActionGroupDisconnectProxyEvent>(
      onListen: () {
          signalId = _connectToDisconnectProxy(false, (Action action, Widget proxy) {
              var result = new ActionGroupDisconnectProxyEvent(action, proxy);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ActionGroupDisconnectProxyEvent> get afterDisconnectProxy {
    int signalId;
    StreamController<ActionGroupDisconnectProxyEvent> controller;
    controller = new StreamController<ActionGroupDisconnectProxyEvent>(
      onListen: () {
          signalId = _connectToDisconnectProxy(true, (Action action, Widget proxy) {
              var result = new ActionGroupDisconnectProxyEvent(action, proxy);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPostActivate(bool after, void func(Action action)) => signalConnect('post-activate', func, after);
  Stream<Action> get onPostActivate {
    int signalId;
    StreamController<Action> controller;
    controller = new StreamController<Action>(
      onListen: () {
          signalId = _connectToPostActivate(false, (Action action) {
              controller.add(action);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Action> get afterPostActivate {
    int signalId;
    StreamController<Action> controller;
    controller = new StreamController<Action>(
      onListen: () {
          signalId = _connectToPostActivate(true, (Action action) {
              controller.add(action);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPreActivate(bool after, void func(Action action)) => signalConnect('pre-activate', func, after);
  Stream<Action> get onPreActivate {
    int signalId;
    StreamController<Action> controller;
    controller = new StreamController<Action>(
      onListen: () {
          signalId = _connectToPreActivate(false, (Action action) {
              controller.add(action);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Action> get afterPreActivate {
    int signalId;
    StreamController<Action> controller;
    controller = new StreamController<Action>(
      onListen: () {
          signalId = _connectToPreActivate(true, (Action action) {
              controller.add(action);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ActionGroupConnectProxyEvent {
  final Action action;
  final Widget proxy;

  ActionGroupConnectProxyEvent(this.action, this.proxy);
}

class ActionGroupDisconnectProxyEvent {
  final Action action;
  final Widget proxy;

  ActionGroupDisconnectProxyEvent(this.action, this.proxy);
}

abstract class Actionable extends GObjectBase implements Widget {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Actionable');

  static const String ACTION_NAME_PROPERTY = 'action-name';
  Variant get actionTarget => _staticInfo.getGPropertyOnReceiver('action-target', this);
  void set actionTarget(Variant value) => _staticInfo.setGPropertyOnReceiver('action-target', this, value);
  static const String ACTION_TARGET_PROPERTY = 'action-target';
  String get actionName => _staticInfo.callMethodOnReceiver('get_action_name', this, []);
  Variant getActionTargetValue() => _staticInfo.callMethodOnReceiver('get_action_target_value', this, []);
  void set actionName(String actionName) => _staticInfo.callMethodOnReceiver('set_action_name', this, [actionName]);
  void setActionTargetValue(Variant targetValue) => _staticInfo.callMethodOnReceiver('set_action_target_value', this, [targetValue]);
  void setDetailedActionName(String detailedActionName) => _staticInfo.callMethodOnReceiver('set_detailed_action_name', this, [detailedActionName]);
}

abstract class Activatable extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Activatable');

  static const String RELATED_ACTION_PROPERTY = 'related-action';
  static const String USE_ACTION_APPEARANCE_PROPERTY = 'use-action-appearance';
  void doSetRelatedAction(Action action) => _staticInfo.callMethodOnReceiver('do_set_related_action', this, [action]);
  Action get relatedAction => _staticInfo.callMethodOnReceiver('get_related_action', this, []);
  bool get useActionAppearance => _staticInfo.callMethodOnReceiver('get_use_action_appearance', this, []);
  void set relatedAction(Action action) => _staticInfo.callMethodOnReceiver('set_related_action', this, [action]);
  void set useActionAppearance(bool useAppearance) => _staticInfo.callMethodOnReceiver('set_use_action_appearance', this, [useAppearance]);
  void syncActionProperties(Action action) => _staticInfo.callMethodOnReceiver('sync_action_properties', this, [action]);
}

class Adjustment extends InitiallyUnowned {
  Adjustment.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Adjustment');

  static const String LOWER_PROPERTY = 'lower';
  static const String PAGE_INCREMENT_PROPERTY = 'page-increment';
  static const String PAGE_SIZE_PROPERTY = 'page-size';
  static const String STEP_INCREMENT_PROPERTY = 'step-increment';
  static const String UPPER_PROPERTY = 'upper';
  static const String VALUE_PROPERTY = 'value';
  factory Adjustment(num value, num lower, num upper, num stepIncrement, num pageIncrement, num pageSize) => _staticInfo.callStatic('new', [value, lower, upper, stepIncrement, pageIncrement, pageSize]);
  void changed() => _staticInfo.callMethodOnReceiver('changed', this, []);
  void clampPage(num lower, num upper) => _staticInfo.callMethodOnReceiver('clamp_page', this, [lower, upper]);
  void configure(num value, num lower, num upper, num stepIncrement, num pageIncrement, num pageSize) => _staticInfo.callMethodOnReceiver('configure', this, [value, lower, upper, stepIncrement, pageIncrement, pageSize]);
  num get lower => _staticInfo.callMethodOnReceiver('get_lower', this, []);
  num getMinimumIncrement() => _staticInfo.callMethodOnReceiver('get_minimum_increment', this, []);
  num get pageIncrement => _staticInfo.callMethodOnReceiver('get_page_increment', this, []);
  num get pageSize => _staticInfo.callMethodOnReceiver('get_page_size', this, []);
  num get stepIncrement => _staticInfo.callMethodOnReceiver('get_step_increment', this, []);
  num get upper => _staticInfo.callMethodOnReceiver('get_upper', this, []);
  num get value => _staticInfo.callMethodOnReceiver('get_value', this, []);
  void set lower(num lower) => _staticInfo.callMethodOnReceiver('set_lower', this, [lower]);
  void set pageIncrement(num pageIncrement) => _staticInfo.callMethodOnReceiver('set_page_increment', this, [pageIncrement]);
  void set pageSize(num pageSize) => _staticInfo.callMethodOnReceiver('set_page_size', this, [pageSize]);
  void set stepIncrement(num stepIncrement) => _staticInfo.callMethodOnReceiver('set_step_increment', this, [stepIncrement]);
  void set upper(num upper) => _staticInfo.callMethodOnReceiver('set_upper', this, [upper]);
  void set value(num value) => _staticInfo.callMethodOnReceiver('set_value', this, [value]);
  void valueChanged() => _staticInfo.callMethodOnReceiver('value_changed', this, []);
  int _connectToChanged(bool after, void func()) => signalConnect('changed', func, after);
  Stream get onChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToValueChanged(bool after, void func()) => signalConnect('value-changed', func, after);
  Stream get onValueChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToValueChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterValueChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToValueChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class Align extends GEnumBase {
  const Align(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Align');

  static const Align FILL = const Align(0);
  static const Align START = const Align(1);
  static const Align END = const Align(2);
  static const Align CENTER = const Align(3);
  static const Align BASELINE = const Align(4);
  String toString() {
    switch(index) {
      case 0: return 'Align.FILL';
      case 1: return 'Align.START';
      case 2: return 'Align.END';
      case 3: return 'Align.CENTER';
      case 4: return 'Align.BASELINE';
      default: return 'new Align($index)';
    }
  }
}

class Alignment extends Bin with ImplementorIface, Buildable {
  Alignment.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Alignment');

  int get bottomPadding => _staticInfo.getGPropertyOnReceiver('bottom-padding', this);
  void set bottomPadding(int value) => _staticInfo.setGPropertyOnReceiver('bottom-padding', this, value);
  static const String BOTTOM_PADDING_PROPERTY = 'bottom-padding';
  int get leftPadding => _staticInfo.getGPropertyOnReceiver('left-padding', this);
  void set leftPadding(int value) => _staticInfo.setGPropertyOnReceiver('left-padding', this, value);
  static const String LEFT_PADDING_PROPERTY = 'left-padding';
  int get rightPadding => _staticInfo.getGPropertyOnReceiver('right-padding', this);
  void set rightPadding(int value) => _staticInfo.setGPropertyOnReceiver('right-padding', this, value);
  static const String RIGHT_PADDING_PROPERTY = 'right-padding';
  int get topPadding => _staticInfo.getGPropertyOnReceiver('top-padding', this);
  void set topPadding(int value) => _staticInfo.setGPropertyOnReceiver('top-padding', this, value);
  static const String TOP_PADDING_PROPERTY = 'top-padding';
  num get xalign => _staticInfo.getGPropertyOnReceiver('xalign', this);
  void set xalign(num value) => _staticInfo.setGPropertyOnReceiver('xalign', this, value);
  static const String XALIGN_PROPERTY = 'xalign';
  num get xscale => _staticInfo.getGPropertyOnReceiver('xscale', this);
  void set xscale(num value) => _staticInfo.setGPropertyOnReceiver('xscale', this, value);
  static const String XSCALE_PROPERTY = 'xscale';
  num get yalign => _staticInfo.getGPropertyOnReceiver('yalign', this);
  void set yalign(num value) => _staticInfo.setGPropertyOnReceiver('yalign', this, value);
  static const String YALIGN_PROPERTY = 'yalign';
  num get yscale => _staticInfo.getGPropertyOnReceiver('yscale', this);
  void set yscale(num value) => _staticInfo.setGPropertyOnReceiver('yscale', this, value);
  static const String YSCALE_PROPERTY = 'yscale';
  factory Alignment(num xalign, num yalign, num xscale, num yscale) => _staticInfo.callStatic('new', [xalign, yalign, xscale, yscale]);
  void getPadding() => _staticInfo.callMethodOnReceiver('get_padding', this, []);
  void set_(num xalign, num yalign, num xscale, num yscale) => _staticInfo.callMethodOnReceiver('set', this, [xalign, yalign, xscale, yscale]);
  void setPadding(int paddingTop, int paddingBottom, int paddingLeft, int paddingRight) => _staticInfo.callMethodOnReceiver('set_padding', this, [paddingTop, paddingBottom, paddingLeft, paddingRight]);
}

abstract class AppChooser extends GObjectBase implements Widget {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AppChooser');

  void set contentType(String value) => _staticInfo.setGPropertyOnReceiver('content-type', this, value);
  static const String CONTENT_TYPE_PROPERTY = 'content-type';
  AppInfo getAppInfo() => _staticInfo.callMethodOnReceiver('get_app_info', this, []);
  String get contentType_ => _staticInfo.callMethodOnReceiver('get_content_type', this, []);
  void refresh() => _staticInfo.callMethodOnReceiver('refresh', this, []);
}

class AppChooserButton extends ComboBox with ImplementorIface, AppChooser, Buildable, CellEditable, CellLayout {
  AppChooserButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AppChooserButton');

  static const String HEADING_PROPERTY = 'heading';
  static const String SHOW_DEFAULT_ITEM_PROPERTY = 'show-default-item';
  static const String SHOW_DIALOG_ITEM_PROPERTY = 'show-dialog-item';
  factory AppChooserButton(String contentType) => _staticInfo.callStatic('new', [contentType]);
  void appendCustomItem(String name, String label, Icon icon) => _staticInfo.callMethodOnReceiver('append_custom_item', this, [name, label, icon]);
  void appendSeparator() => _staticInfo.callMethodOnReceiver('append_separator', this, []);
  String get heading => _staticInfo.callMethodOnReceiver('get_heading', this, []);
  bool get showDefaultItem => _staticInfo.callMethodOnReceiver('get_show_default_item', this, []);
  bool get showDialogItem => _staticInfo.callMethodOnReceiver('get_show_dialog_item', this, []);
  void setActiveCustomItem(String name) => _staticInfo.callMethodOnReceiver('set_active_custom_item', this, [name]);
  void set heading(String heading) => _staticInfo.callMethodOnReceiver('set_heading', this, [heading]);
  void set showDefaultItem(bool setting) => _staticInfo.callMethodOnReceiver('set_show_default_item', this, [setting]);
  void set showDialogItem(bool setting) => _staticInfo.callMethodOnReceiver('set_show_dialog_item', this, [setting]);
  int _connectToCustomItemActivated(bool after, void func(String itemName)) => signalConnect('custom-item-activated', func, after);
  Stream<String> get onCustomItemActivated {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToCustomItemActivated(false, (String itemName) {
              controller.add(itemName);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<String> get afterCustomItemActivated {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToCustomItemActivated(true, (String itemName) {
              controller.add(itemName);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class AppChooserDialog extends Dialog with ImplementorIface, AppChooser, Buildable {
  AppChooserDialog.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AppChooserDialog');

  File get gfile => _staticInfo.getGPropertyOnReceiver('gfile', this);
  void set gfile(File value) => _staticInfo.setGPropertyOnReceiver('gfile', this, value);
  static const String GFILE_PROPERTY = 'gfile';
  static const String HEADING_PROPERTY = 'heading';
  factory AppChooserDialog(Window parent, DialogFlags flags, File file) => _staticInfo.callStatic('new', [parent, flags, file]);
  factory AppChooserDialog.forContentType(Window parent, DialogFlags flags, String contentType) => _staticInfo.callStatic('new_for_content_type', [parent, flags, contentType]);
  String get heading => _staticInfo.callMethodOnReceiver('get_heading', this, []);
  Widget getWidget() => _staticInfo.callMethodOnReceiver('get_widget', this, []);
  void set heading(String heading) => _staticInfo.callMethodOnReceiver('set_heading', this, [heading]);
}

class AppChooserWidget extends Box with ImplementorIface, AppChooser, Buildable, Orientable {
  AppChooserWidget.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AppChooserWidget');

  static const String DEFAULT_TEXT_PROPERTY = 'default-text';
  static const String SHOW_ALL_PROPERTY = 'show-all';
  static const String SHOW_DEFAULT_PROPERTY = 'show-default';
  static const String SHOW_FALLBACK_PROPERTY = 'show-fallback';
  static const String SHOW_OTHER_PROPERTY = 'show-other';
  static const String SHOW_RECOMMENDED_PROPERTY = 'show-recommended';
  factory AppChooserWidget(String contentType) => _staticInfo.callStatic('new', [contentType]);
  String get defaultText => _staticInfo.callMethodOnReceiver('get_default_text', this, []);
  bool get appChooserWidgetShowAll => _staticInfo.callMethodOnReceiver('get_show_all', this, []);
  bool get showDefault => _staticInfo.callMethodOnReceiver('get_show_default', this, []);
  bool get showFallback => _staticInfo.callMethodOnReceiver('get_show_fallback', this, []);
  bool get showOther => _staticInfo.callMethodOnReceiver('get_show_other', this, []);
  bool get showRecommended => _staticInfo.callMethodOnReceiver('get_show_recommended', this, []);
  void set defaultText(String text) => _staticInfo.callMethodOnReceiver('set_default_text', this, [text]);
  void set appChooserWidgetShowAll(bool setting) => _staticInfo.callMethodOnReceiver('set_show_all', this, [setting]);
  void set showDefault(bool setting) => _staticInfo.callMethodOnReceiver('set_show_default', this, [setting]);
  void set showFallback(bool setting) => _staticInfo.callMethodOnReceiver('set_show_fallback', this, [setting]);
  void set showOther(bool setting) => _staticInfo.callMethodOnReceiver('set_show_other', this, [setting]);
  void set showRecommended(bool setting) => _staticInfo.callMethodOnReceiver('set_show_recommended', this, [setting]);
  int _connectToApplicationActivated(bool after, void func(AppInfo application)) => signalConnect('application-activated', func, after);
  Stream<AppInfo> get onApplicationActivated {
    int signalId;
    StreamController<AppInfo> controller;
    controller = new StreamController<AppInfo>(
      onListen: () {
          signalId = _connectToApplicationActivated(false, (AppInfo application) {
              controller.add(application);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<AppInfo> get afterApplicationActivated {
    int signalId;
    StreamController<AppInfo> controller;
    controller = new StreamController<AppInfo>(
      onListen: () {
          signalId = _connectToApplicationActivated(true, (AppInfo application) {
              controller.add(application);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToApplicationSelected(bool after, void func(AppInfo application)) => signalConnect('application-selected', func, after);
  Stream<AppInfo> get onApplicationSelected {
    int signalId;
    StreamController<AppInfo> controller;
    controller = new StreamController<AppInfo>(
      onListen: () {
          signalId = _connectToApplicationSelected(false, (AppInfo application) {
              controller.add(application);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<AppInfo> get afterApplicationSelected {
    int signalId;
    StreamController<AppInfo> controller;
    controller = new StreamController<AppInfo>(
      onListen: () {
          signalId = _connectToApplicationSelected(true, (AppInfo application) {
              controller.add(application);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPopulatePopup(bool after, void func(Menu menu, AppInfo application)) => signalConnect('populate-popup', func, after);
  Stream<AppChooserWidgetPopulatePopupEvent> get onPopulatePopup {
    int signalId;
    StreamController<AppChooserWidgetPopulatePopupEvent> controller;
    controller = new StreamController<AppChooserWidgetPopulatePopupEvent>(
      onListen: () {
          signalId = _connectToPopulatePopup(false, (Menu menu, AppInfo application) {
              var result = new AppChooserWidgetPopulatePopupEvent(menu, application);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<AppChooserWidgetPopulatePopupEvent> get afterPopulatePopup {
    int signalId;
    StreamController<AppChooserWidgetPopulatePopupEvent> controller;
    controller = new StreamController<AppChooserWidgetPopulatePopupEvent>(
      onListen: () {
          signalId = _connectToPopulatePopup(true, (Menu menu, AppInfo application) {
              var result = new AppChooserWidgetPopulatePopupEvent(menu, application);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class AppChooserWidgetPopulatePopupEvent {
  final Menu menu;
  final AppInfo application;

  AppChooserWidgetPopulatePopupEvent(this.menu, this.application);
}

class Application extends gio.Application with gio.ActionGroup, ActionMap {
  Application.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Application');

  static const String ACTIVE_WINDOW_PROPERTY = 'active-window';
  static const String APP_MENU_PROPERTY = 'app-menu';
  static const String MENUBAR_PROPERTY = 'menubar';
  bool get registerSession => _staticInfo.getGPropertyOnReceiver('register-session', this);
  void set registerSession(bool value) => _staticInfo.setGPropertyOnReceiver('register-session', this, value);
  static const String REGISTER_SESSION_PROPERTY = 'register-session';
  factory Application(String applicationId, ApplicationFlags flags) => _staticInfo.callStatic('new', [applicationId, flags]);
  void addAccelerator(String accelerator, String actionName, Variant parameter) => _staticInfo.callMethodOnReceiver('add_accelerator', this, [accelerator, actionName, parameter]);
  void addWindow(Window window) => _staticInfo.callMethodOnReceiver('add_window', this, [window]);
  List<String> getAccelsForAction(String detailedActionName) => _staticInfo.callMethodOnReceiver('get_accels_for_action', this, [detailedActionName]);
  List<String> getActionsForAccel(String accel) => _staticInfo.callMethodOnReceiver('get_actions_for_accel', this, [accel]);
  Window get activeWindow => _staticInfo.callMethodOnReceiver('get_active_window', this, []);
  MenuModel get appMenu => _staticInfo.callMethodOnReceiver('get_app_menu', this, []);
  gio.Menu getMenuById(String id) => _staticInfo.callMethodOnReceiver('get_menu_by_id', this, [id]);
  MenuModel get menubar => _staticInfo.callMethodOnReceiver('get_menubar', this, []);
  Window getWindowById(int id) => _staticInfo.callMethodOnReceiver('get_window_by_id', this, [id]);
  GLibList /* this will fail */ getWindows() => _staticInfo.callMethodOnReceiver('get_windows', this, []);
  int inhibit(Window window, ApplicationInhibitFlags flags, String reason) => _staticInfo.callMethodOnReceiver('inhibit', this, [window, flags, reason]);
  bool isInhibited(ApplicationInhibitFlags flags) => _staticInfo.callMethodOnReceiver('is_inhibited', this, [flags]);
  List<String> listActionDescriptions() => _staticInfo.callMethodOnReceiver('list_action_descriptions', this, []);
  bool prefersAppMenu() => _staticInfo.callMethodOnReceiver('prefers_app_menu', this, []);
  void removeAccelerator(String actionName, Variant parameter) => _staticInfo.callMethodOnReceiver('remove_accelerator', this, [actionName, parameter]);
  void removeWindow(Window window) => _staticInfo.callMethodOnReceiver('remove_window', this, [window]);
  void setAccelsForAction(String detailedActionName, List<String> accels) => _staticInfo.callMethodOnReceiver('set_accels_for_action', this, [detailedActionName, accels]);
  void set appMenu(MenuModel appMenu) => _staticInfo.callMethodOnReceiver('set_app_menu', this, [appMenu]);
  void set menubar(MenuModel menubar) => _staticInfo.callMethodOnReceiver('set_menubar', this, [menubar]);
  void uninhibit(int cookie) => _staticInfo.callMethodOnReceiver('uninhibit', this, [cookie]);
  int _connectToWindowAdded(bool after, void func(Window window)) => signalConnect('window-added', func, after);
  Stream<Window> get onWindowAdded {
    int signalId;
    StreamController<Window> controller;
    controller = new StreamController<Window>(
      onListen: () {
          signalId = _connectToWindowAdded(false, (Window window) {
              controller.add(window);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Window> get afterWindowAdded {
    int signalId;
    StreamController<Window> controller;
    controller = new StreamController<Window>(
      onListen: () {
          signalId = _connectToWindowAdded(true, (Window window) {
              controller.add(window);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToWindowRemoved(bool after, void func(Window window)) => signalConnect('window-removed', func, after);
  Stream<Window> get onWindowRemoved {
    int signalId;
    StreamController<Window> controller;
    controller = new StreamController<Window>(
      onListen: () {
          signalId = _connectToWindowRemoved(false, (Window window) {
              controller.add(window);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Window> get afterWindowRemoved {
    int signalId;
    StreamController<Window> controller;
    controller = new StreamController<Window>(
      onListen: () {
          signalId = _connectToWindowRemoved(true, (Window window) {
              controller.add(window);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ApplicationInhibitFlags extends GEnumBase {
  const ApplicationInhibitFlags(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ApplicationInhibitFlags');

  static const ApplicationInhibitFlags NULL = const ApplicationInhibitFlags(0);
  static const ApplicationInhibitFlags LOGOUT = const ApplicationInhibitFlags(1);
  bool get logout => (index & 1) == 1;
  static const ApplicationInhibitFlags SWITCH = const ApplicationInhibitFlags(2);
  bool get switch_ => (index & 2) == 2;
  static const ApplicationInhibitFlags SUSPEND = const ApplicationInhibitFlags(4);
  bool get suspend => (index & 4) == 4;
  static const ApplicationInhibitFlags IDLE = const ApplicationInhibitFlags(8);
  bool get idle => (index & 8) == 8;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'ApplicationInhibitFlags.LOGOUT';
      case 2: return 'ApplicationInhibitFlags.SWITCH';
      case 4: return 'ApplicationInhibitFlags.SUSPEND';
      case 8: return 'ApplicationInhibitFlags.IDLE';
      default: return 'new ApplicationInhibitFlags($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'ApplicationInhibitFlags.NULL';
    }
    List codes = [];
    for (var i=1; i <= 8; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  ApplicationInhibitFlags operator|(ApplicationInhibitFlags other) =>
    new ApplicationInhibitFlags(index | other.index);
  ApplicationInhibitFlags operator&(ApplicationInhibitFlags other) =>
    new ApplicationInhibitFlags(index & other.index);
}

class ApplicationWindow extends Window with ImplementorIface, gio.ActionGroup, ActionMap, Buildable {
  ApplicationWindow.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ApplicationWindow');

  static const String SHOW_MENUBAR_PROPERTY = 'show-menubar';
  factory ApplicationWindow(Application application) => _staticInfo.callStatic('new', [application]);
  int getId() => _staticInfo.callMethodOnReceiver('get_id', this, []);
  bool get showMenubar => _staticInfo.callMethodOnReceiver('get_show_menubar', this, []);
  void set showMenubar(bool showMenubar) => _staticInfo.callMethodOnReceiver('set_show_menubar', this, [showMenubar]);
}

class Arrow extends Misc with ImplementorIface, Buildable {
  Arrow.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Arrow');

  ArrowType get arrowType => _staticInfo.getGPropertyOnReceiver('arrow-type', this);
  void set arrowType(ArrowType value) => _staticInfo.setGPropertyOnReceiver('arrow-type', this, value);
  static const String ARROW_TYPE_PROPERTY = 'arrow-type';
  ShadowType get shadowType => _staticInfo.getGPropertyOnReceiver('shadow-type', this);
  void set shadowType(ShadowType value) => _staticInfo.setGPropertyOnReceiver('shadow-type', this, value);
  static const String SHADOW_TYPE_PROPERTY = 'shadow-type';
  factory Arrow(ArrowType arrowType, ShadowType shadowType) => _staticInfo.callStatic('new', [arrowType, shadowType]);
  void set_(ArrowType arrowType, ShadowType shadowType) => _staticInfo.callMethodOnReceiver('set', this, [arrowType, shadowType]);
}

class ArrowAccessible extends WidgetAccessible with Component, atk.Image {
  ArrowAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ArrowAccessible');

}

class ArrowPlacement extends GEnumBase {
  const ArrowPlacement(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ArrowPlacement');

  static const ArrowPlacement BOTH = const ArrowPlacement(0);
  static const ArrowPlacement START = const ArrowPlacement(1);
  static const ArrowPlacement END = const ArrowPlacement(2);
  String toString() {
    switch(index) {
      case 0: return 'ArrowPlacement.BOTH';
      case 1: return 'ArrowPlacement.START';
      case 2: return 'ArrowPlacement.END';
      default: return 'new ArrowPlacement($index)';
    }
  }
}

class ArrowType extends GEnumBase {
  const ArrowType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ArrowType');

  static const ArrowType UP = const ArrowType(0);
  static const ArrowType DOWN = const ArrowType(1);
  static const ArrowType LEFT = const ArrowType(2);
  static const ArrowType RIGHT = const ArrowType(3);
  static const ArrowType NONE = const ArrowType(4);
  String toString() {
    switch(index) {
      case 0: return 'ArrowType.UP';
      case 1: return 'ArrowType.DOWN';
      case 2: return 'ArrowType.LEFT';
      case 3: return 'ArrowType.RIGHT';
      case 4: return 'ArrowType.NONE';
      default: return 'new ArrowType($index)';
    }
  }
}

class AspectFrame extends Frame with ImplementorIface, Buildable {
  AspectFrame.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AspectFrame');

  bool get obeyChild => _staticInfo.getGPropertyOnReceiver('obey-child', this);
  void set obeyChild(bool value) => _staticInfo.setGPropertyOnReceiver('obey-child', this, value);
  static const String OBEY_CHILD_PROPERTY = 'obey-child';
  num get ratio => _staticInfo.getGPropertyOnReceiver('ratio', this);
  void set ratio(num value) => _staticInfo.setGPropertyOnReceiver('ratio', this, value);
  static const String RATIO_PROPERTY = 'ratio';
  num get xalign => _staticInfo.getGPropertyOnReceiver('xalign', this);
  void set xalign(num value) => _staticInfo.setGPropertyOnReceiver('xalign', this, value);
  static const String XALIGN_PROPERTY = 'xalign';
  num get yalign => _staticInfo.getGPropertyOnReceiver('yalign', this);
  void set yalign(num value) => _staticInfo.setGPropertyOnReceiver('yalign', this, value);
  static const String YALIGN_PROPERTY = 'yalign';
  factory AspectFrame(String label, num xalign, num yalign, num ratio, bool obeyChild) => _staticInfo.callStatic('new', [label, xalign, yalign, ratio, obeyChild]);
  void set_(num xalign, num yalign, num ratio, bool obeyChild) => _staticInfo.callMethodOnReceiver('set', this, [xalign, yalign, ratio, obeyChild]);
}

class Assistant extends Window with ImplementorIface, Buildable {
  Assistant.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Assistant');

  int get useHeaderBar => _staticInfo.getGPropertyOnReceiver('use-header-bar', this);
  void set useHeaderBar(int value) => _staticInfo.setGPropertyOnReceiver('use-header-bar', this, value);
  static const String USE_HEADER_BAR_PROPERTY = 'use-header-bar';
  factory Assistant() => _staticInfo.callStatic('new', []);
  void addActionWidget(Widget child) => _staticInfo.callMethodOnReceiver('add_action_widget', this, [child]);
  int appendPage(Widget page) => _staticInfo.callMethodOnReceiver('append_page', this, [page]);
  void commit() => _staticInfo.callMethodOnReceiver('commit', this, []);
  int getCurrentPage() => _staticInfo.callMethodOnReceiver('get_current_page', this, []);
  int getNPages() => _staticInfo.callMethodOnReceiver('get_n_pages', this, []);
  Widget getNthPage(int pageNum) => _staticInfo.callMethodOnReceiver('get_nth_page', this, [pageNum]);
  bool getPageComplete(Widget page) => _staticInfo.callMethodOnReceiver('get_page_complete', this, [page]);
  bool getPageHasPadding(Widget page) => _staticInfo.callMethodOnReceiver('get_page_has_padding', this, [page]);
  Pixbuf getPageHeaderImage(Widget page) => _staticInfo.callMethodOnReceiver('get_page_header_image', this, [page]);
  Pixbuf getPageSideImage(Widget page) => _staticInfo.callMethodOnReceiver('get_page_side_image', this, [page]);
  String getPageTitle(Widget page) => _staticInfo.callMethodOnReceiver('get_page_title', this, [page]);
  AssistantPageType getPageType(Widget page) => _staticInfo.callMethodOnReceiver('get_page_type', this, [page]);
  int insertPage(Widget page, int position) => _staticInfo.callMethodOnReceiver('insert_page', this, [page, position]);
  void nextPage() => _staticInfo.callMethodOnReceiver('next_page', this, []);
  int prependPage(Widget page) => _staticInfo.callMethodOnReceiver('prepend_page', this, [page]);
  void previousPage() => _staticInfo.callMethodOnReceiver('previous_page', this, []);
  void removeActionWidget(Widget child) => _staticInfo.callMethodOnReceiver('remove_action_widget', this, [child]);
  void removePage(int pageNum) => _staticInfo.callMethodOnReceiver('remove_page', this, [pageNum]);
  void setCurrentPage(int pageNum) => _staticInfo.callMethodOnReceiver('set_current_page', this, [pageNum]);
  void setForwardPageFunc(AssistantPageFunc pageFunc) => _staticInfo.callMethodOnReceiver('set_forward_page_func', this, [pageFunc]);
  void setPageComplete(Widget page, bool complete) => _staticInfo.callMethodOnReceiver('set_page_complete', this, [page, complete]);
  void setPageHasPadding(Widget page, bool hasPadding) => _staticInfo.callMethodOnReceiver('set_page_has_padding', this, [page, hasPadding]);
  void setPageHeaderImage(Widget page, Pixbuf pixbuf) => _staticInfo.callMethodOnReceiver('set_page_header_image', this, [page, pixbuf]);
  void setPageSideImage(Widget page, Pixbuf pixbuf) => _staticInfo.callMethodOnReceiver('set_page_side_image', this, [page, pixbuf]);
  void setPageTitle(Widget page, String title) => _staticInfo.callMethodOnReceiver('set_page_title', this, [page, title]);
  void setPageType(Widget page, AssistantPageType type) => _staticInfo.callMethodOnReceiver('set_page_type', this, [page, type]);
  void updateButtonsState() => _staticInfo.callMethodOnReceiver('update_buttons_state', this, []);
  int _connectToApply(bool after, void func()) => signalConnect('apply', func, after);
  Stream get onApply {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToApply(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterApply {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToApply(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCancel(bool after, void func()) => signalConnect('cancel', func, after);
  Stream get onCancel {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCancel(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterCancel {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCancel(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToClose(bool after, void func()) => signalConnect('close', func, after);
  Stream get onClose {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClose(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterClose {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClose(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToEscape(bool after, void func()) => signalConnect('escape', func, after);
  Stream get onEscape {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToEscape(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterEscape {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToEscape(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPrepare(bool after, void func(Widget page)) => signalConnect('prepare', func, after);
  Stream<Widget> get onPrepare {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToPrepare(false, (Widget page) {
              controller.add(page);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Widget> get afterPrepare {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToPrepare(true, (Widget page) {
              controller.add(page);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

typedef int AssistantPageFunc(int currentPage);
class AssistantPageType extends GEnumBase {
  const AssistantPageType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AssistantPageType');

  static const AssistantPageType CONTENT = const AssistantPageType(0);
  static const AssistantPageType INTRO = const AssistantPageType(1);
  static const AssistantPageType CONFIRM = const AssistantPageType(2);
  static const AssistantPageType SUMMARY = const AssistantPageType(3);
  static const AssistantPageType PROGRESS = const AssistantPageType(4);
  static const AssistantPageType CUSTOM = const AssistantPageType(5);
  String toString() {
    switch(index) {
      case 0: return 'AssistantPageType.CONTENT';
      case 1: return 'AssistantPageType.INTRO';
      case 2: return 'AssistantPageType.CONFIRM';
      case 3: return 'AssistantPageType.SUMMARY';
      case 4: return 'AssistantPageType.PROGRESS';
      case 5: return 'AssistantPageType.CUSTOM';
      default: return 'new AssistantPageType($index)';
    }
  }
}

class AttachOptions extends GEnumBase {
  const AttachOptions(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'AttachOptions');

  static const AttachOptions NULL = const AttachOptions(0);
  static const AttachOptions EXPAND = const AttachOptions(1);
  bool get expand => (index & 1) == 1;
  static const AttachOptions SHRINK = const AttachOptions(2);
  bool get shrink => (index & 2) == 2;
  static const AttachOptions FILL = const AttachOptions(4);
  bool get fill => (index & 4) == 4;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'AttachOptions.EXPAND';
      case 2: return 'AttachOptions.SHRINK';
      case 4: return 'AttachOptions.FILL';
      default: return 'new AttachOptions($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'AttachOptions.NULL';
    }
    List codes = [];
    for (var i=1; i <= 4; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  AttachOptions operator|(AttachOptions other) =>
    new AttachOptions(index | other.index);
  AttachOptions operator&(AttachOptions other) =>
    new AttachOptions(index & other.index);
}

class BaselinePosition extends GEnumBase {
  const BaselinePosition(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'BaselinePosition');

  static const BaselinePosition TOP = const BaselinePosition(0);
  static const BaselinePosition CENTER = const BaselinePosition(1);
  static const BaselinePosition BOTTOM = const BaselinePosition(2);
  String toString() {
    switch(index) {
      case 0: return 'BaselinePosition.TOP';
      case 1: return 'BaselinePosition.CENTER';
      case 2: return 'BaselinePosition.BOTTOM';
      default: return 'new BaselinePosition($index)';
    }
  }
}

class Bin extends Container with ImplementorIface, Buildable {
  Bin.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Bin');

  Widget getChild() => _staticInfo.callMethodOnReceiver('get_child', this, []);
}

class BindingArg extends GObjectBase {
  BindingArg.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'BindingArg');

  int get argType => getFieldOfObject('arg_type', 0);
  void set argType(int value) => setFieldOfObject('arg_type', 0, value);
}

class BindingEntry extends GObjectBase {
  BindingEntry.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'BindingEntry');

  int get keyval => getFieldOfObject('keyval', 0);
  void set keyval(int value) => setFieldOfObject('keyval', 0, value);
  ModifierType get modifiers => getFieldOfObject('modifiers', 1);
  void set modifiers(ModifierType value) => setFieldOfObject('modifiers', 1, value);
  BindingSet get bindingSet => getFieldOfObject('binding_set', 2);
  void set bindingSet(BindingSet value) => setFieldOfObject('binding_set', 2, value);
  int get destroyed => getFieldOfObject('destroyed', 3);
  void set destroyed(int value) => setFieldOfObject('destroyed', 3, value);
  int get inEmission => getFieldOfObject('in_emission', 4);
  void set inEmission(int value) => setFieldOfObject('in_emission', 4, value);
  int get marksUnbound => getFieldOfObject('marks_unbound', 5);
  void set marksUnbound(int value) => setFieldOfObject('marks_unbound', 5, value);
  BindingEntry get setNext => getFieldOfObject('set_next', 6);
  void set setNext(BindingEntry value) => setFieldOfObject('set_next', 6, value);
  BindingEntry get hashNext => getFieldOfObject('hash_next', 7);
  void set hashNext(BindingEntry value) => setFieldOfObject('hash_next', 7, value);
  BindingSignal get signals => getFieldOfObject('signals', 8);
  void set signals(BindingSignal value) => setFieldOfObject('signals', 8, value);
  static TokenType addSignalFromString(BindingSet bindingSet, String signalDesc) => _staticInfo.callStatic('add_signal_from_string', [bindingSet, signalDesc]);
  static void addSignall(BindingSet bindingSet, int keyval, ModifierType modifiers, String signalName, SList bindingArgs /* this will fail */) => _staticInfo.callStatic('add_signall', [bindingSet, keyval, modifiers, signalName, bindingArgs]);
  static void remove(BindingSet bindingSet, int keyval, ModifierType modifiers) => _staticInfo.callStatic('remove', [bindingSet, keyval, modifiers]);
  static void skip(BindingSet bindingSet, int keyval, ModifierType modifiers) => _staticInfo.callStatic('skip', [bindingSet, keyval, modifiers]);
}

class BindingSet extends GObjectBase {
  BindingSet.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'BindingSet');

  String get setName => getFieldOfObject('set_name', 0);
  void set setName(String value) => setFieldOfObject('set_name', 0, value);
  int get priority => getFieldOfObject('priority', 1);
  void set priority(int value) => setFieldOfObject('priority', 1, value);
  SList /* this will fail */ get widgetPathPspecs => getFieldOfObject('widget_path_pspecs', 2);
  void set widgetPathPspecs(SList value /* this will fail */) => setFieldOfObject('widget_path_pspecs', 2, value);
  SList /* this will fail */ get widgetClassPspecs => getFieldOfObject('widget_class_pspecs', 3);
  void set widgetClassPspecs(SList value /* this will fail */) => setFieldOfObject('widget_class_pspecs', 3, value);
  SList /* this will fail */ get classBranchPspecs => getFieldOfObject('class_branch_pspecs', 4);
  void set classBranchPspecs(SList value /* this will fail */) => setFieldOfObject('class_branch_pspecs', 4, value);
  BindingEntry get entries => getFieldOfObject('entries', 5);
  void set entries(BindingEntry value) => setFieldOfObject('entries', 5, value);
  BindingEntry get current => getFieldOfObject('current', 6);
  void set current(BindingEntry value) => setFieldOfObject('current', 6, value);
  int get parsed => getFieldOfObject('parsed', 7);
  void set parsed(int value) => setFieldOfObject('parsed', 7, value);
  bool activate(int keyval, ModifierType modifiers, GObjectObject object) => _staticInfo.callMethodOnReceiver('activate', this, [keyval, modifiers, object]);
  void addPath(PathType pathType, String pathCairoPattern, PathPriorityType priority) => _staticInfo.callMethodOnReceiver('add_path', this, [pathType, pathCairoPattern, priority]);
  static BindingSet find(String setName) => _staticInfo.callStatic('find', [setName]);
}

class BindingSignal extends GObjectBase {
  BindingSignal.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'BindingSignal');

  BindingSignal get next => getFieldOfObject('next', 0);
  void set next(BindingSignal value) => setFieldOfObject('next', 0, value);
  String get signalName => getFieldOfObject('signal_name', 1);
  void set signalName(String value) => setFieldOfObject('signal_name', 1, value);
  int get nArgs => getFieldOfObject('n_args', 2);
  void set nArgs(int value) => setFieldOfObject('n_args', 2, value);
  List<BindingArg> get args => getFieldOfObject('args', 3);
  void set args(List<BindingArg> value) => setFieldOfObject('args', 3, value);
}

class BooleanCellAccessible extends RendererCellAccessible with atk.Action, Component {
  BooleanCellAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'BooleanCellAccessible');

}

class Border extends GObjectBase {
  Border.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Border');

  int get left => getFieldOfObject('left', 0);
  void set left(int value) => setFieldOfObject('left', 0, value);
  int get right => getFieldOfObject('right', 1);
  void set right(int value) => setFieldOfObject('right', 1, value);
  int get top => getFieldOfObject('top', 2);
  void set top(int value) => setFieldOfObject('top', 2, value);
  int get bottom => getFieldOfObject('bottom', 3);
  void set bottom(int value) => setFieldOfObject('bottom', 3, value);
  factory Border() => _staticInfo.callStatic('new', []);
  Border copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void free() => _staticInfo.callMethodOnReceiver('free', this, []);
}

class BorderStyle extends GEnumBase {
  const BorderStyle(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'BorderStyle');

  static const BorderStyle NONE = const BorderStyle(0);
  static const BorderStyle SOLID = const BorderStyle(1);
  static const BorderStyle INSET = const BorderStyle(2);
  static const BorderStyle OUTSET = const BorderStyle(3);
  static const BorderStyle HIDDEN = const BorderStyle(4);
  static const BorderStyle DOTTED = const BorderStyle(5);
  static const BorderStyle DASHED = const BorderStyle(6);
  static const BorderStyle DOUBLE = const BorderStyle(7);
  static const BorderStyle GROOVE = const BorderStyle(8);
  static const BorderStyle RIDGE = const BorderStyle(9);
  String toString() {
    switch(index) {
      case 0: return 'BorderStyle.NONE';
      case 1: return 'BorderStyle.SOLID';
      case 2: return 'BorderStyle.INSET';
      case 3: return 'BorderStyle.OUTSET';
      case 4: return 'BorderStyle.HIDDEN';
      case 5: return 'BorderStyle.DOTTED';
      case 6: return 'BorderStyle.DASHED';
      case 7: return 'BorderStyle.DOUBLE';
      case 8: return 'BorderStyle.GROOVE';
      case 9: return 'BorderStyle.RIDGE';
      default: return 'new BorderStyle($index)';
    }
  }
}

class Box extends Container with ImplementorIface, Buildable, Orientable {
  Box.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Box');

  static const String BASELINE_POSITION_PROPERTY = 'baseline-position';
  static const String HOMOGENEOUS_PROPERTY = 'homogeneous';
  static const String SPACING_PROPERTY = 'spacing';
  factory Box(Orientation orientation, int spacing) => _staticInfo.callStatic('new', [orientation, spacing]);
  BaselinePosition get baselinePosition => _staticInfo.callMethodOnReceiver('get_baseline_position', this, []);
  Widget getCenterWidget() => _staticInfo.callMethodOnReceiver('get_center_widget', this, []);
  bool get homogeneous => _staticInfo.callMethodOnReceiver('get_homogeneous', this, []);
  int get spacing => _staticInfo.callMethodOnReceiver('get_spacing', this, []);
  void packEnd(Widget child, bool expand, bool fill, int padding) => _staticInfo.callMethodOnReceiver('pack_end', this, [child, expand, fill, padding]);
  void packStart(Widget child, bool expand, bool fill, int padding) => _staticInfo.callMethodOnReceiver('pack_start', this, [child, expand, fill, padding]);
  void queryChildPacking(Widget child) => _staticInfo.callMethodOnReceiver('query_child_packing', this, [child]);
  void reorderChild(Widget child, int position) => _staticInfo.callMethodOnReceiver('reorder_child', this, [child, position]);
  void set baselinePosition(BaselinePosition position) => _staticInfo.callMethodOnReceiver('set_baseline_position', this, [position]);
  void setCenterWidget(Widget widget) => _staticInfo.callMethodOnReceiver('set_center_widget', this, [widget]);
  void setChildPacking(Widget child, bool expand, bool fill, int padding, PackType packType) => _staticInfo.callMethodOnReceiver('set_child_packing', this, [child, expand, fill, padding, packType]);
  void set homogeneous(bool homogeneous) => _staticInfo.callMethodOnReceiver('set_homogeneous', this, [homogeneous]);
  void set spacing(int spacing) => _staticInfo.callMethodOnReceiver('set_spacing', this, [spacing]);
}

abstract class Buildable extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Buildable');

  void addChild(Builder builder, GObjectObject child, String type) => _staticInfo.callMethodOnReceiver('add_child', this, [builder, child, type]);
  GObjectObject constructChild(Builder builder, String name) => _staticInfo.callMethodOnReceiver('construct_child', this, [builder, name]);
  void customFinished(Builder builder, GObjectObject child, String tagname, dynamic data /* this will fail */) => _staticInfo.callMethodOnReceiver('custom_finished', this, [builder, child, tagname, data]);
  void customTagEnd(Builder builder, GObjectObject child, String tagname, dynamic data /* this will fail */) => _staticInfo.callMethodOnReceiver('custom_tag_end', this, [builder, child, tagname, data]);
  bool customTagStart(Builder builder, GObjectObject child, String tagname) => _staticInfo.callMethodOnReceiver('custom_tag_start', this, [builder, child, tagname]);
  GObjectObject getInternalChild(Builder builder, String childname) => _staticInfo.callMethodOnReceiver('get_internal_child', this, [builder, childname]);
  String getName() => _staticInfo.callMethodOnReceiver('get_name', this, []);
  void parserFinished(Builder builder) => _staticInfo.callMethodOnReceiver('parser_finished', this, [builder]);
  void setBuildableProperty(Builder builder, String name, Value value) => _staticInfo.callMethodOnReceiver('set_buildable_property', this, [builder, name, value]);
  void setName(String name) => _staticInfo.callMethodOnReceiver('set_name', this, [name]);
}

class Builder extends GObjectObject {
  Builder.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Builder');

  static const String TRANSLATION_DOMAIN_PROPERTY = 'translation-domain';
  factory Builder() => _staticInfo.callStatic('new', []);
  factory Builder.fromFile(String filename) => _staticInfo.callStatic('new_from_file', [filename]);
  factory Builder.fromResource(String resourcePath) => _staticInfo.callStatic('new_from_resource', [resourcePath]);
  factory Builder.fromString(String string, int length) => _staticInfo.callStatic('new_from_string', [string, length]);
  void addCallbackSymbol(String callbackName, Callback callbackSymbol) => _staticInfo.callMethodOnReceiver('add_callback_symbol', this, [callbackName, callbackSymbol]);
  int addFromFile(String filename) => _staticInfo.callMethodOnReceiver('add_from_file', this, [filename]);
  int addFromResource(String resourcePath) => _staticInfo.callMethodOnReceiver('add_from_resource', this, [resourcePath]);
  int addFromString(String buffer, int length) => _staticInfo.callMethodOnReceiver('add_from_string', this, [buffer, length]);
  int addObjectsFromFile(String filename, List<String> objectIds) => _staticInfo.callMethodOnReceiver('add_objects_from_file', this, [filename, objectIds]);
  int addObjectsFromResource(String resourcePath, List<String> objectIds) => _staticInfo.callMethodOnReceiver('add_objects_from_resource', this, [resourcePath, objectIds]);
  int addObjectsFromString(String buffer, int length, List<String> objectIds) => _staticInfo.callMethodOnReceiver('add_objects_from_string', this, [buffer, length, objectIds]);
  void connectSignals(dynamic userData /* this will fail */) => _staticInfo.callMethodOnReceiver('connect_signals', this, [userData]);
  void connectSignalsFull(BuilderConnectFunc func) => _staticInfo.callMethodOnReceiver('connect_signals_full', this, [func]);
  void exposeObject(String name, GObjectObject object) => _staticInfo.callMethodOnReceiver('expose_object', this, [name, object]);
  Application getApplication() => _staticInfo.callMethodOnReceiver('get_application', this, []);
  GObjectObject getObject(String name) => _staticInfo.callMethodOnReceiver('get_object', this, [name]);
  SList /* this will fail */ getObjects() => _staticInfo.callMethodOnReceiver('get_objects', this, []);
  String get translationDomain => _staticInfo.callMethodOnReceiver('get_translation_domain', this, []);
  int getTypeFromName(String typeName) => _staticInfo.callMethodOnReceiver('get_type_from_name', this, [typeName]);
  void setApplication(Application application) => _staticInfo.callMethodOnReceiver('set_application', this, [application]);
  void set translationDomain(String domain) => _staticInfo.callMethodOnReceiver('set_translation_domain', this, [domain]);
  bool valueFromString(ParamSpec pspec, String string) => _staticInfo.callMethodOnReceiver('value_from_string', this, [pspec, string]);
  bool valueFromStringType(int type, String string) => _staticInfo.callMethodOnReceiver('value_from_string_type', this, [type, string]);
}

typedef void BuilderConnectFunc(Builder builder, GObjectObject object, String signalName, String handlerName, GObjectObject connectObject, ConnectFlags flags);
class BuilderErrorCode extends GEnumBase {
  const BuilderErrorCode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'BuilderError');

  static const BuilderErrorCode INVALID_TYPE_FUNCTION = const BuilderErrorCode(0);
  static const BuilderErrorCode UNHANDLED_TAG = const BuilderErrorCode(1);
  static const BuilderErrorCode MISSING_ATTRIBUTE = const BuilderErrorCode(2);
  static const BuilderErrorCode INVALID_ATTRIBUTE = const BuilderErrorCode(3);
  static const BuilderErrorCode INVALID_TAG = const BuilderErrorCode(4);
  static const BuilderErrorCode MISSING_PROPERTY_VALUE = const BuilderErrorCode(5);
  static const BuilderErrorCode INVALID_VALUE = const BuilderErrorCode(6);
  static const BuilderErrorCode VERSION_MISMATCH = const BuilderErrorCode(7);
  static const BuilderErrorCode DUPLICATE_ID = const BuilderErrorCode(8);
  static const BuilderErrorCode OBJECT_TYPE_REFUSED = const BuilderErrorCode(9);
  static const BuilderErrorCode TEMPLATE_MISMATCH = const BuilderErrorCode(10);
  static const BuilderErrorCode INVALID_PROPERTY = const BuilderErrorCode(11);
  static const BuilderErrorCode INVALID_SIGNAL = const BuilderErrorCode(12);
  static const BuilderErrorCode INVALID_ID = const BuilderErrorCode(13);
  String toString() {
    switch(index) {
      case 0: return 'BuilderErrorCode.INVALID_TYPE_FUNCTION';
      case 1: return 'BuilderErrorCode.UNHANDLED_TAG';
      case 2: return 'BuilderErrorCode.MISSING_ATTRIBUTE';
      case 3: return 'BuilderErrorCode.INVALID_ATTRIBUTE';
      case 4: return 'BuilderErrorCode.INVALID_TAG';
      case 5: return 'BuilderErrorCode.MISSING_PROPERTY_VALUE';
      case 6: return 'BuilderErrorCode.INVALID_VALUE';
      case 7: return 'BuilderErrorCode.VERSION_MISMATCH';
      case 8: return 'BuilderErrorCode.DUPLICATE_ID';
      case 9: return 'BuilderErrorCode.OBJECT_TYPE_REFUSED';
      case 10: return 'BuilderErrorCode.TEMPLATE_MISMATCH';
      case 11: return 'BuilderErrorCode.INVALID_PROPERTY';
      case 12: return 'BuilderErrorCode.INVALID_SIGNAL';
      case 13: return 'BuilderErrorCode.INVALID_ID';
      default: return 'new BuilderErrorCode($index)';
    }
  }
  static int quark() => _staticInfo.callStatic('quark', []);
}

class BuilderError extends GErrorBase {
  static final int _quark = lookupErrorQuarkFromString('gtk-builder-error-quark');
  BuilderError(BuilderErrorCode code, String message)
      : super.fromFields(_quark, code, message);
}

class Button extends Bin with ImplementorIface, Actionable, Activatable, Buildable {
  Button.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Button');

  static const String ALWAYS_SHOW_IMAGE_PROPERTY = 'always-show-image';
  static const String FOCUS_ON_CLICK_PROPERTY = 'focus-on-click';
  static const String IMAGE_PROPERTY = 'image';
  static const String IMAGE_POSITION_PROPERTY = 'image-position';
  static const String LABEL_PROPERTY = 'label';
  static const String RELIEF_PROPERTY = 'relief';
  static const String USE_STOCK_PROPERTY = 'use-stock';
  static const String USE_UNDERLINE_PROPERTY = 'use-underline';
  num get xalign => _staticInfo.getGPropertyOnReceiver('xalign', this);
  void set xalign(num value) => _staticInfo.setGPropertyOnReceiver('xalign', this, value);
  static const String XALIGN_PROPERTY = 'xalign';
  num get yalign => _staticInfo.getGPropertyOnReceiver('yalign', this);
  void set yalign(num value) => _staticInfo.setGPropertyOnReceiver('yalign', this, value);
  static const String YALIGN_PROPERTY = 'yalign';
  factory Button() => _staticInfo.callStatic('new', []);
  factory Button.fromIconName(String iconName, int size) => _staticInfo.callStatic('new_from_icon_name', [iconName, size]);
  factory Button.fromStock(String stockId) => _staticInfo.callStatic('new_from_stock', [stockId]);
  factory Button.withLabel(String label) => _staticInfo.callStatic('new_with_label', [label]);
  factory Button.withMnemonic(String label) => _staticInfo.callStatic('new_with_mnemonic', [label]);
  void clicked() => _staticInfo.callMethodOnReceiver('clicked', this, []);
  void enter() => _staticInfo.callMethodOnReceiver('enter', this, []);
  void getAlignment() => _staticInfo.callMethodOnReceiver('get_alignment', this, []);
  bool get alwaysShowImage => _staticInfo.callMethodOnReceiver('get_always_show_image', this, []);
  gdk.Window getEventWindow() => _staticInfo.callMethodOnReceiver('get_event_window', this, []);
  bool get focusOnClick => _staticInfo.callMethodOnReceiver('get_focus_on_click', this, []);
  Widget get image => _staticInfo.callMethodOnReceiver('get_image', this, []);
  PositionType get imagePosition => _staticInfo.callMethodOnReceiver('get_image_position', this, []);
  String get label => _staticInfo.callMethodOnReceiver('get_label', this, []);
  ReliefStyle get relief => _staticInfo.callMethodOnReceiver('get_relief', this, []);
  bool get useStock => _staticInfo.callMethodOnReceiver('get_use_stock', this, []);
  bool get useUnderline => _staticInfo.callMethodOnReceiver('get_use_underline', this, []);
  void leave() => _staticInfo.callMethodOnReceiver('leave', this, []);
  void pressed() => _staticInfo.callMethodOnReceiver('pressed', this, []);
  void released() => _staticInfo.callMethodOnReceiver('released', this, []);
  void setAlignment(num xalign, num yalign) => _staticInfo.callMethodOnReceiver('set_alignment', this, [xalign, yalign]);
  void set alwaysShowImage(bool alwaysShow) => _staticInfo.callMethodOnReceiver('set_always_show_image', this, [alwaysShow]);
  void set focusOnClick(bool focusOnClick) => _staticInfo.callMethodOnReceiver('set_focus_on_click', this, [focusOnClick]);
  void set image(Widget image) => _staticInfo.callMethodOnReceiver('set_image', this, [image]);
  void set imagePosition(PositionType position) => _staticInfo.callMethodOnReceiver('set_image_position', this, [position]);
  void set label(String label) => _staticInfo.callMethodOnReceiver('set_label', this, [label]);
  void set relief(ReliefStyle relief) => _staticInfo.callMethodOnReceiver('set_relief', this, [relief]);
  void set useStock(bool useStock) => _staticInfo.callMethodOnReceiver('set_use_stock', this, [useStock]);
  void set useUnderline(bool useUnderline) => _staticInfo.callMethodOnReceiver('set_use_underline', this, [useUnderline]);
  int _connectToActivate(bool after, void func()) => signalConnect('activate', func, after);
  Stream get onActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToClicked(bool after, void func()) => signalConnect('clicked', func, after);
  Stream get onClicked {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClicked(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterClicked {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClicked(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToEnter(bool after, void func()) => signalConnect('enter', func, after);
  Stream get onEnter {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToEnter(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterEnter {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToEnter(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToLeave(bool after, void func()) => signalConnect('leave', func, after);
  Stream get onLeave {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToLeave(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterLeave {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToLeave(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPressed(bool after, void func()) => signalConnect('pressed', func, after);
  Stream get onPressed {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPressed(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPressed {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPressed(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToReleased(bool after, void func()) => signalConnect('released', func, after);
  Stream get onReleased {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToReleased(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterReleased {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToReleased(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ButtonAccessible extends ContainerAccessible with atk.Action, Component, atk.Image {
  ButtonAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ButtonAccessible');

}

class ButtonBox extends Box with ImplementorIface, Buildable, Orientable {
  ButtonBox.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ButtonBox');

  ButtonBoxStyle get layoutStyle => _staticInfo.getGPropertyOnReceiver('layout-style', this);
  void set layoutStyle(ButtonBoxStyle value) => _staticInfo.setGPropertyOnReceiver('layout-style', this, value);
  static const String LAYOUT_STYLE_PROPERTY = 'layout-style';
  factory ButtonBox(Orientation orientation) => _staticInfo.callStatic('new', [orientation]);
  bool getChildNonHomogeneous(Widget child) => _staticInfo.callMethodOnReceiver('get_child_non_homogeneous', this, [child]);
  bool getChildSecondary(Widget child) => _staticInfo.callMethodOnReceiver('get_child_secondary', this, [child]);
  ButtonBoxStyle getLayout() => _staticInfo.callMethodOnReceiver('get_layout', this, []);
  void setChildNonHomogeneous(Widget child, bool nonHomogeneous) => _staticInfo.callMethodOnReceiver('set_child_non_homogeneous', this, [child, nonHomogeneous]);
  void setChildSecondary(Widget child, bool isSecondary) => _staticInfo.callMethodOnReceiver('set_child_secondary', this, [child, isSecondary]);
  void setLayout(ButtonBoxStyle layoutStyle) => _staticInfo.callMethodOnReceiver('set_layout', this, [layoutStyle]);
}

class ButtonBoxStyle extends GEnumBase {
  const ButtonBoxStyle(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ButtonBoxStyle');

  static const ButtonBoxStyle SPREAD = const ButtonBoxStyle(1);
  static const ButtonBoxStyle EDGE = const ButtonBoxStyle(2);
  static const ButtonBoxStyle START = const ButtonBoxStyle(3);
  static const ButtonBoxStyle END = const ButtonBoxStyle(4);
  static const ButtonBoxStyle CENTER = const ButtonBoxStyle(5);
  static const ButtonBoxStyle EXPAND = const ButtonBoxStyle(6);
  String toString() {
    switch(index) {
      case 1: return 'ButtonBoxStyle.SPREAD';
      case 2: return 'ButtonBoxStyle.EDGE';
      case 3: return 'ButtonBoxStyle.START';
      case 4: return 'ButtonBoxStyle.END';
      case 5: return 'ButtonBoxStyle.CENTER';
      case 6: return 'ButtonBoxStyle.EXPAND';
      default: return 'new ButtonBoxStyle($index)';
    }
  }
}

class ButtonRole extends GEnumBase {
  const ButtonRole(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ButtonRole');

  static const ButtonRole NORMAL = const ButtonRole(0);
  static const ButtonRole CHECK = const ButtonRole(1);
  static const ButtonRole RADIO = const ButtonRole(2);
  String toString() {
    switch(index) {
      case 0: return 'ButtonRole.NORMAL';
      case 1: return 'ButtonRole.CHECK';
      case 2: return 'ButtonRole.RADIO';
      default: return 'new ButtonRole($index)';
    }
  }
}

class ButtonsType extends GEnumBase {
  const ButtonsType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ButtonsType');

  static const ButtonsType NONE = const ButtonsType(0);
  static const ButtonsType OK = const ButtonsType(1);
  static const ButtonsType CLOSE = const ButtonsType(2);
  static const ButtonsType CANCEL = const ButtonsType(3);
  static const ButtonsType YES_NO = const ButtonsType(4);
  static const ButtonsType OK_CANCEL = const ButtonsType(5);
  String toString() {
    switch(index) {
      case 0: return 'ButtonsType.NONE';
      case 1: return 'ButtonsType.OK';
      case 2: return 'ButtonsType.CLOSE';
      case 3: return 'ButtonsType.CANCEL';
      case 4: return 'ButtonsType.YES_NO';
      case 5: return 'ButtonsType.OK_CANCEL';
      default: return 'new ButtonsType($index)';
    }
  }
}

class Calendar extends Widget with ImplementorIface, Buildable {
  Calendar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Calendar');

  int get day => _staticInfo.getGPropertyOnReceiver('day', this);
  void set day(int value) => _staticInfo.setGPropertyOnReceiver('day', this, value);
  static const String DAY_PROPERTY = 'day';
  static const String DETAIL_HEIGHT_ROWS_PROPERTY = 'detail-height-rows';
  static const String DETAIL_WIDTH_CHARS_PROPERTY = 'detail-width-chars';
  int get month => _staticInfo.getGPropertyOnReceiver('month', this);
  void set month(int value) => _staticInfo.setGPropertyOnReceiver('month', this, value);
  static const String MONTH_PROPERTY = 'month';
  bool get noMonthChange => _staticInfo.getGPropertyOnReceiver('no-month-change', this);
  void set noMonthChange(bool value) => _staticInfo.setGPropertyOnReceiver('no-month-change', this, value);
  static const String NO_MONTH_CHANGE_PROPERTY = 'no-month-change';
  bool get showDayNames => _staticInfo.getGPropertyOnReceiver('show-day-names', this);
  void set showDayNames(bool value) => _staticInfo.setGPropertyOnReceiver('show-day-names', this, value);
  static const String SHOW_DAY_NAMES_PROPERTY = 'show-day-names';
  bool get showDetails => _staticInfo.getGPropertyOnReceiver('show-details', this);
  void set showDetails(bool value) => _staticInfo.setGPropertyOnReceiver('show-details', this, value);
  static const String SHOW_DETAILS_PROPERTY = 'show-details';
  bool get showHeading => _staticInfo.getGPropertyOnReceiver('show-heading', this);
  void set showHeading(bool value) => _staticInfo.setGPropertyOnReceiver('show-heading', this, value);
  static const String SHOW_HEADING_PROPERTY = 'show-heading';
  bool get showWeekNumbers => _staticInfo.getGPropertyOnReceiver('show-week-numbers', this);
  void set showWeekNumbers(bool value) => _staticInfo.setGPropertyOnReceiver('show-week-numbers', this, value);
  static const String SHOW_WEEK_NUMBERS_PROPERTY = 'show-week-numbers';
  int get year => _staticInfo.getGPropertyOnReceiver('year', this);
  void set year(int value) => _staticInfo.setGPropertyOnReceiver('year', this, value);
  static const String YEAR_PROPERTY = 'year';
  factory Calendar() => _staticInfo.callStatic('new', []);
  void clearMarks() => _staticInfo.callMethodOnReceiver('clear_marks', this, []);
  void getDate() => _staticInfo.callMethodOnReceiver('get_date', this, []);
  bool getDayIsMarked(int day) => _staticInfo.callMethodOnReceiver('get_day_is_marked', this, [day]);
  int get detailHeightRows => _staticInfo.callMethodOnReceiver('get_detail_height_rows', this, []);
  int get detailWidthChars => _staticInfo.callMethodOnReceiver('get_detail_width_chars', this, []);
  CalendarDisplayOptions getDisplayOptions() => _staticInfo.callMethodOnReceiver('get_display_options', this, []);
  void markDay(int day) => _staticInfo.callMethodOnReceiver('mark_day', this, [day]);
  void selectDay(int day) => _staticInfo.callMethodOnReceiver('select_day', this, [day]);
  void selectMonth(int month, int year) => _staticInfo.callMethodOnReceiver('select_month', this, [month, year]);
  void setDetailFunc(CalendarDetailFunc func) => _staticInfo.callMethodOnReceiver('set_detail_func', this, [func]);
  void set detailHeightRows(int rows) => _staticInfo.callMethodOnReceiver('set_detail_height_rows', this, [rows]);
  void set detailWidthChars(int chars) => _staticInfo.callMethodOnReceiver('set_detail_width_chars', this, [chars]);
  void setDisplayOptions(CalendarDisplayOptions flags) => _staticInfo.callMethodOnReceiver('set_display_options', this, [flags]);
  void unmarkDay(int day) => _staticInfo.callMethodOnReceiver('unmark_day', this, [day]);
  int _connectToDaySelected(bool after, void func()) => signalConnect('day-selected', func, after);
  Stream get onDaySelected {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDaySelected(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterDaySelected {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDaySelected(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDaySelectedDoubleClick(bool after, void func()) => signalConnect('day-selected-double-click', func, after);
  Stream get onDaySelectedDoubleClick {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDaySelectedDoubleClick(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterDaySelectedDoubleClick {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDaySelectedDoubleClick(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMonthChanged(bool after, void func()) => signalConnect('month-changed', func, after);
  Stream get onMonthChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToMonthChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterMonthChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToMonthChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToNextMonth(bool after, void func()) => signalConnect('next-month', func, after);
  Stream get onNextMonth {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToNextMonth(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterNextMonth {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToNextMonth(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToNextYear(bool after, void func()) => signalConnect('next-year', func, after);
  Stream get onNextYear {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToNextYear(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterNextYear {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToNextYear(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPrevMonth(bool after, void func()) => signalConnect('prev-month', func, after);
  Stream get onPrevMonth {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPrevMonth(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPrevMonth {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPrevMonth(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPrevYear(bool after, void func()) => signalConnect('prev-year', func, after);
  Stream get onPrevYear {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPrevYear(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPrevYear {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPrevYear(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

typedef String CalendarDetailFunc(Calendar calendar, int year, int month, int day);
class CalendarDisplayOptions extends GEnumBase {
  const CalendarDisplayOptions(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CalendarDisplayOptions');

  static const CalendarDisplayOptions NULL = const CalendarDisplayOptions(0);
  static const CalendarDisplayOptions SHOW_HEADING = const CalendarDisplayOptions(1);
  bool get showHeading => (index & 1) == 1;
  static const CalendarDisplayOptions SHOW_DAY_NAMES = const CalendarDisplayOptions(2);
  bool get showDayNames => (index & 2) == 2;
  static const CalendarDisplayOptions NO_MONTH_CHANGE = const CalendarDisplayOptions(4);
  bool get noMonthChange => (index & 4) == 4;
  static const CalendarDisplayOptions SHOW_WEEK_NUMBERS = const CalendarDisplayOptions(8);
  bool get showWeekNumbers => (index & 8) == 8;
  static const CalendarDisplayOptions SHOW_DETAILS = const CalendarDisplayOptions(32);
  bool get showDetails => (index & 32) == 32;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'CalendarDisplayOptions.SHOW_HEADING';
      case 2: return 'CalendarDisplayOptions.SHOW_DAY_NAMES';
      case 4: return 'CalendarDisplayOptions.NO_MONTH_CHANGE';
      case 8: return 'CalendarDisplayOptions.SHOW_WEEK_NUMBERS';
      case 32: return 'CalendarDisplayOptions.SHOW_DETAILS';
      default: return 'new CalendarDisplayOptions($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'CalendarDisplayOptions.NULL';
    }
    List codes = [];
    for (var i=1; i <= 32; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  CalendarDisplayOptions operator|(CalendarDisplayOptions other) =>
    new CalendarDisplayOptions(index | other.index);
  CalendarDisplayOptions operator&(CalendarDisplayOptions other) =>
    new CalendarDisplayOptions(index & other.index);
}

typedef void Callback(Widget widget);
class CellAccessible extends Accessible with atk.Action, Component {
  CellAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellAccessible');

}

abstract class CellAccessibleParent extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellAccessibleParent');

  void activate(CellAccessible cell) => _staticInfo.callMethodOnReceiver('activate', this, [cell]);
  void edit(CellAccessible cell) => _staticInfo.callMethodOnReceiver('edit', this, [cell]);
  void expandCollapse(CellAccessible cell) => _staticInfo.callMethodOnReceiver('expand_collapse', this, [cell]);
  void getCellArea(CellAccessible cell, RectangleInt cellRect) => _staticInfo.callMethodOnReceiver('get_cell_area', this, [cell, cellRect]);
  void getCellExtents(CellAccessible cell, int x, int y, int width, int height, CoordType coordType) => _staticInfo.callMethodOnReceiver('get_cell_extents', this, [cell, x, y, width, height, coordType]);
  int getChildIndex(CellAccessible cell) => _staticInfo.callMethodOnReceiver('get_child_index', this, [cell]);
  CellRendererState getRendererState(CellAccessible cell) => _staticInfo.callMethodOnReceiver('get_renderer_state', this, [cell]);
  bool cellAccessibleParentGrabFocus(CellAccessible cell) => _staticInfo.callMethodOnReceiver('grab_focus', this, [cell]);
  void updateRelationset(CellAccessible cell, RelationSet relationset) => _staticInfo.callMethodOnReceiver('update_relationset', this, [cell, relationset]);
}

typedef bool CellAllocCallback(CellRenderer renderer, RectangleInt cellArea, RectangleInt cellBackground);
class CellArea extends InitiallyUnowned with Buildable, CellLayout {
  CellArea.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellArea');

  static const String EDIT_WIDGET_PROPERTY = 'edit-widget';
  static const String EDITED_CELL_PROPERTY = 'edited-cell';
  static const String FOCUS_CELL_PROPERTY = 'focus-cell';
  bool activate(CellAreaContext context, Widget widget, RectangleInt cellArea, CellRendererState flags, bool editOnly) => _staticInfo.callMethodOnReceiver('activate', this, [context, widget, cellArea, flags, editOnly]);
  bool activateCell(Widget widget, CellRenderer renderer, Event event, RectangleInt cellArea, CellRendererState flags) => _staticInfo.callMethodOnReceiver('activate_cell', this, [widget, renderer, event, cellArea, flags]);
  void add(CellRenderer renderer) => _staticInfo.callMethodOnReceiver('add', this, [renderer]);
  void addFocusSibling(CellRenderer renderer, CellRenderer sibling) => _staticInfo.callMethodOnReceiver('add_focus_sibling', this, [renderer, sibling]);
  void applyAttributes(TreeModel treeModel, TreeIter iter, bool isExpander, bool isExpanded) => _staticInfo.callMethodOnReceiver('apply_attributes', this, [treeModel, iter, isExpander, isExpanded]);
  void attributeConnect(CellRenderer renderer, String attribute, int column) => _staticInfo.callMethodOnReceiver('attribute_connect', this, [renderer, attribute, column]);
  void attributeDisconnect(CellRenderer renderer, String attribute) => _staticInfo.callMethodOnReceiver('attribute_disconnect', this, [renderer, attribute]);
  int attributeGetColumn(CellRenderer renderer, String attribute) => _staticInfo.callMethodOnReceiver('attribute_get_column', this, [renderer, attribute]);
  void cellGetProperty(CellRenderer renderer, String propertyName, Value value) => _staticInfo.callMethodOnReceiver('cell_get_property', this, [renderer, propertyName, value]);
  void cellSetProperty(CellRenderer renderer, String propertyName, Value value) => _staticInfo.callMethodOnReceiver('cell_set_property', this, [renderer, propertyName, value]);
  CellAreaContext copyContext(CellAreaContext context) => _staticInfo.callMethodOnReceiver('copy_context', this, [context]);
  CellAreaContext createContext() => _staticInfo.callMethodOnReceiver('create_context', this, []);
  int event(CellAreaContext context, Widget widget, Event event, RectangleInt cellArea, CellRendererState flags) => _staticInfo.callMethodOnReceiver('event', this, [context, widget, event, cellArea, flags]);
  bool focus(DirectionType direction) => _staticInfo.callMethodOnReceiver('focus', this, [direction]);
  void foreach(CellCallback callback) => _staticInfo.callMethodOnReceiver('foreach', this, [callback]);
  void foreachAlloc(CellAreaContext context, Widget widget, RectangleInt cellArea, RectangleInt backgroundArea, CellAllocCallback callback) => _staticInfo.callMethodOnReceiver('foreach_alloc', this, [context, widget, cellArea, backgroundArea, callback]);
  void getCellAllocation(CellAreaContext context, Widget widget, CellRenderer renderer, RectangleInt cellArea) => _staticInfo.callMethodOnReceiver('get_cell_allocation', this, [context, widget, renderer, cellArea]);
  CellRenderer getCellAtPosition(CellAreaContext context, Widget widget, RectangleInt cellArea, int x, int y) => _staticInfo.callMethodOnReceiver('get_cell_at_position', this, [context, widget, cellArea, x, y]);
  String getCurrentPathString() => _staticInfo.callMethodOnReceiver('get_current_path_string', this, []);
  CellEditable get editWidget => _staticInfo.callMethodOnReceiver('get_edit_widget', this, []);
  CellRenderer get editedCell => _staticInfo.callMethodOnReceiver('get_edited_cell', this, []);
  CellRenderer get focusCell => _staticInfo.callMethodOnReceiver('get_focus_cell', this, []);
  CellRenderer getFocusFromSibling(CellRenderer renderer) => _staticInfo.callMethodOnReceiver('get_focus_from_sibling', this, [renderer]);
  GLibList /* this will fail */ getFocusSiblings(CellRenderer renderer) => _staticInfo.callMethodOnReceiver('get_focus_siblings', this, [renderer]);
  void getPreferredHeight(CellAreaContext context, Widget widget) => _staticInfo.callMethodOnReceiver('get_preferred_height', this, [context, widget]);
  void getPreferredHeightForWidth(CellAreaContext context, Widget widget, int width) => _staticInfo.callMethodOnReceiver('get_preferred_height_for_width', this, [context, widget, width]);
  void getPreferredWidth(CellAreaContext context, Widget widget) => _staticInfo.callMethodOnReceiver('get_preferred_width', this, [context, widget]);
  void getPreferredWidthForHeight(CellAreaContext context, Widget widget, int height) => _staticInfo.callMethodOnReceiver('get_preferred_width_for_height', this, [context, widget, height]);
  SizeRequestMode getRequestMode() => _staticInfo.callMethodOnReceiver('get_request_mode', this, []);
  bool hasRenderer(CellRenderer renderer) => _staticInfo.callMethodOnReceiver('has_renderer', this, [renderer]);
  void innerCellArea(Widget widget, RectangleInt cellArea) => _staticInfo.callMethodOnReceiver('inner_cell_area', this, [widget, cellArea]);
  bool isActivatable() => _staticInfo.callMethodOnReceiver('is_activatable', this, []);
  bool isFocusSibling(CellRenderer renderer, CellRenderer sibling) => _staticInfo.callMethodOnReceiver('is_focus_sibling', this, [renderer, sibling]);
  void remove(CellRenderer renderer) => _staticInfo.callMethodOnReceiver('remove', this, [renderer]);
  void removeFocusSibling(CellRenderer renderer, CellRenderer sibling) => _staticInfo.callMethodOnReceiver('remove_focus_sibling', this, [renderer, sibling]);
  void render(CellAreaContext context, Widget widget, Context cr, RectangleInt backgroundArea, RectangleInt cellArea, CellRendererState flags, bool paintFocus) => _staticInfo.callMethodOnReceiver('render', this, [context, widget, cr, backgroundArea, cellArea, flags, paintFocus]);
  void requestRenderer(CellRenderer renderer, Orientation orientation, Widget widget, int forSize) => _staticInfo.callMethodOnReceiver('request_renderer', this, [renderer, orientation, widget, forSize]);
  void set focusCell(CellRenderer renderer) => _staticInfo.callMethodOnReceiver('set_focus_cell', this, [renderer]);
  void stopEditing(bool canceled) => _staticInfo.callMethodOnReceiver('stop_editing', this, [canceled]);
  int _connectToAddEditable(bool after, void func(CellRenderer renderer, CellEditable editable, RectangleInt cellArea, String path)) => signalConnect('add-editable', func, after);
  Stream<CellAreaAddEditableEvent> get onAddEditable {
    int signalId;
    StreamController<CellAreaAddEditableEvent> controller;
    controller = new StreamController<CellAreaAddEditableEvent>(
      onListen: () {
          signalId = _connectToAddEditable(false, (CellRenderer renderer, CellEditable editable, RectangleInt cellArea, String path) {
              var result = new CellAreaAddEditableEvent(renderer, editable, cellArea, path);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<CellAreaAddEditableEvent> get afterAddEditable {
    int signalId;
    StreamController<CellAreaAddEditableEvent> controller;
    controller = new StreamController<CellAreaAddEditableEvent>(
      onListen: () {
          signalId = _connectToAddEditable(true, (CellRenderer renderer, CellEditable editable, RectangleInt cellArea, String path) {
              var result = new CellAreaAddEditableEvent(renderer, editable, cellArea, path);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToApplyAttributes(bool after, void func(TreeModel model, TreeIter iter, bool isExpander, bool isExpanded)) => signalConnect('apply-attributes', func, after);
  Stream<CellAreaApplyAttributesEvent> get onApplyAttributes {
    int signalId;
    StreamController<CellAreaApplyAttributesEvent> controller;
    controller = new StreamController<CellAreaApplyAttributesEvent>(
      onListen: () {
          signalId = _connectToApplyAttributes(false, (TreeModel model, TreeIter iter, bool isExpander, bool isExpanded) {
              var result = new CellAreaApplyAttributesEvent(model, iter, isExpander, isExpanded);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<CellAreaApplyAttributesEvent> get afterApplyAttributes {
    int signalId;
    StreamController<CellAreaApplyAttributesEvent> controller;
    controller = new StreamController<CellAreaApplyAttributesEvent>(
      onListen: () {
          signalId = _connectToApplyAttributes(true, (TreeModel model, TreeIter iter, bool isExpander, bool isExpanded) {
              var result = new CellAreaApplyAttributesEvent(model, iter, isExpander, isExpanded);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToFocusChanged(bool after, void func(CellRenderer renderer, String path)) => signalConnect('focus-changed', func, after);
  Stream<CellAreaFocusChangedEvent> get onFocusChanged {
    int signalId;
    StreamController<CellAreaFocusChangedEvent> controller;
    controller = new StreamController<CellAreaFocusChangedEvent>(
      onListen: () {
          signalId = _connectToFocusChanged(false, (CellRenderer renderer, String path) {
              var result = new CellAreaFocusChangedEvent(renderer, path);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<CellAreaFocusChangedEvent> get afterFocusChanged {
    int signalId;
    StreamController<CellAreaFocusChangedEvent> controller;
    controller = new StreamController<CellAreaFocusChangedEvent>(
      onListen: () {
          signalId = _connectToFocusChanged(true, (CellRenderer renderer, String path) {
              var result = new CellAreaFocusChangedEvent(renderer, path);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRemoveEditable(bool after, void func(CellRenderer renderer, CellEditable editable)) => signalConnect('remove-editable', func, after);
  Stream<CellAreaRemoveEditableEvent> get onRemoveEditable {
    int signalId;
    StreamController<CellAreaRemoveEditableEvent> controller;
    controller = new StreamController<CellAreaRemoveEditableEvent>(
      onListen: () {
          signalId = _connectToRemoveEditable(false, (CellRenderer renderer, CellEditable editable) {
              var result = new CellAreaRemoveEditableEvent(renderer, editable);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<CellAreaRemoveEditableEvent> get afterRemoveEditable {
    int signalId;
    StreamController<CellAreaRemoveEditableEvent> controller;
    controller = new StreamController<CellAreaRemoveEditableEvent>(
      onListen: () {
          signalId = _connectToRemoveEditable(true, (CellRenderer renderer, CellEditable editable) {
              var result = new CellAreaRemoveEditableEvent(renderer, editable);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class CellAreaAddEditableEvent {
  final CellRenderer renderer;
  final CellEditable editable;
  final RectangleInt cellArea;
  final String path;

  CellAreaAddEditableEvent(this.renderer, this.editable, this.cellArea, this.path);
}

class CellAreaApplyAttributesEvent {
  final TreeModel model;
  final TreeIter iter;
  final bool isExpander;
  final bool isExpanded;

  CellAreaApplyAttributesEvent(this.model, this.iter, this.isExpander, this.isExpanded);
}

class CellAreaFocusChangedEvent {
  final CellRenderer renderer;
  final String path;

  CellAreaFocusChangedEvent(this.renderer, this.path);
}

class CellAreaRemoveEditableEvent {
  final CellRenderer renderer;
  final CellEditable editable;

  CellAreaRemoveEditableEvent(this.renderer, this.editable);
}

class CellAreaBox extends CellArea with Buildable, CellLayout, Orientable {
  CellAreaBox.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellAreaBox');

  static const String SPACING_PROPERTY = 'spacing';
  factory CellAreaBox() => _staticInfo.callStatic('new', []);
  int get spacing => _staticInfo.callMethodOnReceiver('get_spacing', this, []);
  void cellAreaBoxPackEnd(CellRenderer renderer, bool expand, bool align, bool fixed) => _staticInfo.callMethodOnReceiver('pack_end', this, [renderer, expand, align, fixed]);
  void cellAreaBoxPackStart(CellRenderer renderer, bool expand, bool align, bool fixed) => _staticInfo.callMethodOnReceiver('pack_start', this, [renderer, expand, align, fixed]);
  void set spacing(int spacing) => _staticInfo.callMethodOnReceiver('set_spacing', this, [spacing]);
}

class CellAreaContext extends GObjectObject {
  CellAreaContext.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellAreaContext');

  void set area(CellArea value) => _staticInfo.setGPropertyOnReceiver('area', this, value);
  static const String AREA_PROPERTY = 'area';
  int get minimumHeight => _staticInfo.getGPropertyOnReceiver('minimum-height', this);
  static const String MINIMUM_HEIGHT_PROPERTY = 'minimum-height';
  int get minimumWidth => _staticInfo.getGPropertyOnReceiver('minimum-width', this);
  static const String MINIMUM_WIDTH_PROPERTY = 'minimum-width';
  int get naturalHeight => _staticInfo.getGPropertyOnReceiver('natural-height', this);
  static const String NATURAL_HEIGHT_PROPERTY = 'natural-height';
  int get naturalWidth => _staticInfo.getGPropertyOnReceiver('natural-width', this);
  static const String NATURAL_WIDTH_PROPERTY = 'natural-width';
  void allocate(int width, int height) => _staticInfo.callMethodOnReceiver('allocate', this, [width, height]);
  void getAllocation() => _staticInfo.callMethodOnReceiver('get_allocation', this, []);
  CellArea get area_ => _staticInfo.callMethodOnReceiver('get_area', this, []);
  void getPreferredHeight() => _staticInfo.callMethodOnReceiver('get_preferred_height', this, []);
  void getPreferredHeightForWidth(int width) => _staticInfo.callMethodOnReceiver('get_preferred_height_for_width', this, [width]);
  void getPreferredWidth() => _staticInfo.callMethodOnReceiver('get_preferred_width', this, []);
  void getPreferredWidthForHeight(int height) => _staticInfo.callMethodOnReceiver('get_preferred_width_for_height', this, [height]);
  void pushPreferredHeight(int minimumHeight, int naturalHeight) => _staticInfo.callMethodOnReceiver('push_preferred_height', this, [minimumHeight, naturalHeight]);
  void pushPreferredWidth(int minimumWidth, int naturalWidth) => _staticInfo.callMethodOnReceiver('push_preferred_width', this, [minimumWidth, naturalWidth]);
  void reset() => _staticInfo.callMethodOnReceiver('reset', this, []);
}

typedef bool CellCallback(CellRenderer renderer);
abstract class CellEditable extends GObjectBase implements Widget {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellEditable');



  bool get editingCanceled => _staticInfo.getGPropertyOnReceiver('editing-canceled', this);
  void set editingCanceled(bool value) => _staticInfo.setGPropertyOnReceiver('editing-canceled', this, value);
  static const String EDITING_CANCELED_PROPERTY = 'editing-canceled';
  void editingDone() => _staticInfo.callMethodOnReceiver('editing_done', this, []);
  void removeWidget() => _staticInfo.callMethodOnReceiver('remove_widget', this, []);
  void startEditing(Event event) => _staticInfo.callMethodOnReceiver('start_editing', this, [event]);
  int _connectToEditingDone(bool after, void func()) => signalConnect('editing-done', func, after);
  Stream get onEditingDone {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToEditingDone(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterEditingDone {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToEditingDone(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRemoveWidget(bool after, void func()) => signalConnect('remove-widget', func, after);
  Stream get onRemoveWidget {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToRemoveWidget(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterRemoveWidget {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToRemoveWidget(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

abstract class CellLayout extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellLayout');



  void addAttribute(CellRenderer cell, String attribute, int column) => _staticInfo.callMethodOnReceiver('add_attribute', this, [cell, attribute, column]);
  void clear() => _staticInfo.callMethodOnReceiver('clear', this, []);
  void clearAttributes(CellRenderer cell) => _staticInfo.callMethodOnReceiver('clear_attributes', this, [cell]);
  CellArea getArea() => _staticInfo.callMethodOnReceiver('get_area', this, []);
  GLibList /* this will fail */ getCells() => _staticInfo.callMethodOnReceiver('get_cells', this, []);
  void packEnd(CellRenderer cell, bool expand) => _staticInfo.callMethodOnReceiver('pack_end', this, [cell, expand]);
  void packStart(CellRenderer cell, bool expand) => _staticInfo.callMethodOnReceiver('pack_start', this, [cell, expand]);
  void reorder(CellRenderer cell, int position) => _staticInfo.callMethodOnReceiver('reorder', this, [cell, position]);
  void setCellDataFunc(CellRenderer cell, CellLayoutDataFunc func) => _staticInfo.callMethodOnReceiver('set_cell_data_func', this, [cell, func]);
}

typedef void CellLayoutDataFunc(CellLayout cellLayout, CellRenderer cell, TreeModel treeModel, TreeIter iter);
class CellRenderer extends InitiallyUnowned {
  CellRenderer.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellRenderer');

  void set cellBackground(String value) => _staticInfo.setGPropertyOnReceiver('cell-background', this, value);
  static const String CELL_BACKGROUND_PROPERTY = 'cell-background';
  Color get cellBackgroundGdk => _staticInfo.getGPropertyOnReceiver('cell-background-gdk', this);
  void set cellBackgroundGdk(Color value) => _staticInfo.setGPropertyOnReceiver('cell-background-gdk', this, value);
  static const String CELL_BACKGROUND_GDK_PROPERTY = 'cell-background-gdk';
  RGBA get cellBackgroundRgba => _staticInfo.getGPropertyOnReceiver('cell-background-rgba', this);
  void set cellBackgroundRgba(RGBA value) => _staticInfo.setGPropertyOnReceiver('cell-background-rgba', this, value);
  static const String CELL_BACKGROUND_RGBA_PROPERTY = 'cell-background-rgba';
  bool get cellBackgroundSet => _staticInfo.getGPropertyOnReceiver('cell-background-set', this);
  void set cellBackgroundSet(bool value) => _staticInfo.setGPropertyOnReceiver('cell-background-set', this, value);
  static const String CELL_BACKGROUND_SET_PROPERTY = 'cell-background-set';
  bool get editing => _staticInfo.getGPropertyOnReceiver('editing', this);
  static const String EDITING_PROPERTY = 'editing';
  int get height => _staticInfo.getGPropertyOnReceiver('height', this);
  void set height(int value) => _staticInfo.setGPropertyOnReceiver('height', this, value);
  static const String HEIGHT_PROPERTY = 'height';
  bool get isExpanded => _staticInfo.getGPropertyOnReceiver('is-expanded', this);
  void set isExpanded(bool value) => _staticInfo.setGPropertyOnReceiver('is-expanded', this, value);
  static const String IS_EXPANDED_PROPERTY = 'is-expanded';
  bool get isExpander => _staticInfo.getGPropertyOnReceiver('is-expander', this);
  void set isExpander(bool value) => _staticInfo.setGPropertyOnReceiver('is-expander', this, value);
  static const String IS_EXPANDER_PROPERTY = 'is-expander';
  CellRendererMode get mode => _staticInfo.getGPropertyOnReceiver('mode', this);
  void set mode(CellRendererMode value) => _staticInfo.setGPropertyOnReceiver('mode', this, value);
  static const String MODE_PROPERTY = 'mode';
  static const String SENSITIVE_PROPERTY = 'sensitive';
  static const String VISIBLE_PROPERTY = 'visible';
  int get width => _staticInfo.getGPropertyOnReceiver('width', this);
  void set width(int value) => _staticInfo.setGPropertyOnReceiver('width', this, value);
  static const String WIDTH_PROPERTY = 'width';
  num get xalign => _staticInfo.getGPropertyOnReceiver('xalign', this);
  void set xalign(num value) => _staticInfo.setGPropertyOnReceiver('xalign', this, value);
  static const String XALIGN_PROPERTY = 'xalign';
  int get xpad => _staticInfo.getGPropertyOnReceiver('xpad', this);
  void set xpad(int value) => _staticInfo.setGPropertyOnReceiver('xpad', this, value);
  static const String XPAD_PROPERTY = 'xpad';
  num get yalign => _staticInfo.getGPropertyOnReceiver('yalign', this);
  void set yalign(num value) => _staticInfo.setGPropertyOnReceiver('yalign', this, value);
  static const String YALIGN_PROPERTY = 'yalign';
  int get ypad => _staticInfo.getGPropertyOnReceiver('ypad', this);
  void set ypad(int value) => _staticInfo.setGPropertyOnReceiver('ypad', this, value);
  static const String YPAD_PROPERTY = 'ypad';
  bool activate(Event event, Widget widget, String path, RectangleInt backgroundArea, RectangleInt cellArea, CellRendererState flags) => _staticInfo.callMethodOnReceiver('activate', this, [event, widget, path, backgroundArea, cellArea, flags]);
  void getAlignedArea(Widget widget, CellRendererState flags, RectangleInt cellArea) => _staticInfo.callMethodOnReceiver('get_aligned_area', this, [widget, flags, cellArea]);
  void getAlignment() => _staticInfo.callMethodOnReceiver('get_alignment', this, []);
  void getFixedSize() => _staticInfo.callMethodOnReceiver('get_fixed_size', this, []);
  void getPadding() => _staticInfo.callMethodOnReceiver('get_padding', this, []);
  void getPreferredHeight(Widget widget) => _staticInfo.callMethodOnReceiver('get_preferred_height', this, [widget]);
  void getPreferredHeightForWidth(Widget widget, int width) => _staticInfo.callMethodOnReceiver('get_preferred_height_for_width', this, [widget, width]);
  void getPreferredSize(Widget widget) => _staticInfo.callMethodOnReceiver('get_preferred_size', this, [widget]);
  void getPreferredWidth(Widget widget) => _staticInfo.callMethodOnReceiver('get_preferred_width', this, [widget]);
  void getPreferredWidthForHeight(Widget widget, int height) => _staticInfo.callMethodOnReceiver('get_preferred_width_for_height', this, [widget, height]);
  SizeRequestMode getRequestMode() => _staticInfo.callMethodOnReceiver('get_request_mode', this, []);
  bool get sensitive => _staticInfo.callMethodOnReceiver('get_sensitive', this, []);
  void getSize(Widget widget, RectangleInt cellArea) => _staticInfo.callMethodOnReceiver('get_size', this, [widget, cellArea]);
  StateFlags getState(Widget widget, CellRendererState cellState) => _staticInfo.callMethodOnReceiver('get_state', this, [widget, cellState]);
  bool get visible => _staticInfo.callMethodOnReceiver('get_visible', this, []);
  bool isActivatable() => _staticInfo.callMethodOnReceiver('is_activatable', this, []);
  void render(Context cr, Widget widget, RectangleInt backgroundArea, RectangleInt cellArea, CellRendererState flags) => _staticInfo.callMethodOnReceiver('render', this, [cr, widget, backgroundArea, cellArea, flags]);
  void setAlignment(num xalign, num yalign) => _staticInfo.callMethodOnReceiver('set_alignment', this, [xalign, yalign]);
  void setFixedSize(int width, int height) => _staticInfo.callMethodOnReceiver('set_fixed_size', this, [width, height]);
  void setPadding(int xpad, int ypad) => _staticInfo.callMethodOnReceiver('set_padding', this, [xpad, ypad]);
  void set sensitive(bool sensitive) => _staticInfo.callMethodOnReceiver('set_sensitive', this, [sensitive]);
  void set visible(bool visible) => _staticInfo.callMethodOnReceiver('set_visible', this, [visible]);
  CellEditable startEditing(Event event, Widget widget, String path, RectangleInt backgroundArea, RectangleInt cellArea, CellRendererState flags) => _staticInfo.callMethodOnReceiver('start_editing', this, [event, widget, path, backgroundArea, cellArea, flags]);
  void stopEditing(bool canceled) => _staticInfo.callMethodOnReceiver('stop_editing', this, [canceled]);
  int _connectToEditingCanceled(bool after, void func()) => signalConnect('editing-canceled', func, after);
  Stream get onEditingCanceled {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToEditingCanceled(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterEditingCanceled {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToEditingCanceled(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToEditingStarted(bool after, void func(CellEditable editable, String path)) => signalConnect('editing-started', func, after);
  Stream<CellRendererEditingStartedEvent> get onEditingStarted {
    int signalId;
    StreamController<CellRendererEditingStartedEvent> controller;
    controller = new StreamController<CellRendererEditingStartedEvent>(
      onListen: () {
          signalId = _connectToEditingStarted(false, (CellEditable editable, String path) {
              var result = new CellRendererEditingStartedEvent(editable, path);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<CellRendererEditingStartedEvent> get afterEditingStarted {
    int signalId;
    StreamController<CellRendererEditingStartedEvent> controller;
    controller = new StreamController<CellRendererEditingStartedEvent>(
      onListen: () {
          signalId = _connectToEditingStarted(true, (CellEditable editable, String path) {
              var result = new CellRendererEditingStartedEvent(editable, path);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class CellRendererEditingStartedEvent {
  final CellEditable editable;
  final String path;

  CellRendererEditingStartedEvent(this.editable, this.path);
}

class CellRendererAccel extends CellRendererText {
  CellRendererAccel.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellRendererAccel');

  int get accelKey => _staticInfo.getGPropertyOnReceiver('accel-key', this);
  void set accelKey(int value) => _staticInfo.setGPropertyOnReceiver('accel-key', this, value);
  static const String ACCEL_KEY_PROPERTY = 'accel-key';
  CellRendererAccelMode get accelMode => _staticInfo.getGPropertyOnReceiver('accel-mode', this);
  void set accelMode(CellRendererAccelMode value) => _staticInfo.setGPropertyOnReceiver('accel-mode', this, value);
  static const String ACCEL_MODE_PROPERTY = 'accel-mode';
  ModifierType get accelMods => _staticInfo.getGPropertyOnReceiver('accel-mods', this);
  void set accelMods(ModifierType value) => _staticInfo.setGPropertyOnReceiver('accel-mods', this, value);
  static const String ACCEL_MODS_PROPERTY = 'accel-mods';
  int get keycode => _staticInfo.getGPropertyOnReceiver('keycode', this);
  void set keycode(int value) => _staticInfo.setGPropertyOnReceiver('keycode', this, value);
  static const String KEYCODE_PROPERTY = 'keycode';
  factory CellRendererAccel() => _staticInfo.callStatic('new', []);
  int _connectToAccelCleared(bool after, void func(String pathString)) => signalConnect('accel-cleared', func, after);
  Stream<String> get onAccelCleared {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToAccelCleared(false, (String pathString) {
              controller.add(pathString);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<String> get afterAccelCleared {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToAccelCleared(true, (String pathString) {
              controller.add(pathString);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToAccelEdited(bool after, void func(String pathString, int accelKey, ModifierType accelMods, int hardwareKeycode)) => signalConnect('accel-edited', func, after);
  Stream<CellRendererAccelAccelEditedEvent> get onAccelEdited {
    int signalId;
    StreamController<CellRendererAccelAccelEditedEvent> controller;
    controller = new StreamController<CellRendererAccelAccelEditedEvent>(
      onListen: () {
          signalId = _connectToAccelEdited(false, (String pathString, int accelKey, ModifierType accelMods, int hardwareKeycode) {
              var result = new CellRendererAccelAccelEditedEvent(pathString, accelKey, accelMods, hardwareKeycode);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<CellRendererAccelAccelEditedEvent> get afterAccelEdited {
    int signalId;
    StreamController<CellRendererAccelAccelEditedEvent> controller;
    controller = new StreamController<CellRendererAccelAccelEditedEvent>(
      onListen: () {
          signalId = _connectToAccelEdited(true, (String pathString, int accelKey, ModifierType accelMods, int hardwareKeycode) {
              var result = new CellRendererAccelAccelEditedEvent(pathString, accelKey, accelMods, hardwareKeycode);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class CellRendererAccelAccelEditedEvent {
  final String pathString;
  final int accelKey;
  final ModifierType accelMods;
  final int hardwareKeycode;

  CellRendererAccelAccelEditedEvent(this.pathString, this.accelKey, this.accelMods, this.hardwareKeycode);
}

class CellRendererAccelMode extends GEnumBase {
  const CellRendererAccelMode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellRendererAccelMode');

  static const CellRendererAccelMode GTK = const CellRendererAccelMode(0);
  static const CellRendererAccelMode OTHER = const CellRendererAccelMode(1);
  String toString() {
    switch(index) {
      case 0: return 'CellRendererAccelMode.GTK';
      case 1: return 'CellRendererAccelMode.OTHER';
      default: return 'new CellRendererAccelMode($index)';
    }
  }
}

class CellRendererClassPrivate extends GObjectBase {
  CellRendererClassPrivate.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellRendererClassPrivate');

}

class CellRendererCombo extends CellRendererText {
  CellRendererCombo.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellRendererCombo');

  bool get hasEntry => _staticInfo.getGPropertyOnReceiver('has-entry', this);
  void set hasEntry(bool value) => _staticInfo.setGPropertyOnReceiver('has-entry', this, value);
  static const String HAS_ENTRY_PROPERTY = 'has-entry';
  TreeModel get model => _staticInfo.getGPropertyOnReceiver('model', this);
  void set model(TreeModel value) => _staticInfo.setGPropertyOnReceiver('model', this, value);
  static const String MODEL_PROPERTY = 'model';
  int get textColumn => _staticInfo.getGPropertyOnReceiver('text-column', this);
  void set textColumn(int value) => _staticInfo.setGPropertyOnReceiver('text-column', this, value);
  static const String TEXT_COLUMN_PROPERTY = 'text-column';
  factory CellRendererCombo() => _staticInfo.callStatic('new', []);
  int _connectToChanged(bool after, void func(String pathString, TreeIter newIter)) => signalConnect('changed', func, after);
  Stream<CellRendererComboChangedEvent> get onChanged {
    int signalId;
    StreamController<CellRendererComboChangedEvent> controller;
    controller = new StreamController<CellRendererComboChangedEvent>(
      onListen: () {
          signalId = _connectToChanged(false, (String pathString, TreeIter newIter) {
              var result = new CellRendererComboChangedEvent(pathString, newIter);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<CellRendererComboChangedEvent> get afterChanged {
    int signalId;
    StreamController<CellRendererComboChangedEvent> controller;
    controller = new StreamController<CellRendererComboChangedEvent>(
      onListen: () {
          signalId = _connectToChanged(true, (String pathString, TreeIter newIter) {
              var result = new CellRendererComboChangedEvent(pathString, newIter);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class CellRendererComboChangedEvent {
  final String pathString;
  final TreeIter newIter;

  CellRendererComboChangedEvent(this.pathString, this.newIter);
}

class CellRendererMode extends GEnumBase {
  const CellRendererMode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellRendererMode');

  static const CellRendererMode INERT = const CellRendererMode(0);
  static const CellRendererMode ACTIVATABLE = const CellRendererMode(1);
  static const CellRendererMode EDITABLE = const CellRendererMode(2);
  String toString() {
    switch(index) {
      case 0: return 'CellRendererMode.INERT';
      case 1: return 'CellRendererMode.ACTIVATABLE';
      case 2: return 'CellRendererMode.EDITABLE';
      default: return 'new CellRendererMode($index)';
    }
  }
}

class CellRendererPixbuf extends CellRenderer {
  CellRendererPixbuf.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellRendererPixbuf');

  bool get followState => _staticInfo.getGPropertyOnReceiver('follow-state', this);
  void set followState(bool value) => _staticInfo.setGPropertyOnReceiver('follow-state', this, value);
  static const String FOLLOW_STATE_PROPERTY = 'follow-state';
  Icon get gicon => _staticInfo.getGPropertyOnReceiver('gicon', this);
  void set gicon(Icon value) => _staticInfo.setGPropertyOnReceiver('gicon', this, value);
  static const String GICON_PROPERTY = 'gicon';
  String get iconName => _staticInfo.getGPropertyOnReceiver('icon-name', this);
  void set iconName(String value) => _staticInfo.setGPropertyOnReceiver('icon-name', this, value);
  static const String ICON_NAME_PROPERTY = 'icon-name';
  Pixbuf get pixbuf => _staticInfo.getGPropertyOnReceiver('pixbuf', this);
  void set pixbuf(Pixbuf value) => _staticInfo.setGPropertyOnReceiver('pixbuf', this, value);
  static const String PIXBUF_PROPERTY = 'pixbuf';
  Pixbuf get pixbufExpanderClosed => _staticInfo.getGPropertyOnReceiver('pixbuf-expander-closed', this);
  void set pixbufExpanderClosed(Pixbuf value) => _staticInfo.setGPropertyOnReceiver('pixbuf-expander-closed', this, value);
  static const String PIXBUF_EXPANDER_CLOSED_PROPERTY = 'pixbuf-expander-closed';
  Pixbuf get pixbufExpanderOpen => _staticInfo.getGPropertyOnReceiver('pixbuf-expander-open', this);
  void set pixbufExpanderOpen(Pixbuf value) => _staticInfo.setGPropertyOnReceiver('pixbuf-expander-open', this, value);
  static const String PIXBUF_EXPANDER_OPEN_PROPERTY = 'pixbuf-expander-open';
  String get stockDetail => _staticInfo.getGPropertyOnReceiver('stock-detail', this);
  void set stockDetail(String value) => _staticInfo.setGPropertyOnReceiver('stock-detail', this, value);
  static const String STOCK_DETAIL_PROPERTY = 'stock-detail';
  String get stockId => _staticInfo.getGPropertyOnReceiver('stock-id', this);
  void set stockId(String value) => _staticInfo.setGPropertyOnReceiver('stock-id', this, value);
  static const String STOCK_ID_PROPERTY = 'stock-id';
  int get stockSize => _staticInfo.getGPropertyOnReceiver('stock-size', this);
  void set stockSize(int value) => _staticInfo.setGPropertyOnReceiver('stock-size', this, value);
  static const String STOCK_SIZE_PROPERTY = 'stock-size';
  Surface get surface => _staticInfo.getGPropertyOnReceiver('surface', this);
  void set surface(Surface value) => _staticInfo.setGPropertyOnReceiver('surface', this, value);
  static const String SURFACE_PROPERTY = 'surface';
  factory CellRendererPixbuf() => _staticInfo.callStatic('new', []);
}

class CellRendererProgress extends CellRenderer with Orientable {
  CellRendererProgress.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellRendererProgress');

  bool get inverted => _staticInfo.getGPropertyOnReceiver('inverted', this);
  void set inverted(bool value) => _staticInfo.setGPropertyOnReceiver('inverted', this, value);
  static const String INVERTED_PROPERTY = 'inverted';
  int get pulse => _staticInfo.getGPropertyOnReceiver('pulse', this);
  void set pulse(int value) => _staticInfo.setGPropertyOnReceiver('pulse', this, value);
  static const String PULSE_PROPERTY = 'pulse';
  String get text => _staticInfo.getGPropertyOnReceiver('text', this);
  void set text(String value) => _staticInfo.setGPropertyOnReceiver('text', this, value);
  static const String TEXT_PROPERTY = 'text';
  num get textXalign => _staticInfo.getGPropertyOnReceiver('text-xalign', this);
  void set textXalign(num value) => _staticInfo.setGPropertyOnReceiver('text-xalign', this, value);
  static const String TEXT_XALIGN_PROPERTY = 'text-xalign';
  num get textYalign => _staticInfo.getGPropertyOnReceiver('text-yalign', this);
  void set textYalign(num value) => _staticInfo.setGPropertyOnReceiver('text-yalign', this, value);
  static const String TEXT_YALIGN_PROPERTY = 'text-yalign';
  int get value => _staticInfo.getGPropertyOnReceiver('value', this);
  void set value(int value) => _staticInfo.setGPropertyOnReceiver('value', this, value);
  static const String VALUE_PROPERTY = 'value';
  factory CellRendererProgress() => _staticInfo.callStatic('new', []);
}

class CellRendererSpin extends CellRendererText {
  CellRendererSpin.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellRendererSpin');

  Adjustment get adjustment => _staticInfo.getGPropertyOnReceiver('adjustment', this);
  void set adjustment(Adjustment value) => _staticInfo.setGPropertyOnReceiver('adjustment', this, value);
  static const String ADJUSTMENT_PROPERTY = 'adjustment';
  num get climbRate => _staticInfo.getGPropertyOnReceiver('climb-rate', this);
  void set climbRate(num value) => _staticInfo.setGPropertyOnReceiver('climb-rate', this, value);
  static const String CLIMB_RATE_PROPERTY = 'climb-rate';
  int get digits => _staticInfo.getGPropertyOnReceiver('digits', this);
  void set digits(int value) => _staticInfo.setGPropertyOnReceiver('digits', this, value);
  static const String DIGITS_PROPERTY = 'digits';
  factory CellRendererSpin() => _staticInfo.callStatic('new', []);
}

class CellRendererSpinner extends CellRenderer {
  CellRendererSpinner.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellRendererSpinner');

  bool get active => _staticInfo.getGPropertyOnReceiver('active', this);
  void set active(bool value) => _staticInfo.setGPropertyOnReceiver('active', this, value);
  static const String ACTIVE_PROPERTY = 'active';
  int get pulse => _staticInfo.getGPropertyOnReceiver('pulse', this);
  void set pulse(int value) => _staticInfo.setGPropertyOnReceiver('pulse', this, value);
  static const String PULSE_PROPERTY = 'pulse';
  IconSize get size => _staticInfo.getGPropertyOnReceiver('size', this);
  void set size(IconSize value) => _staticInfo.setGPropertyOnReceiver('size', this, value);
  static const String SIZE_PROPERTY = 'size';
  factory CellRendererSpinner() => _staticInfo.callStatic('new', []);
}

class CellRendererState extends GEnumBase {
  const CellRendererState(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellRendererState');

  static const CellRendererState NULL = const CellRendererState(0);
  static const CellRendererState SELECTED = const CellRendererState(1);
  bool get selected => (index & 1) == 1;
  static const CellRendererState PRELIT = const CellRendererState(2);
  bool get prelit => (index & 2) == 2;
  static const CellRendererState INSENSITIVE = const CellRendererState(4);
  bool get insensitive => (index & 4) == 4;
  static const CellRendererState SORTED = const CellRendererState(8);
  bool get sorted => (index & 8) == 8;
  static const CellRendererState FOCUSED = const CellRendererState(16);
  bool get focused => (index & 16) == 16;
  static const CellRendererState EXPANDABLE = const CellRendererState(32);
  bool get expandable => (index & 32) == 32;
  static const CellRendererState EXPANDED = const CellRendererState(64);
  bool get expanded => (index & 64) == 64;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'CellRendererState.SELECTED';
      case 2: return 'CellRendererState.PRELIT';
      case 4: return 'CellRendererState.INSENSITIVE';
      case 8: return 'CellRendererState.SORTED';
      case 16: return 'CellRendererState.FOCUSED';
      case 32: return 'CellRendererState.EXPANDABLE';
      case 64: return 'CellRendererState.EXPANDED';
      default: return 'new CellRendererState($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'CellRendererState.NULL';
    }
    List codes = [];
    for (var i=1; i <= 64; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  CellRendererState operator|(CellRendererState other) =>
    new CellRendererState(index | other.index);
  CellRendererState operator&(CellRendererState other) =>
    new CellRendererState(index & other.index);
}

class CellRendererText extends CellRenderer {
  CellRendererText.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellRendererText');

  bool get alignSet => _staticInfo.getGPropertyOnReceiver('align-set', this);
  void set alignSet(bool value) => _staticInfo.setGPropertyOnReceiver('align-set', this, value);
  static const String ALIGN_SET_PROPERTY = 'align-set';
  pango.Alignment get alignment => _staticInfo.getGPropertyOnReceiver('alignment', this);
  void set alignment(pango.Alignment value) => _staticInfo.setGPropertyOnReceiver('alignment', this, value);
  static const String ALIGNMENT_PROPERTY = 'alignment';
  AttrList get attributes => _staticInfo.getGPropertyOnReceiver('attributes', this);
  void set attributes(AttrList value) => _staticInfo.setGPropertyOnReceiver('attributes', this, value);
  static const String ATTRIBUTES_PROPERTY = 'attributes';
  void set background(String value) => _staticInfo.setGPropertyOnReceiver('background', this, value);
  static const String BACKGROUND_PROPERTY = 'background';
  Color get backgroundGdk => _staticInfo.getGPropertyOnReceiver('background-gdk', this);
  void set backgroundGdk(Color value) => _staticInfo.setGPropertyOnReceiver('background-gdk', this, value);
  static const String BACKGROUND_GDK_PROPERTY = 'background-gdk';
  RGBA get backgroundRgba => _staticInfo.getGPropertyOnReceiver('background-rgba', this);
  void set backgroundRgba(RGBA value) => _staticInfo.setGPropertyOnReceiver('background-rgba', this, value);
  static const String BACKGROUND_RGBA_PROPERTY = 'background-rgba';
  bool get backgroundSet => _staticInfo.getGPropertyOnReceiver('background-set', this);
  void set backgroundSet(bool value) => _staticInfo.setGPropertyOnReceiver('background-set', this, value);
  static const String BACKGROUND_SET_PROPERTY = 'background-set';
  bool get editable => _staticInfo.getGPropertyOnReceiver('editable', this);
  void set editable(bool value) => _staticInfo.setGPropertyOnReceiver('editable', this, value);
  static const String EDITABLE_PROPERTY = 'editable';
  bool get editableSet => _staticInfo.getGPropertyOnReceiver('editable-set', this);
  void set editableSet(bool value) => _staticInfo.setGPropertyOnReceiver('editable-set', this, value);
  static const String EDITABLE_SET_PROPERTY = 'editable-set';
  EllipsizeMode get ellipsize => _staticInfo.getGPropertyOnReceiver('ellipsize', this);
  void set ellipsize(EllipsizeMode value) => _staticInfo.setGPropertyOnReceiver('ellipsize', this, value);
  static const String ELLIPSIZE_PROPERTY = 'ellipsize';
  bool get ellipsizeSet => _staticInfo.getGPropertyOnReceiver('ellipsize-set', this);
  void set ellipsizeSet(bool value) => _staticInfo.setGPropertyOnReceiver('ellipsize-set', this, value);
  static const String ELLIPSIZE_SET_PROPERTY = 'ellipsize-set';
  String get family => _staticInfo.getGPropertyOnReceiver('family', this);
  void set family(String value) => _staticInfo.setGPropertyOnReceiver('family', this, value);
  static const String FAMILY_PROPERTY = 'family';
  bool get familySet => _staticInfo.getGPropertyOnReceiver('family-set', this);
  void set familySet(bool value) => _staticInfo.setGPropertyOnReceiver('family-set', this, value);
  static const String FAMILY_SET_PROPERTY = 'family-set';
  String get font => _staticInfo.getGPropertyOnReceiver('font', this);
  void set font(String value) => _staticInfo.setGPropertyOnReceiver('font', this, value);
  static const String FONT_PROPERTY = 'font';
  FontDescription get fontDesc => _staticInfo.getGPropertyOnReceiver('font-desc', this);
  void set fontDesc(FontDescription value) => _staticInfo.setGPropertyOnReceiver('font-desc', this, value);
  static const String FONT_DESC_PROPERTY = 'font-desc';
  void set foreground(String value) => _staticInfo.setGPropertyOnReceiver('foreground', this, value);
  static const String FOREGROUND_PROPERTY = 'foreground';
  Color get foregroundGdk => _staticInfo.getGPropertyOnReceiver('foreground-gdk', this);
  void set foregroundGdk(Color value) => _staticInfo.setGPropertyOnReceiver('foreground-gdk', this, value);
  static const String FOREGROUND_GDK_PROPERTY = 'foreground-gdk';
  RGBA get foregroundRgba => _staticInfo.getGPropertyOnReceiver('foreground-rgba', this);
  void set foregroundRgba(RGBA value) => _staticInfo.setGPropertyOnReceiver('foreground-rgba', this, value);
  static const String FOREGROUND_RGBA_PROPERTY = 'foreground-rgba';
  bool get foregroundSet => _staticInfo.getGPropertyOnReceiver('foreground-set', this);
  void set foregroundSet(bool value) => _staticInfo.setGPropertyOnReceiver('foreground-set', this, value);
  static const String FOREGROUND_SET_PROPERTY = 'foreground-set';
  String get language => _staticInfo.getGPropertyOnReceiver('language', this);
  void set language(String value) => _staticInfo.setGPropertyOnReceiver('language', this, value);
  static const String LANGUAGE_PROPERTY = 'language';
  bool get languageSet => _staticInfo.getGPropertyOnReceiver('language-set', this);
  void set languageSet(bool value) => _staticInfo.setGPropertyOnReceiver('language-set', this, value);
  static const String LANGUAGE_SET_PROPERTY = 'language-set';
  void set markup(String value) => _staticInfo.setGPropertyOnReceiver('markup', this, value);
  static const String MARKUP_PROPERTY = 'markup';
  int get maxWidthChars => _staticInfo.getGPropertyOnReceiver('max-width-chars', this);
  void set maxWidthChars(int value) => _staticInfo.setGPropertyOnReceiver('max-width-chars', this, value);
  static const String MAX_WIDTH_CHARS_PROPERTY = 'max-width-chars';
  String get placeholderText => _staticInfo.getGPropertyOnReceiver('placeholder-text', this);
  void set placeholderText(String value) => _staticInfo.setGPropertyOnReceiver('placeholder-text', this, value);
  static const String PLACEHOLDER_TEXT_PROPERTY = 'placeholder-text';
  int get rise => _staticInfo.getGPropertyOnReceiver('rise', this);
  void set rise(int value) => _staticInfo.setGPropertyOnReceiver('rise', this, value);
  static const String RISE_PROPERTY = 'rise';
  bool get riseSet => _staticInfo.getGPropertyOnReceiver('rise-set', this);
  void set riseSet(bool value) => _staticInfo.setGPropertyOnReceiver('rise-set', this, value);
  static const String RISE_SET_PROPERTY = 'rise-set';
  num get scale => _staticInfo.getGPropertyOnReceiver('scale', this);
  void set scale(num value) => _staticInfo.setGPropertyOnReceiver('scale', this, value);
  static const String SCALE_PROPERTY = 'scale';
  bool get scaleSet => _staticInfo.getGPropertyOnReceiver('scale-set', this);
  void set scaleSet(bool value) => _staticInfo.setGPropertyOnReceiver('scale-set', this, value);
  static const String SCALE_SET_PROPERTY = 'scale-set';
  bool get singleParagraphMode => _staticInfo.getGPropertyOnReceiver('single-paragraph-mode', this);
  void set singleParagraphMode(bool value) => _staticInfo.setGPropertyOnReceiver('single-paragraph-mode', this, value);
  static const String SINGLE_PARAGRAPH_MODE_PROPERTY = 'single-paragraph-mode';
  int get size => _staticInfo.getGPropertyOnReceiver('size', this);
  void set size(int value) => _staticInfo.setGPropertyOnReceiver('size', this, value);
  static const String SIZE_PROPERTY = 'size';
  num get sizePoints => _staticInfo.getGPropertyOnReceiver('size-points', this);
  void set sizePoints(num value) => _staticInfo.setGPropertyOnReceiver('size-points', this, value);
  static const String SIZE_POINTS_PROPERTY = 'size-points';
  bool get sizeSet => _staticInfo.getGPropertyOnReceiver('size-set', this);
  void set sizeSet(bool value) => _staticInfo.setGPropertyOnReceiver('size-set', this, value);
  static const String SIZE_SET_PROPERTY = 'size-set';
  Stretch get stretch => _staticInfo.getGPropertyOnReceiver('stretch', this);
  void set stretch(Stretch value) => _staticInfo.setGPropertyOnReceiver('stretch', this, value);
  static const String STRETCH_PROPERTY = 'stretch';
  bool get stretchSet => _staticInfo.getGPropertyOnReceiver('stretch-set', this);
  void set stretchSet(bool value) => _staticInfo.setGPropertyOnReceiver('stretch-set', this, value);
  static const String STRETCH_SET_PROPERTY = 'stretch-set';
  bool get strikethrough => _staticInfo.getGPropertyOnReceiver('strikethrough', this);
  void set strikethrough(bool value) => _staticInfo.setGPropertyOnReceiver('strikethrough', this, value);
  static const String STRIKETHROUGH_PROPERTY = 'strikethrough';
  bool get strikethroughSet => _staticInfo.getGPropertyOnReceiver('strikethrough-set', this);
  void set strikethroughSet(bool value) => _staticInfo.setGPropertyOnReceiver('strikethrough-set', this, value);
  static const String STRIKETHROUGH_SET_PROPERTY = 'strikethrough-set';
  pango.Style get style => _staticInfo.getGPropertyOnReceiver('style', this);
  void set style(pango.Style value) => _staticInfo.setGPropertyOnReceiver('style', this, value);
  static const String STYLE_PROPERTY = 'style';
  bool get styleSet => _staticInfo.getGPropertyOnReceiver('style-set', this);
  void set styleSet(bool value) => _staticInfo.setGPropertyOnReceiver('style-set', this, value);
  static const String STYLE_SET_PROPERTY = 'style-set';
  String get text => _staticInfo.getGPropertyOnReceiver('text', this);
  void set text(String value) => _staticInfo.setGPropertyOnReceiver('text', this, value);
  static const String TEXT_PROPERTY = 'text';
  Underline get underline => _staticInfo.getGPropertyOnReceiver('underline', this);
  void set underline(Underline value) => _staticInfo.setGPropertyOnReceiver('underline', this, value);
  static const String UNDERLINE_PROPERTY = 'underline';
  bool get underlineSet => _staticInfo.getGPropertyOnReceiver('underline-set', this);
  void set underlineSet(bool value) => _staticInfo.setGPropertyOnReceiver('underline-set', this, value);
  static const String UNDERLINE_SET_PROPERTY = 'underline-set';
  pango.Variant get variant => _staticInfo.getGPropertyOnReceiver('variant', this);
  void set variant(pango.Variant value) => _staticInfo.setGPropertyOnReceiver('variant', this, value);
  static const String VARIANT_PROPERTY = 'variant';
  bool get variantSet => _staticInfo.getGPropertyOnReceiver('variant-set', this);
  void set variantSet(bool value) => _staticInfo.setGPropertyOnReceiver('variant-set', this, value);
  static const String VARIANT_SET_PROPERTY = 'variant-set';
  int get weight => _staticInfo.getGPropertyOnReceiver('weight', this);
  void set weight(int value) => _staticInfo.setGPropertyOnReceiver('weight', this, value);
  static const String WEIGHT_PROPERTY = 'weight';
  bool get weightSet => _staticInfo.getGPropertyOnReceiver('weight-set', this);
  void set weightSet(bool value) => _staticInfo.setGPropertyOnReceiver('weight-set', this, value);
  static const String WEIGHT_SET_PROPERTY = 'weight-set';
  int get widthChars => _staticInfo.getGPropertyOnReceiver('width-chars', this);
  void set widthChars(int value) => _staticInfo.setGPropertyOnReceiver('width-chars', this, value);
  static const String WIDTH_CHARS_PROPERTY = 'width-chars';
  WrapMode get wrapMode => _staticInfo.getGPropertyOnReceiver('wrap-mode', this);
  void set wrapMode(WrapMode value) => _staticInfo.setGPropertyOnReceiver('wrap-mode', this, value);
  static const String WRAP_MODE_PROPERTY = 'wrap-mode';
  int get wrapWidth => _staticInfo.getGPropertyOnReceiver('wrap-width', this);
  void set wrapWidth(int value) => _staticInfo.setGPropertyOnReceiver('wrap-width', this, value);
  static const String WRAP_WIDTH_PROPERTY = 'wrap-width';
  factory CellRendererText() => _staticInfo.callStatic('new', []);
  void setFixedHeightFromFont(int numberOfRows) => _staticInfo.callMethodOnReceiver('set_fixed_height_from_font', this, [numberOfRows]);
  int _connectToEdited(bool after, void func(String path, String newText)) => signalConnect('edited', func, after);
  Stream<CellRendererTextEditedEvent> get onEdited {
    int signalId;
    StreamController<CellRendererTextEditedEvent> controller;
    controller = new StreamController<CellRendererTextEditedEvent>(
      onListen: () {
          signalId = _connectToEdited(false, (String path, String newText) {
              var result = new CellRendererTextEditedEvent(path, newText);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<CellRendererTextEditedEvent> get afterEdited {
    int signalId;
    StreamController<CellRendererTextEditedEvent> controller;
    controller = new StreamController<CellRendererTextEditedEvent>(
      onListen: () {
          signalId = _connectToEdited(true, (String path, String newText) {
              var result = new CellRendererTextEditedEvent(path, newText);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class CellRendererTextEditedEvent {
  final String path;
  final String newText;

  CellRendererTextEditedEvent(this.path, this.newText);
}

class CellRendererToggle extends CellRenderer {
  CellRendererToggle.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellRendererToggle');

  static const String ACTIVATABLE_PROPERTY = 'activatable';
  static const String ACTIVE_PROPERTY = 'active';
  bool get inconsistent => _staticInfo.getGPropertyOnReceiver('inconsistent', this);
  void set inconsistent(bool value) => _staticInfo.setGPropertyOnReceiver('inconsistent', this, value);
  static const String INCONSISTENT_PROPERTY = 'inconsistent';
  int get indicatorSize => _staticInfo.getGPropertyOnReceiver('indicator-size', this);
  void set indicatorSize(int value) => _staticInfo.setGPropertyOnReceiver('indicator-size', this, value);
  static const String INDICATOR_SIZE_PROPERTY = 'indicator-size';
  static const String RADIO_PROPERTY = 'radio';
  factory CellRendererToggle() => _staticInfo.callStatic('new', []);
  bool get activatable => _staticInfo.callMethodOnReceiver('get_activatable', this, []);
  bool get active => _staticInfo.callMethodOnReceiver('get_active', this, []);
  bool get radio => _staticInfo.callMethodOnReceiver('get_radio', this, []);
  void set activatable(bool setting) => _staticInfo.callMethodOnReceiver('set_activatable', this, [setting]);
  void set active(bool setting) => _staticInfo.callMethodOnReceiver('set_active', this, [setting]);
  void set radio(bool radio) => _staticInfo.callMethodOnReceiver('set_radio', this, [radio]);
  int _connectToToggled(bool after, void func(String path)) => signalConnect('toggled', func, after);
  Stream<String> get onToggled {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToToggled(false, (String path) {
              controller.add(path);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<String> get afterToggled {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToToggled(true, (String path) {
              controller.add(path);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class CellView extends Widget with ImplementorIface, Buildable, CellLayout, Orientable {
  CellView.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CellView');

  void set background(String value) => _staticInfo.setGPropertyOnReceiver('background', this, value);
  static const String BACKGROUND_PROPERTY = 'background';
  Color get backgroundGdk => _staticInfo.getGPropertyOnReceiver('background-gdk', this);
  void set backgroundGdk(Color value) => _staticInfo.setGPropertyOnReceiver('background-gdk', this, value);
  static const String BACKGROUND_GDK_PROPERTY = 'background-gdk';
  RGBA get backgroundRgba => _staticInfo.getGPropertyOnReceiver('background-rgba', this);
  static const String BACKGROUND_RGBA_PROPERTY = 'background-rgba';
  bool get backgroundSet => _staticInfo.getGPropertyOnReceiver('background-set', this);
  void set backgroundSet(bool value) => _staticInfo.setGPropertyOnReceiver('background-set', this, value);
  static const String BACKGROUND_SET_PROPERTY = 'background-set';
  CellArea get cellArea => _staticInfo.getGPropertyOnReceiver('cell-area', this);
  void set cellArea(CellArea value) => _staticInfo.setGPropertyOnReceiver('cell-area', this, value);
  static const String CELL_AREA_PROPERTY = 'cell-area';
  CellAreaContext get cellAreaContext => _staticInfo.getGPropertyOnReceiver('cell-area-context', this);
  void set cellAreaContext(CellAreaContext value) => _staticInfo.setGPropertyOnReceiver('cell-area-context', this, value);
  static const String CELL_AREA_CONTEXT_PROPERTY = 'cell-area-context';
  static const String DRAW_SENSITIVE_PROPERTY = 'draw-sensitive';
  static const String FIT_MODEL_PROPERTY = 'fit-model';
  static const String MODEL_PROPERTY = 'model';
  factory CellView() => _staticInfo.callStatic('new', []);
  factory CellView.withContext(CellArea area, CellAreaContext context) => _staticInfo.callStatic('new_with_context', [area, context]);
  factory CellView.withMarkup(String markup) => _staticInfo.callStatic('new_with_markup', [markup]);
  factory CellView.withPixbuf(Pixbuf pixbuf) => _staticInfo.callStatic('new_with_pixbuf', [pixbuf]);
  factory CellView.withText(String text) => _staticInfo.callStatic('new_with_text', [text]);
  TreePath getDisplayedRow() => _staticInfo.callMethodOnReceiver('get_displayed_row', this, []);
  bool get drawSensitive => _staticInfo.callMethodOnReceiver('get_draw_sensitive', this, []);
  bool get fitModel => _staticInfo.callMethodOnReceiver('get_fit_model', this, []);
  TreeModel get model => _staticInfo.callMethodOnReceiver('get_model', this, []);
  bool getSizeOfRow(TreePath path) => _staticInfo.callMethodOnReceiver('get_size_of_row', this, [path]);
  void setBackgroundColor(Color color) => _staticInfo.callMethodOnReceiver('set_background_color', this, [color]);
  void set backgroundRgba_(RGBA rgba) => _staticInfo.callMethodOnReceiver('set_background_rgba', this, [rgba]);
  void setDisplayedRow(TreePath path) => _staticInfo.callMethodOnReceiver('set_displayed_row', this, [path]);
  void set drawSensitive(bool drawSensitive) => _staticInfo.callMethodOnReceiver('set_draw_sensitive', this, [drawSensitive]);
  void set fitModel(bool fitModel) => _staticInfo.callMethodOnReceiver('set_fit_model', this, [fitModel]);
  void set model(TreeModel model) => _staticInfo.callMethodOnReceiver('set_model', this, [model]);
}

class CheckButton extends ToggleButton with ImplementorIface, Actionable, Activatable, Buildable {
  CheckButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CheckButton');

  factory CheckButton() => _staticInfo.callStatic('new', []);
  factory CheckButton.withLabel(String label) => _staticInfo.callStatic('new_with_label', [label]);
  factory CheckButton.withMnemonic(String label) => _staticInfo.callStatic('new_with_mnemonic', [label]);
}

class CheckMenuItem extends MenuItem with ImplementorIface, Actionable, Activatable, Buildable {
  CheckMenuItem.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CheckMenuItem');

  static const String ACTIVE_PROPERTY = 'active';
  static const String DRAW_AS_RADIO_PROPERTY = 'draw-as-radio';
  static const String INCONSISTENT_PROPERTY = 'inconsistent';
  factory CheckMenuItem() => _staticInfo.callStatic('new', []);
  factory CheckMenuItem.withLabel(String label) => _staticInfo.callStatic('new_with_label', [label]);
  factory CheckMenuItem.withMnemonic(String label) => _staticInfo.callStatic('new_with_mnemonic', [label]);
  bool get active => _staticInfo.callMethodOnReceiver('get_active', this, []);
  bool get drawAsRadio => _staticInfo.callMethodOnReceiver('get_draw_as_radio', this, []);
  bool get inconsistent => _staticInfo.callMethodOnReceiver('get_inconsistent', this, []);
  void set active(bool isActive) => _staticInfo.callMethodOnReceiver('set_active', this, [isActive]);
  void set drawAsRadio(bool drawAsRadio) => _staticInfo.callMethodOnReceiver('set_draw_as_radio', this, [drawAsRadio]);
  void set inconsistent(bool setting) => _staticInfo.callMethodOnReceiver('set_inconsistent', this, [setting]);
  void toggled() => _staticInfo.callMethodOnReceiver('toggled', this, []);
  int _connectToToggled(bool after, void func()) => signalConnect('toggled', func, after);
  Stream get onToggled {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggled(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterToggled {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggled(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class CheckMenuItemAccessible extends MenuItemAccessible with atk.Action, Component, Selection {
  CheckMenuItemAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CheckMenuItemAccessible');

}

class Clipboard extends GObjectObject {
  Clipboard.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Clipboard');

  static Clipboard get_(Atom selection) => _staticInfo.callStatic('get', [selection]);
  static Clipboard getDefault(Display display) => _staticInfo.callStatic('get_default', [display]);
  static Clipboard getForDisplay(Display display, Atom selection) => _staticInfo.callStatic('get_for_display', [display, selection]);
  void clear() => _staticInfo.callMethodOnReceiver('clear', this, []);
  Display getDisplay() => _staticInfo.callMethodOnReceiver('get_display', this, []);
  GObjectObject getOwner() => _staticInfo.callMethodOnReceiver('get_owner', this, []);
  void requestContents(Atom target, ClipboardReceivedFunc callback) => _staticInfo.callMethodOnReceiver('request_contents', this, [target, callback]);
  void requestImage(ClipboardImageReceivedFunc callback) => _staticInfo.callMethodOnReceiver('request_image', this, [callback]);
  void requestRichText(TextBuffer buffer, ClipboardRichTextReceivedFunc callback) => _staticInfo.callMethodOnReceiver('request_rich_text', this, [buffer, callback]);
  void requestTargets(ClipboardTargetsReceivedFunc callback) => _staticInfo.callMethodOnReceiver('request_targets', this, [callback]);
  void requestText(ClipboardTextReceivedFunc callback) => _staticInfo.callMethodOnReceiver('request_text', this, [callback]);
  void requestUris(ClipboardURIReceivedFunc callback) => _staticInfo.callMethodOnReceiver('request_uris', this, [callback]);
  void setCanStore(List<TargetEntry> targets) => _staticInfo.callMethodOnReceiver('set_can_store', this, [targets]);
  void setImage(Pixbuf pixbuf) => _staticInfo.callMethodOnReceiver('set_image', this, [pixbuf]);
  void setText(String text, int len) => _staticInfo.callMethodOnReceiver('set_text', this, [text, len]);
  void store() => _staticInfo.callMethodOnReceiver('store', this, []);
  SelectionData waitForContents(Atom target) => _staticInfo.callMethodOnReceiver('wait_for_contents', this, [target]);
  Pixbuf waitForImage() => _staticInfo.callMethodOnReceiver('wait_for_image', this, []);
  List<int> waitForRichText(TextBuffer buffer) => _staticInfo.callMethodOnReceiver('wait_for_rich_text', this, [buffer]);
  bool waitForTargets() => _staticInfo.callMethodOnReceiver('wait_for_targets', this, []);
  String waitForText() => _staticInfo.callMethodOnReceiver('wait_for_text', this, []);
  List<String> waitForUris() => _staticInfo.callMethodOnReceiver('wait_for_uris', this, []);
  bool waitIsImageAvailable() => _staticInfo.callMethodOnReceiver('wait_is_image_available', this, []);
  bool waitIsRichTextAvailable(TextBuffer buffer) => _staticInfo.callMethodOnReceiver('wait_is_rich_text_available', this, [buffer]);
  bool waitIsTargetAvailable(Atom target) => _staticInfo.callMethodOnReceiver('wait_is_target_available', this, [target]);
  bool waitIsTextAvailable() => _staticInfo.callMethodOnReceiver('wait_is_text_available', this, []);
  bool waitIsUrisAvailable() => _staticInfo.callMethodOnReceiver('wait_is_uris_available', this, []);
  int _connectToOwnerChange(bool after, void func(EventOwnerChange event)) => signalConnect('owner-change', func, after);
  Stream<EventOwnerChange> get onOwnerChange {
    int signalId;
    StreamController<EventOwnerChange> controller;
    controller = new StreamController<EventOwnerChange>(
      onListen: () {
          signalId = _connectToOwnerChange(false, (EventOwnerChange event) {
              controller.add(event);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EventOwnerChange> get afterOwnerChange {
    int signalId;
    StreamController<EventOwnerChange> controller;
    controller = new StreamController<EventOwnerChange>(
      onListen: () {
          signalId = _connectToOwnerChange(true, (EventOwnerChange event) {
              controller.add(event);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

typedef void ClipboardClearFunc(Clipboard clipboard);
typedef void ClipboardGetFunc(Clipboard clipboard, SelectionData selectionData, int info);
typedef void ClipboardImageReceivedFunc(Clipboard clipboard, Pixbuf pixbuf);
typedef void ClipboardReceivedFunc(Clipboard clipboard, SelectionData selectionData);
typedef void ClipboardRichTextReceivedFunc(Clipboard clipboard, Atom format, String text, int length);
typedef void ClipboardTargetsReceivedFunc(Clipboard clipboard, List<Atom> atoms);
typedef void ClipboardTextReceivedFunc(Clipboard clipboard, String text);
typedef void ClipboardURIReceivedFunc(Clipboard clipboard, List<String> uris);
class ColorButton extends Button with ImplementorIface, Actionable, Activatable, Buildable, ColorChooser {
  ColorButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ColorButton');

  static const String ALPHA_PROPERTY = 'alpha';
  static const String COLOR_PROPERTY = 'color';
  RGBA get rgba => _staticInfo.getGPropertyOnReceiver('rgba', this);
  void set rgba(RGBA value) => _staticInfo.setGPropertyOnReceiver('rgba', this, value);
  static const String RGBA_PROPERTY = 'rgba';
  static const String TITLE_PROPERTY = 'title';
  static const String USE_ALPHA_PROPERTY = 'use-alpha';
  factory ColorButton() => _staticInfo.callStatic('new', []);
  factory ColorButton.withColor(Color color) => _staticInfo.callStatic('new_with_color', [color]);
  factory ColorButton.withRgba(RGBA rgba) => _staticInfo.callStatic('new_with_rgba', [rgba]);
  int get alpha => _staticInfo.callMethodOnReceiver('get_alpha', this, []);
  void getColor() => _staticInfo.callMethodOnReceiver('get_color', this, []);
  String get title => _staticInfo.callMethodOnReceiver('get_title', this, []);
  bool get useAlpha => _staticInfo.callMethodOnReceiver('get_use_alpha', this, []);
  void set alpha(int alpha) => _staticInfo.callMethodOnReceiver('set_alpha', this, [alpha]);
  void set color(Color color) => _staticInfo.callMethodOnReceiver('set_color', this, [color]);
  void set title(String title) => _staticInfo.callMethodOnReceiver('set_title', this, [title]);
  void set useAlpha(bool useAlpha) => _staticInfo.callMethodOnReceiver('set_use_alpha', this, [useAlpha]);
  int _connectToColorSet(bool after, void func()) => signalConnect('color-set', func, after);
  Stream get onColorSet {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToColorSet(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterColorSet {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToColorSet(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

abstract class ColorChooser extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ColorChooser');



  static const String RGBA_PROPERTY = 'rgba';
  static const String USE_ALPHA_PROPERTY = 'use-alpha';
  void addPalette(Orientation orientation, int colorsPerLine, List<RGBA> colors) => _staticInfo.callMethodOnReceiver('add_palette', this, [orientation, colorsPerLine, colors]);
  void getRgba() => _staticInfo.callMethodOnReceiver('get_rgba', this, []);
  bool get useAlpha => _staticInfo.callMethodOnReceiver('get_use_alpha', this, []);
  void set rgba(RGBA color) => _staticInfo.callMethodOnReceiver('set_rgba', this, [color]);
  void set useAlpha(bool useAlpha) => _staticInfo.callMethodOnReceiver('set_use_alpha', this, [useAlpha]);
  int _connectToColorActivated(bool after, void func(RGBA color)) => signalConnect('color-activated', func, after);
  Stream<RGBA> get onColorActivated {
    int signalId;
    StreamController<RGBA> controller;
    controller = new StreamController<RGBA>(
      onListen: () {
          signalId = _connectToColorActivated(false, (RGBA color) {
              controller.add(color);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<RGBA> get afterColorActivated {
    int signalId;
    StreamController<RGBA> controller;
    controller = new StreamController<RGBA>(
      onListen: () {
          signalId = _connectToColorActivated(true, (RGBA color) {
              controller.add(color);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ColorChooserDialog extends Dialog with ImplementorIface, Buildable, ColorChooser {
  ColorChooserDialog.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ColorChooserDialog');

  bool get showEditor => _staticInfo.getGPropertyOnReceiver('show-editor', this);
  void set showEditor(bool value) => _staticInfo.setGPropertyOnReceiver('show-editor', this, value);
  static const String SHOW_EDITOR_PROPERTY = 'show-editor';
  factory ColorChooserDialog(String title, Window parent) => _staticInfo.callStatic('new', [title, parent]);
}

class ColorChooserWidget extends Box with ImplementorIface, Buildable, ColorChooser, Orientable {
  ColorChooserWidget.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ColorChooserWidget');

  bool get showEditor => _staticInfo.getGPropertyOnReceiver('show-editor', this);
  void set showEditor(bool value) => _staticInfo.setGPropertyOnReceiver('show-editor', this, value);
  static const String SHOW_EDITOR_PROPERTY = 'show-editor';
  factory ColorChooserWidget() => _staticInfo.callStatic('new', []);
}

class ColorSelection extends Box with ImplementorIface, Buildable, Orientable {
  ColorSelection.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ColorSelection');

  static const String CURRENT_ALPHA_PROPERTY = 'current-alpha';
  static const String CURRENT_COLOR_PROPERTY = 'current-color';
  static const String CURRENT_RGBA_PROPERTY = 'current-rgba';
  static const String HAS_OPACITY_CONTROL_PROPERTY = 'has-opacity-control';
  static const String HAS_PALETTE_PROPERTY = 'has-palette';
  factory ColorSelection() => _staticInfo.callStatic('new', []);
  static bool paletteFromString(String str) => _staticInfo.callStatic('palette_from_string', [str]);
  static String paletteToString(List<Color> colors) => _staticInfo.callStatic('palette_to_string', [colors]);
  int get currentAlpha => _staticInfo.callMethodOnReceiver('get_current_alpha', this, []);
  void getCurrentColor() => _staticInfo.callMethodOnReceiver('get_current_color', this, []);
  void getCurrentRgba() => _staticInfo.callMethodOnReceiver('get_current_rgba', this, []);
  bool get hasOpacityControl => _staticInfo.callMethodOnReceiver('get_has_opacity_control', this, []);
  bool get hasPalette => _staticInfo.callMethodOnReceiver('get_has_palette', this, []);
  int getPreviousAlpha() => _staticInfo.callMethodOnReceiver('get_previous_alpha', this, []);
  void getPreviousColor() => _staticInfo.callMethodOnReceiver('get_previous_color', this, []);
  void getPreviousRgba() => _staticInfo.callMethodOnReceiver('get_previous_rgba', this, []);
  bool isAdjusting() => _staticInfo.callMethodOnReceiver('is_adjusting', this, []);
  void set currentAlpha(int alpha) => _staticInfo.callMethodOnReceiver('set_current_alpha', this, [alpha]);
  void set currentColor(Color color) => _staticInfo.callMethodOnReceiver('set_current_color', this, [color]);
  void set currentRgba(RGBA rgba) => _staticInfo.callMethodOnReceiver('set_current_rgba', this, [rgba]);
  void set hasOpacityControl(bool hasOpacity) => _staticInfo.callMethodOnReceiver('set_has_opacity_control', this, [hasOpacity]);
  void set hasPalette(bool hasPalette) => _staticInfo.callMethodOnReceiver('set_has_palette', this, [hasPalette]);
  void setPreviousAlpha(int alpha) => _staticInfo.callMethodOnReceiver('set_previous_alpha', this, [alpha]);
  void setPreviousColor(Color color) => _staticInfo.callMethodOnReceiver('set_previous_color', this, [color]);
  void setPreviousRgba(RGBA rgba) => _staticInfo.callMethodOnReceiver('set_previous_rgba', this, [rgba]);
  int _connectToColorChanged(bool after, void func()) => signalConnect('color-changed', func, after);
  Stream get onColorChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToColorChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterColorChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToColorChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

typedef void ColorSelectionChangePaletteFunc(List<Color> colors);
typedef void ColorSelectionChangePaletteWithScreenFunc(Screen screen, List<Color> colors);
class ColorSelectionDialog extends Dialog with ImplementorIface, Buildable {
  ColorSelectionDialog.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ColorSelectionDialog');

  Widget get cancelButton => _staticInfo.getGPropertyOnReceiver('cancel-button', this);
  static const String CANCEL_BUTTON_PROPERTY = 'cancel-button';
  static const String COLOR_SELECTION_PROPERTY = 'color-selection';
  Widget get helpButton => _staticInfo.getGPropertyOnReceiver('help-button', this);
  static const String HELP_BUTTON_PROPERTY = 'help-button';
  Widget get okButton => _staticInfo.getGPropertyOnReceiver('ok-button', this);
  static const String OK_BUTTON_PROPERTY = 'ok-button';
  factory ColorSelectionDialog(String title) => _staticInfo.callStatic('new', [title]);
  Widget get colorSelection => _staticInfo.callMethodOnReceiver('get_color_selection', this, []);
}

class ComboBox extends Bin with ImplementorIface, Buildable, CellEditable, CellLayout {
  ComboBox.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ComboBox');

  static const String ACTIVE_PROPERTY = 'active';
  static const String ACTIVE_ID_PROPERTY = 'active-id';
  static const String ADD_TEAROFFS_PROPERTY = 'add-tearoffs';
  static const String BUTTON_SENSITIVITY_PROPERTY = 'button-sensitivity';
  CellArea get cellArea => _staticInfo.getGPropertyOnReceiver('cell-area', this);
  void set cellArea(CellArea value) => _staticInfo.setGPropertyOnReceiver('cell-area', this, value);
  static const String CELL_AREA_PROPERTY = 'cell-area';
  static const String COLUMN_SPAN_COLUMN_PROPERTY = 'column-span-column';
  static const String ENTRY_TEXT_COLUMN_PROPERTY = 'entry-text-column';
  static const String FOCUS_ON_CLICK_PROPERTY = 'focus-on-click';
  void set hasEntry(bool value) => _staticInfo.setGPropertyOnReceiver('has-entry', this, value);
  static const String HAS_ENTRY_PROPERTY = 'has-entry';
  bool get hasFrame => _staticInfo.getGPropertyOnReceiver('has-frame', this);
  void set hasFrame(bool value) => _staticInfo.setGPropertyOnReceiver('has-frame', this, value);
  static const String HAS_FRAME_PROPERTY = 'has-frame';
  static const String ID_COLUMN_PROPERTY = 'id-column';
  static const String MODEL_PROPERTY = 'model';
  static const String POPUP_FIXED_WIDTH_PROPERTY = 'popup-fixed-width';
  bool get popupShown => _staticInfo.getGPropertyOnReceiver('popup-shown', this);
  static const String POPUP_SHOWN_PROPERTY = 'popup-shown';
  static const String ROW_SPAN_COLUMN_PROPERTY = 'row-span-column';
  String get tearoffTitle => _staticInfo.getGPropertyOnReceiver('tearoff-title', this);
  void set tearoffTitle(String value) => _staticInfo.setGPropertyOnReceiver('tearoff-title', this, value);
  static const String TEAROFF_TITLE_PROPERTY = 'tearoff-title';
  static const String WRAP_WIDTH_PROPERTY = 'wrap-width';
  factory ComboBox() => _staticInfo.callStatic('new', []);
  factory ComboBox.withArea(CellArea area) => _staticInfo.callStatic('new_with_area', [area]);
  factory ComboBox.withAreaAndEntry(CellArea area) => _staticInfo.callStatic('new_with_area_and_entry', [area]);
  factory ComboBox.withEntry() => _staticInfo.callStatic('new_with_entry', []);
  factory ComboBox.withModel(TreeModel model) => _staticInfo.callStatic('new_with_model', [model]);
  factory ComboBox.withModelAndEntry(TreeModel model) => _staticInfo.callStatic('new_with_model_and_entry', [model]);
  int get active => _staticInfo.callMethodOnReceiver('get_active', this, []);
  String get activeId => _staticInfo.callMethodOnReceiver('get_active_id', this, []);
  bool getActiveIter() => _staticInfo.callMethodOnReceiver('get_active_iter', this, []);
  bool get addTearoffs => _staticInfo.callMethodOnReceiver('get_add_tearoffs', this, []);
  SensitivityType get buttonSensitivity => _staticInfo.callMethodOnReceiver('get_button_sensitivity', this, []);
  int get columnSpanColumn => _staticInfo.callMethodOnReceiver('get_column_span_column', this, []);
  int get entryTextColumn => _staticInfo.callMethodOnReceiver('get_entry_text_column', this, []);
  bool get focusOnClick => _staticInfo.callMethodOnReceiver('get_focus_on_click', this, []);
  bool get hasEntry_ => _staticInfo.callMethodOnReceiver('get_has_entry', this, []);
  int get idColumn => _staticInfo.callMethodOnReceiver('get_id_column', this, []);
  TreeModel get model => _staticInfo.callMethodOnReceiver('get_model', this, []);
  AtkObject getPopupAccessible() => _staticInfo.callMethodOnReceiver('get_popup_accessible', this, []);
  bool get popupFixedWidth => _staticInfo.callMethodOnReceiver('get_popup_fixed_width', this, []);
  int get rowSpanColumn => _staticInfo.callMethodOnReceiver('get_row_span_column', this, []);
  String getTitle() => _staticInfo.callMethodOnReceiver('get_title', this, []);
  int get wrapWidth => _staticInfo.callMethodOnReceiver('get_wrap_width', this, []);
  void popdown() => _staticInfo.callMethodOnReceiver('popdown', this, []);
  void popup() => _staticInfo.callMethodOnReceiver('popup', this, []);
  void popupForDevice(Device device) => _staticInfo.callMethodOnReceiver('popup_for_device', this, [device]);
  void set active(int index_) => _staticInfo.callMethodOnReceiver('set_active', this, [index_]);
  bool setActiveId(String activeId) => _staticInfo.callMethodOnReceiver('set_active_id', this, [activeId]);
  void setActiveIter(TreeIter iter) => _staticInfo.callMethodOnReceiver('set_active_iter', this, [iter]);
  void set addTearoffs(bool addTearoffs) => _staticInfo.callMethodOnReceiver('set_add_tearoffs', this, [addTearoffs]);
  void set buttonSensitivity(SensitivityType sensitivity) => _staticInfo.callMethodOnReceiver('set_button_sensitivity', this, [sensitivity]);
  void set columnSpanColumn(int columnSpan) => _staticInfo.callMethodOnReceiver('set_column_span_column', this, [columnSpan]);
  void set entryTextColumn(int textColumn) => _staticInfo.callMethodOnReceiver('set_entry_text_column', this, [textColumn]);
  void set focusOnClick(bool focusOnClick) => _staticInfo.callMethodOnReceiver('set_focus_on_click', this, [focusOnClick]);
  void set idColumn(int idColumn) => _staticInfo.callMethodOnReceiver('set_id_column', this, [idColumn]);
  void set model(TreeModel model) => _staticInfo.callMethodOnReceiver('set_model', this, [model]);
  void set popupFixedWidth(bool fixed) => _staticInfo.callMethodOnReceiver('set_popup_fixed_width', this, [fixed]);
  void setRowSeparatorFunc(TreeViewRowSeparatorFunc func) => _staticInfo.callMethodOnReceiver('set_row_separator_func', this, [func]);
  void set rowSpanColumn(int rowSpan) => _staticInfo.callMethodOnReceiver('set_row_span_column', this, [rowSpan]);
  void setTitle(String title) => _staticInfo.callMethodOnReceiver('set_title', this, [title]);
  void set wrapWidth(int width) => _staticInfo.callMethodOnReceiver('set_wrap_width', this, [width]);
  int _connectToChanged(bool after, void func()) => signalConnect('changed', func, after);
  Stream get onChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int connectToFormatEntryText(bool after, String func(String path)) => signalConnect('format-entry-text', func, after);
  int _connectToMoveActive(bool after, void func(ScrollType scrollType)) => signalConnect('move-active', func, after);
  Stream<ScrollType> get onMoveActive {
    int signalId;
    StreamController<ScrollType> controller;
    controller = new StreamController<ScrollType>(
      onListen: () {
          signalId = _connectToMoveActive(false, (ScrollType scrollType) {
              controller.add(scrollType);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ScrollType> get afterMoveActive {
    int signalId;
    StreamController<ScrollType> controller;
    controller = new StreamController<ScrollType>(
      onListen: () {
          signalId = _connectToMoveActive(true, (ScrollType scrollType) {
              controller.add(scrollType);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPopdown(bool after, bool func()) => signalConnect('popdown', func, after);
  Stream<ComboBoxPopdownEvent> get onPopdown {
    int signalId;
    StreamController<ComboBoxPopdownEvent> controller;
    controller = new StreamController<ComboBoxPopdownEvent>(
      onListen: () {
          signalId = _connectToPopdown(false, () {
              var result = new ComboBoxPopdownEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ComboBoxPopdownEvent> get afterPopdown {
    int signalId;
    StreamController<ComboBoxPopdownEvent> controller;
    controller = new StreamController<ComboBoxPopdownEvent>(
      onListen: () {
          signalId = _connectToPopdown(true, () {
              var result = new ComboBoxPopdownEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPopup(bool after, void func()) => signalConnect('popup', func, after);
  Stream get onPopup {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPopup(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPopup {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPopup(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ComboBoxPopdownEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  ComboBoxPopdownEvent();
}

class ComboBoxAccessible extends ContainerAccessible with atk.Action, Component, Selection {
  ComboBoxAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ComboBoxAccessible');

}

class ComboBoxText extends ComboBox with ImplementorIface, Buildable, CellEditable, CellLayout {
  ComboBoxText.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ComboBoxText');

  factory ComboBoxText() => _staticInfo.callStatic('new', []);
  factory ComboBoxText.withEntry() => _staticInfo.callStatic('new_with_entry', []);
  void append(String id, String text) => _staticInfo.callMethodOnReceiver('append', this, [id, text]);
  void appendText(String text) => _staticInfo.callMethodOnReceiver('append_text', this, [text]);
  String getActiveText() => _staticInfo.callMethodOnReceiver('get_active_text', this, []);
  void insert(int position, String id, String text) => _staticInfo.callMethodOnReceiver('insert', this, [position, id, text]);
  void insertText(int position, String text) => _staticInfo.callMethodOnReceiver('insert_text', this, [position, text]);
  void prepend(String id, String text) => _staticInfo.callMethodOnReceiver('prepend', this, [id, text]);
  void prependText(String text) => _staticInfo.callMethodOnReceiver('prepend_text', this, [text]);
  void comboBoxTextRemove(int position) => _staticInfo.callMethodOnReceiver('remove', this, [position]);
  void removeAll() => _staticInfo.callMethodOnReceiver('remove_all', this, []);
}

class Container extends Widget with ImplementorIface, Buildable {
  Container.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Container');

  static const String BORDER_WIDTH_PROPERTY = 'border-width';
  void set child(Widget value) => _staticInfo.setGPropertyOnReceiver('child', this, value);
  static const String CHILD_PROPERTY = 'child';
  static const String RESIZE_MODE_PROPERTY = 'resize-mode';
  void add(Widget widget) => _staticInfo.callMethodOnReceiver('add', this, [widget]);
  void checkResize() => _staticInfo.callMethodOnReceiver('check_resize', this, []);
  void childGetProperty(Widget child, String propertyName, Value value) => _staticInfo.callMethodOnReceiver('child_get_property', this, [child, propertyName, value]);
  void containerChildNotify(Widget child, String childProperty) => _staticInfo.callMethodOnReceiver('child_notify', this, [child, childProperty]);
  void childNotifyByPspec(Widget child, ParamSpec pspec) => _staticInfo.callMethodOnReceiver('child_notify_by_pspec', this, [child, pspec]);
  void childSetProperty(Widget child, String propertyName, Value value) => _staticInfo.callMethodOnReceiver('child_set_property', this, [child, propertyName, value]);
  int childType() => _staticInfo.callMethodOnReceiver('child_type', this, []);
  void forall(Callback callback) => _staticInfo.callMethodOnReceiver('forall', this, [callback]);
  void foreach(Callback callback) => _staticInfo.callMethodOnReceiver('foreach', this, [callback]);
  int get borderWidth => _staticInfo.callMethodOnReceiver('get_border_width', this, []);
  GLibList /* this will fail */ getChildren() => _staticInfo.callMethodOnReceiver('get_children', this, []);
  bool getFocusChain() => _staticInfo.callMethodOnReceiver('get_focus_chain', this, []);
  Widget getFocusChild() => _staticInfo.callMethodOnReceiver('get_focus_child', this, []);
  Adjustment getFocusHadjustment() => _staticInfo.callMethodOnReceiver('get_focus_hadjustment', this, []);
  Adjustment getFocusVadjustment() => _staticInfo.callMethodOnReceiver('get_focus_vadjustment', this, []);
  WidgetPath getPathForChild(Widget child) => _staticInfo.callMethodOnReceiver('get_path_for_child', this, [child]);
  ResizeMode get resizeMode => _staticInfo.callMethodOnReceiver('get_resize_mode', this, []);
  void propagateDraw(Widget child, Context cr) => _staticInfo.callMethodOnReceiver('propagate_draw', this, [child, cr]);
  void remove(Widget widget) => _staticInfo.callMethodOnReceiver('remove', this, [widget]);
  void resizeChildren() => _staticInfo.callMethodOnReceiver('resize_children', this, []);
  void set borderWidth(int borderWidth) => _staticInfo.callMethodOnReceiver('set_border_width', this, [borderWidth]);
  void setFocusChain(GLibList focusableWidgets /* this will fail */) => _staticInfo.callMethodOnReceiver('set_focus_chain', this, [focusableWidgets]);
  void setFocusChild(Widget child) => _staticInfo.callMethodOnReceiver('set_focus_child', this, [child]);
  void setFocusHadjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_focus_hadjustment', this, [adjustment]);
  void setFocusVadjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_focus_vadjustment', this, [adjustment]);
  void setReallocateRedraws(bool needsRedraws) => _staticInfo.callMethodOnReceiver('set_reallocate_redraws', this, [needsRedraws]);
  void set resizeMode(ResizeMode resizeMode) => _staticInfo.callMethodOnReceiver('set_resize_mode', this, [resizeMode]);
  void unsetFocusChain() => _staticInfo.callMethodOnReceiver('unset_focus_chain', this, []);
  int _connectToAdd(bool after, void func(Widget object)) => signalConnect('add', func, after);
  Stream<Widget> get onAdd {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToAdd(false, (Widget object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Widget> get afterAdd {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToAdd(true, (Widget object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCheckResize(bool after, void func()) => signalConnect('check-resize', func, after);
  Stream get onCheckResize {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCheckResize(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterCheckResize {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCheckResize(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRemove(bool after, void func(Widget object)) => signalConnect('remove', func, after);
  Stream<Widget> get onRemove {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToRemove(false, (Widget object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Widget> get afterRemove {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToRemove(true, (Widget object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSetFocusChild(bool after, void func(Widget object)) => signalConnect('set-focus-child', func, after);
  Stream<Widget> get onSetFocusChild {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToSetFocusChild(false, (Widget object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Widget> get afterSetFocusChild {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToSetFocusChild(true, (Widget object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ContainerAccessible extends WidgetAccessible with Component {
  ContainerAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ContainerAccessible');

}

class ContainerCellAccessible extends CellAccessible with atk.Action, Component {
  ContainerCellAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ContainerCellAccessible');

  factory ContainerCellAccessible() => _staticInfo.callStatic('new', []);
  void addChild(CellAccessible child) => _staticInfo.callMethodOnReceiver('add_child', this, [child]);
  GLibList /* this will fail */ getChildren() => _staticInfo.callMethodOnReceiver('get_children', this, []);
  void removeChild(CellAccessible child) => _staticInfo.callMethodOnReceiver('remove_child', this, [child]);
}

class CornerType extends GEnumBase {
  const CornerType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CornerType');

  static const CornerType TOP_LEFT = const CornerType(0);
  static const CornerType BOTTOM_LEFT = const CornerType(1);
  static const CornerType TOP_RIGHT = const CornerType(2);
  static const CornerType BOTTOM_RIGHT = const CornerType(3);
  String toString() {
    switch(index) {
      case 0: return 'CornerType.TOP_LEFT';
      case 1: return 'CornerType.BOTTOM_LEFT';
      case 2: return 'CornerType.TOP_RIGHT';
      case 3: return 'CornerType.BOTTOM_RIGHT';
      default: return 'new CornerType($index)';
    }
  }
}

class CssProvider extends GObjectObject with StyleProvider {
  CssProvider.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CssProvider');

  factory CssProvider() => _staticInfo.callStatic('new', []);
  static CssProvider getDefault() => _staticInfo.callStatic('get_default', []);
  static CssProvider getNamed(String name, String variant) => _staticInfo.callStatic('get_named', [name, variant]);
  bool loadFromData(List<int> data) => _staticInfo.callMethodOnReceiver('load_from_data', this, [data]);
  bool loadFromFile(File file) => _staticInfo.callMethodOnReceiver('load_from_file', this, [file]);
  bool loadFromPath(String path) => _staticInfo.callMethodOnReceiver('load_from_path', this, [path]);
  void loadFromResource(String resourcePath) => _staticInfo.callMethodOnReceiver('load_from_resource', this, [resourcePath]);
  String toString() => _staticInfo.callMethodOnReceiver('to_string', this, []);
  int _connectToParsingError(bool after, void func(CssSection section, GErrorBase error)) => signalConnect('parsing-error', func, after);
  Stream<CssProviderParsingErrorEvent> get onParsingError {
    int signalId;
    StreamController<CssProviderParsingErrorEvent> controller;
    controller = new StreamController<CssProviderParsingErrorEvent>(
      onListen: () {
          signalId = _connectToParsingError(false, (CssSection section, GErrorBase error) {
              var result = new CssProviderParsingErrorEvent(section, error);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<CssProviderParsingErrorEvent> get afterParsingError {
    int signalId;
    StreamController<CssProviderParsingErrorEvent> controller;
    controller = new StreamController<CssProviderParsingErrorEvent>(
      onListen: () {
          signalId = _connectToParsingError(true, (CssSection section, GErrorBase error) {
              var result = new CssProviderParsingErrorEvent(section, error);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class CssProviderParsingErrorEvent {
  final CssSection section;
  final GErrorBase error;

  CssProviderParsingErrorEvent(this.section, this.error);
}

class CssProviderErrorCode extends GEnumBase {
  const CssProviderErrorCode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CssProviderError');

  static const CssProviderErrorCode FAILED = const CssProviderErrorCode(0);
  static const CssProviderErrorCode SYNTAX = const CssProviderErrorCode(1);
  static const CssProviderErrorCode IMPORT = const CssProviderErrorCode(2);
  static const CssProviderErrorCode NAME = const CssProviderErrorCode(3);
  static const CssProviderErrorCode DEPRECATED = const CssProviderErrorCode(4);
  static const CssProviderErrorCode UNKNOWN_VALUE = const CssProviderErrorCode(5);
  String toString() {
    switch(index) {
      case 0: return 'CssProviderErrorCode.FAILED';
      case 1: return 'CssProviderErrorCode.SYNTAX';
      case 2: return 'CssProviderErrorCode.IMPORT';
      case 3: return 'CssProviderErrorCode.NAME';
      case 4: return 'CssProviderErrorCode.DEPRECATED';
      case 5: return 'CssProviderErrorCode.UNKNOWN_VALUE';
      default: return 'new CssProviderErrorCode($index)';
    }
  }
  static int quark() => _staticInfo.callStatic('quark', []);
}

class CssProviderError extends GErrorBase {
  static final int _quark = lookupErrorQuarkFromString('gtk-css-provider-error-quark');
  CssProviderError(CssProviderErrorCode code, String message)
      : super.fromFields(_quark, code, message);
}

class CssSection extends GObjectBase {
  CssSection.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CssSection');

  int getEndLine() => _staticInfo.callMethodOnReceiver('get_end_line', this, []);
  int getEndPosition() => _staticInfo.callMethodOnReceiver('get_end_position', this, []);
  File getFile() => _staticInfo.callMethodOnReceiver('get_file', this, []);
  CssSection getParent() => _staticInfo.callMethodOnReceiver('get_parent', this, []);
  CssSectionType getSectionType() => _staticInfo.callMethodOnReceiver('get_section_type', this, []);
  int getStartLine() => _staticInfo.callMethodOnReceiver('get_start_line', this, []);
  int getStartPosition() => _staticInfo.callMethodOnReceiver('get_start_position', this, []);
  CssSection ref() => _staticInfo.callMethodOnReceiver('ref', this, []);
  void unref() => _staticInfo.callMethodOnReceiver('unref', this, []);
}

class CssSectionType extends GEnumBase {
  const CssSectionType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'CssSectionType');

  static const CssSectionType DOCUMENT = const CssSectionType(0);
  static const CssSectionType IMPORT = const CssSectionType(1);
  static const CssSectionType COLOR_DEFINITION = const CssSectionType(2);
  static const CssSectionType BINDING_SET = const CssSectionType(3);
  static const CssSectionType RULESET = const CssSectionType(4);
  static const CssSectionType SELECTOR = const CssSectionType(5);
  static const CssSectionType DECLARATION = const CssSectionType(6);
  static const CssSectionType VALUE = const CssSectionType(7);
  static const CssSectionType KEYFRAMES = const CssSectionType(8);
  String toString() {
    switch(index) {
      case 0: return 'CssSectionType.DOCUMENT';
      case 1: return 'CssSectionType.IMPORT';
      case 2: return 'CssSectionType.COLOR_DEFINITION';
      case 3: return 'CssSectionType.BINDING_SET';
      case 4: return 'CssSectionType.RULESET';
      case 5: return 'CssSectionType.SELECTOR';
      case 6: return 'CssSectionType.DECLARATION';
      case 7: return 'CssSectionType.VALUE';
      case 8: return 'CssSectionType.KEYFRAMES';
      default: return 'new CssSectionType($index)';
    }
  }
}

class DebugFlag extends GEnumBase {
  const DebugFlag(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'DebugFlag');

  static const DebugFlag NULL = const DebugFlag(0);
  static const DebugFlag MISC = const DebugFlag(1);
  bool get misc => (index & 1) == 1;
  static const DebugFlag PLUGSOCKET = const DebugFlag(2);
  bool get plugsocket => (index & 2) == 2;
  static const DebugFlag TEXT = const DebugFlag(4);
  bool get text => (index & 4) == 4;
  static const DebugFlag TREE = const DebugFlag(8);
  bool get tree => (index & 8) == 8;
  static const DebugFlag UPDATES = const DebugFlag(16);
  bool get updates => (index & 16) == 16;
  static const DebugFlag KEYBINDINGS = const DebugFlag(32);
  bool get keybindings => (index & 32) == 32;
  static const DebugFlag MULTIHEAD = const DebugFlag(64);
  bool get multihead => (index & 64) == 64;
  static const DebugFlag MODULES = const DebugFlag(128);
  bool get modules => (index & 128) == 128;
  static const DebugFlag GEOMETRY = const DebugFlag(256);
  bool get geometry => (index & 256) == 256;
  static const DebugFlag ICONTHEME = const DebugFlag(512);
  bool get icontheme => (index & 512) == 512;
  static const DebugFlag PRINTING = const DebugFlag(1024);
  bool get printing => (index & 1024) == 1024;
  static const DebugFlag BUILDER = const DebugFlag(2048);
  bool get builder => (index & 2048) == 2048;
  static const DebugFlag SIZE_REQUEST = const DebugFlag(4096);
  bool get sizeRequest => (index & 4096) == 4096;
  static const DebugFlag NO_CSS_CACHE = const DebugFlag(8192);
  bool get noCssCache => (index & 8192) == 8192;
  static const DebugFlag BASELINES = const DebugFlag(16384);
  bool get baselines => (index & 16384) == 16384;
  static const DebugFlag PIXEL_CACHE = const DebugFlag(32768);
  bool get pixelCache => (index & 32768) == 32768;
  static const DebugFlag NO_PIXEL_CACHE = const DebugFlag(65536);
  bool get noPixelCache => (index & 65536) == 65536;
  static const DebugFlag INTERACTIVE = const DebugFlag(131072);
  bool get interactive => (index & 131072) == 131072;
  static const DebugFlag TOUCHSCREEN = const DebugFlag(262144);
  bool get touchscreen => (index & 262144) == 262144;
  static const DebugFlag ACTIONS = const DebugFlag(524288);
  bool get actions => (index & 524288) == 524288;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'DebugFlag.MISC';
      case 2: return 'DebugFlag.PLUGSOCKET';
      case 4: return 'DebugFlag.TEXT';
      case 8: return 'DebugFlag.TREE';
      case 16: return 'DebugFlag.UPDATES';
      case 32: return 'DebugFlag.KEYBINDINGS';
      case 64: return 'DebugFlag.MULTIHEAD';
      case 128: return 'DebugFlag.MODULES';
      default: return 'new DebugFlag($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'DebugFlag.NULL';
    }
    List codes = [];
    for (var i=1; i <= 524288; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  DebugFlag operator|(DebugFlag other) =>
    new DebugFlag(index | other.index);
  DebugFlag operator&(DebugFlag other) =>
    new DebugFlag(index & other.index);
}

class DeleteType extends GEnumBase {
  const DeleteType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'DeleteType');

  static const DeleteType CHARS = const DeleteType(0);
  static const DeleteType WORD_ENDS = const DeleteType(1);
  static const DeleteType WORDS = const DeleteType(2);
  static const DeleteType DISPLAY_LINES = const DeleteType(3);
  static const DeleteType DISPLAY_LINE_ENDS = const DeleteType(4);
  static const DeleteType PARAGRAPH_ENDS = const DeleteType(5);
  static const DeleteType PARAGRAPHS = const DeleteType(6);
  static const DeleteType WHITESPACE = const DeleteType(7);
  String toString() {
    switch(index) {
      case 0: return 'DeleteType.CHARS';
      case 1: return 'DeleteType.WORD_ENDS';
      case 2: return 'DeleteType.WORDS';
      case 3: return 'DeleteType.DISPLAY_LINES';
      case 4: return 'DeleteType.DISPLAY_LINE_ENDS';
      case 5: return 'DeleteType.PARAGRAPH_ENDS';
      case 6: return 'DeleteType.PARAGRAPHS';
      case 7: return 'DeleteType.WHITESPACE';
      default: return 'new DeleteType($index)';
    }
  }
}

class DestDefaults extends GEnumBase {
  const DestDefaults(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'DestDefaults');

  static const DestDefaults NULL = const DestDefaults(0);
  static const DestDefaults MOTION = const DestDefaults(1);
  bool get motion => (index & 1) == 1;
  static const DestDefaults HIGHLIGHT = const DestDefaults(2);
  bool get highlight => (index & 2) == 2;
  static const DestDefaults DROP = const DestDefaults(4);
  bool get drop => (index & 4) == 4;
  static const DestDefaults ALL = const DestDefaults(7);
  bool get all => (index & 7) == 7;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'DestDefaults.MOTION';
      case 2: return 'DestDefaults.HIGHLIGHT';
      case 4: return 'DestDefaults.DROP';
      default: return 'new DestDefaults($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'DestDefaults.NULL';
    }
    List codes = [];
    for (var i=1; i <= 4; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  DestDefaults operator|(DestDefaults other) =>
    new DestDefaults(index | other.index);
  DestDefaults operator&(DestDefaults other) =>
    new DestDefaults(index & other.index);
}

class Dialog extends Window with ImplementorIface, Buildable {
  Dialog.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Dialog');

  int get useHeaderBar => _staticInfo.getGPropertyOnReceiver('use-header-bar', this);
  void set useHeaderBar(int value) => _staticInfo.setGPropertyOnReceiver('use-header-bar', this, value);
  static const String USE_HEADER_BAR_PROPERTY = 'use-header-bar';
  factory Dialog() => _staticInfo.callStatic('new', []);
  void addActionWidget(Widget child, int responseId) => _staticInfo.callMethodOnReceiver('add_action_widget', this, [child, responseId]);
  Widget addButton(String buttonText, int responseId) => _staticInfo.callMethodOnReceiver('add_button', this, [buttonText, responseId]);
  Widget getActionArea() => _staticInfo.callMethodOnReceiver('get_action_area', this, []);
  Box getContentArea() => _staticInfo.callMethodOnReceiver('get_content_area', this, []);
  Widget getHeaderBar() => _staticInfo.callMethodOnReceiver('get_header_bar', this, []);
  int getResponseForWidget(Widget widget) => _staticInfo.callMethodOnReceiver('get_response_for_widget', this, [widget]);
  Widget getWidgetForResponse(int responseId) => _staticInfo.callMethodOnReceiver('get_widget_for_response', this, [responseId]);
  void response(int responseId) => _staticInfo.callMethodOnReceiver('response', this, [responseId]);
  int run() => _staticInfo.callMethodOnReceiver('run', this, []);
  void setAlternativeButtonOrderFromArray(List<int> newOrder) => _staticInfo.callMethodOnReceiver('set_alternative_button_order_from_array', this, [newOrder]);
  void setDefaultResponse(int responseId) => _staticInfo.callMethodOnReceiver('set_default_response', this, [responseId]);
  void setResponseSensitive(int responseId, bool setting) => _staticInfo.callMethodOnReceiver('set_response_sensitive', this, [responseId, setting]);
  int _connectToClose(bool after, void func()) => signalConnect('close', func, after);
  Stream get onClose {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClose(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterClose {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClose(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToResponse(bool after, void func(int responseId)) => signalConnect('response', func, after);
  Stream<int> get onResponse {
    int signalId;
    StreamController<int> controller;
    controller = new StreamController<int>(
      onListen: () {
          signalId = _connectToResponse(false, (int responseId) {
              controller.add(responseId);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<int> get afterResponse {
    int signalId;
    StreamController<int> controller;
    controller = new StreamController<int>(
      onListen: () {
          signalId = _connectToResponse(true, (int responseId) {
              controller.add(responseId);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class DialogFlags extends GEnumBase {
  const DialogFlags(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'DialogFlags');

  static const DialogFlags NULL = const DialogFlags(0);
  static const DialogFlags MODAL = const DialogFlags(1);
  bool get modal => (index & 1) == 1;
  static const DialogFlags DESTROY_WITH_PARENT = const DialogFlags(2);
  bool get destroyWithParent => (index & 2) == 2;
  static const DialogFlags USE_HEADER_BAR = const DialogFlags(4);
  bool get useHeaderBar => (index & 4) == 4;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'DialogFlags.MODAL';
      case 2: return 'DialogFlags.DESTROY_WITH_PARENT';
      case 4: return 'DialogFlags.USE_HEADER_BAR';
      default: return 'new DialogFlags($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'DialogFlags.NULL';
    }
    List codes = [];
    for (var i=1; i <= 4; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  DialogFlags operator|(DialogFlags other) =>
    new DialogFlags(index | other.index);
  DialogFlags operator&(DialogFlags other) =>
    new DialogFlags(index & other.index);
}

class DirectionType extends GEnumBase {
  const DirectionType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'DirectionType');

  static const DirectionType TAB_FORWARD = const DirectionType(0);
  static const DirectionType TAB_BACKWARD = const DirectionType(1);
  static const DirectionType UP = const DirectionType(2);
  static const DirectionType DOWN = const DirectionType(3);
  static const DirectionType LEFT = const DirectionType(4);
  static const DirectionType RIGHT = const DirectionType(5);
  String toString() {
    switch(index) {
      case 0: return 'DirectionType.TAB_FORWARD';
      case 1: return 'DirectionType.TAB_BACKWARD';
      case 2: return 'DirectionType.UP';
      case 3: return 'DirectionType.DOWN';
      case 4: return 'DirectionType.LEFT';
      case 5: return 'DirectionType.RIGHT';
      default: return 'new DirectionType($index)';
    }
  }
}

class DragResult extends GEnumBase {
  const DragResult(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'DragResult');

  static const DragResult SUCCESS = const DragResult(0);
  static const DragResult NO_TARGET = const DragResult(1);
  static const DragResult USER_CANCELLED = const DragResult(2);
  static const DragResult TIMEOUT_EXPIRED = const DragResult(3);
  static const DragResult GRAB_BROKEN = const DragResult(4);
  static const DragResult ERROR = const DragResult(5);
  String toString() {
    switch(index) {
      case 0: return 'DragResult.SUCCESS';
      case 1: return 'DragResult.NO_TARGET';
      case 2: return 'DragResult.USER_CANCELLED';
      case 3: return 'DragResult.TIMEOUT_EXPIRED';
      case 4: return 'DragResult.GRAB_BROKEN';
      case 5: return 'DragResult.ERROR';
      default: return 'new DragResult($index)';
    }
  }
}

class DrawingArea extends Widget with ImplementorIface, Buildable {
  DrawingArea.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'DrawingArea');

  factory DrawingArea() => _staticInfo.callStatic('new', []);
}

abstract class Editable extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Editable');



  void copyClipboard() => _staticInfo.callMethodOnReceiver('copy_clipboard', this, []);
  void cutClipboard() => _staticInfo.callMethodOnReceiver('cut_clipboard', this, []);
  void deleteSelection() => _staticInfo.callMethodOnReceiver('delete_selection', this, []);
  void deleteText(int startPos, int endPos) => _staticInfo.callMethodOnReceiver('delete_text', this, [startPos, endPos]);
  String getChars(int startPos, int endPos) => _staticInfo.callMethodOnReceiver('get_chars', this, [startPos, endPos]);
  bool getEditable() => _staticInfo.callMethodOnReceiver('get_editable', this, []);
  int getPosition() => _staticInfo.callMethodOnReceiver('get_position', this, []);
  bool getSelectionBounds() => _staticInfo.callMethodOnReceiver('get_selection_bounds', this, []);
  void insertText(String newText, int newTextLength, int position) => _staticInfo.callMethodOnReceiver('insert_text', this, [newText, newTextLength, position]);
  void pasteClipboard() => _staticInfo.callMethodOnReceiver('paste_clipboard', this, []);
  void selectRegion(int startPos, int endPos) => _staticInfo.callMethodOnReceiver('select_region', this, [startPos, endPos]);
  void setEditable(bool isEditable) => _staticInfo.callMethodOnReceiver('set_editable', this, [isEditable]);
  void setPosition(int position) => _staticInfo.callMethodOnReceiver('set_position', this, [position]);
  int _connectToChanged(bool after, void func()) => signalConnect('changed', func, after);
  Stream get onChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDeleteText(bool after, void func(int startPos, int endPos)) => signalConnect('delete-text', func, after);
  Stream<EditableDeleteTextEvent> get onDeleteText {
    int signalId;
    StreamController<EditableDeleteTextEvent> controller;
    controller = new StreamController<EditableDeleteTextEvent>(
      onListen: () {
          signalId = _connectToDeleteText(false, (int startPos, int endPos) {
              var result = new EditableDeleteTextEvent(startPos, endPos);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EditableDeleteTextEvent> get afterDeleteText {
    int signalId;
    StreamController<EditableDeleteTextEvent> controller;
    controller = new StreamController<EditableDeleteTextEvent>(
      onListen: () {
          signalId = _connectToDeleteText(true, (int startPos, int endPos) {
              var result = new EditableDeleteTextEvent(startPos, endPos);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int connectToInsertText(bool after, int func(String newText, int newTextLength, int position)) => signalConnect('insert-text', func, after);
}

class EditableDeleteTextEvent {
  final int startPos;
  final int endPos;

  EditableDeleteTextEvent(this.startPos, this.endPos);
}

class Entry extends Widget with ImplementorIface, Buildable, CellEditable, Editable {
  Entry.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Entry');

  static const String ACTIVATES_DEFAULT_PROPERTY = 'activates-default';
  static const String ATTRIBUTES_PROPERTY = 'attributes';
  static const String BUFFER_PROPERTY = 'buffer';
  bool get capsLockWarning => _staticInfo.getGPropertyOnReceiver('caps-lock-warning', this);
  void set capsLockWarning(bool value) => _staticInfo.setGPropertyOnReceiver('caps-lock-warning', this, value);
  static const String CAPS_LOCK_WARNING_PROPERTY = 'caps-lock-warning';
  static const String COMPLETION_PROPERTY = 'completion';
  int get cursorPosition => _staticInfo.getGPropertyOnReceiver('cursor-position', this);
  static const String CURSOR_POSITION_PROPERTY = 'cursor-position';
  bool get editable => _staticInfo.getGPropertyOnReceiver('editable', this);
  void set editable(bool value) => _staticInfo.setGPropertyOnReceiver('editable', this, value);
  static const String EDITABLE_PROPERTY = 'editable';
  static const String HAS_FRAME_PROPERTY = 'has-frame';
  String get imModule => _staticInfo.getGPropertyOnReceiver('im-module', this);
  void set imModule(String value) => _staticInfo.setGPropertyOnReceiver('im-module', this, value);
  static const String IM_MODULE_PROPERTY = 'im-module';
  static const String INNER_BORDER_PROPERTY = 'inner-border';
  static const String INPUT_HINTS_PROPERTY = 'input-hints';
  static const String INPUT_PURPOSE_PROPERTY = 'input-purpose';
  static const String INVISIBLE_CHAR_PROPERTY = 'invisible-char';
  bool get invisibleCharSet => _staticInfo.getGPropertyOnReceiver('invisible-char-set', this);
  void set invisibleCharSet(bool value) => _staticInfo.setGPropertyOnReceiver('invisible-char-set', this, value);
  static const String INVISIBLE_CHAR_SET_PROPERTY = 'invisible-char-set';
  static const String MAX_LENGTH_PROPERTY = 'max-length';
  static const String MAX_WIDTH_CHARS_PROPERTY = 'max-width-chars';
  static const String OVERWRITE_MODE_PROPERTY = 'overwrite-mode';
  static const String PLACEHOLDER_TEXT_PROPERTY = 'placeholder-text';
  bool get populateAll => _staticInfo.getGPropertyOnReceiver('populate-all', this);
  void set populateAll(bool value) => _staticInfo.setGPropertyOnReceiver('populate-all', this, value);
  static const String POPULATE_ALL_PROPERTY = 'populate-all';
  bool get primaryIconActivatable => _staticInfo.getGPropertyOnReceiver('primary-icon-activatable', this);
  void set primaryIconActivatable(bool value) => _staticInfo.setGPropertyOnReceiver('primary-icon-activatable', this, value);
  static const String PRIMARY_ICON_ACTIVATABLE_PROPERTY = 'primary-icon-activatable';
  Icon get primaryIconGicon => _staticInfo.getGPropertyOnReceiver('primary-icon-gicon', this);
  void set primaryIconGicon(Icon value) => _staticInfo.setGPropertyOnReceiver('primary-icon-gicon', this, value);
  static const String PRIMARY_ICON_GICON_PROPERTY = 'primary-icon-gicon';
  String get primaryIconName => _staticInfo.getGPropertyOnReceiver('primary-icon-name', this);
  void set primaryIconName(String value) => _staticInfo.setGPropertyOnReceiver('primary-icon-name', this, value);
  static const String PRIMARY_ICON_NAME_PROPERTY = 'primary-icon-name';
  Pixbuf get primaryIconPixbuf => _staticInfo.getGPropertyOnReceiver('primary-icon-pixbuf', this);
  void set primaryIconPixbuf(Pixbuf value) => _staticInfo.setGPropertyOnReceiver('primary-icon-pixbuf', this, value);
  static const String PRIMARY_ICON_PIXBUF_PROPERTY = 'primary-icon-pixbuf';
  bool get primaryIconSensitive => _staticInfo.getGPropertyOnReceiver('primary-icon-sensitive', this);
  void set primaryIconSensitive(bool value) => _staticInfo.setGPropertyOnReceiver('primary-icon-sensitive', this, value);
  static const String PRIMARY_ICON_SENSITIVE_PROPERTY = 'primary-icon-sensitive';
  String get primaryIconStock => _staticInfo.getGPropertyOnReceiver('primary-icon-stock', this);
  void set primaryIconStock(String value) => _staticInfo.setGPropertyOnReceiver('primary-icon-stock', this, value);
  static const String PRIMARY_ICON_STOCK_PROPERTY = 'primary-icon-stock';
  ImageType get primaryIconStorageType => _staticInfo.getGPropertyOnReceiver('primary-icon-storage-type', this);
  static const String PRIMARY_ICON_STORAGE_TYPE_PROPERTY = 'primary-icon-storage-type';
  String get primaryIconTooltipMarkup => _staticInfo.getGPropertyOnReceiver('primary-icon-tooltip-markup', this);
  void set primaryIconTooltipMarkup(String value) => _staticInfo.setGPropertyOnReceiver('primary-icon-tooltip-markup', this, value);
  static const String PRIMARY_ICON_TOOLTIP_MARKUP_PROPERTY = 'primary-icon-tooltip-markup';
  String get primaryIconTooltipText => _staticInfo.getGPropertyOnReceiver('primary-icon-tooltip-text', this);
  void set primaryIconTooltipText(String value) => _staticInfo.setGPropertyOnReceiver('primary-icon-tooltip-text', this, value);
  static const String PRIMARY_ICON_TOOLTIP_TEXT_PROPERTY = 'primary-icon-tooltip-text';
  static const String PROGRESS_FRACTION_PROPERTY = 'progress-fraction';
  static const String PROGRESS_PULSE_STEP_PROPERTY = 'progress-pulse-step';
  int get scrollOffset => _staticInfo.getGPropertyOnReceiver('scroll-offset', this);
  static const String SCROLL_OFFSET_PROPERTY = 'scroll-offset';
  bool get secondaryIconActivatable => _staticInfo.getGPropertyOnReceiver('secondary-icon-activatable', this);
  void set secondaryIconActivatable(bool value) => _staticInfo.setGPropertyOnReceiver('secondary-icon-activatable', this, value);
  static const String SECONDARY_ICON_ACTIVATABLE_PROPERTY = 'secondary-icon-activatable';
  Icon get secondaryIconGicon => _staticInfo.getGPropertyOnReceiver('secondary-icon-gicon', this);
  void set secondaryIconGicon(Icon value) => _staticInfo.setGPropertyOnReceiver('secondary-icon-gicon', this, value);
  static const String SECONDARY_ICON_GICON_PROPERTY = 'secondary-icon-gicon';
  String get secondaryIconName => _staticInfo.getGPropertyOnReceiver('secondary-icon-name', this);
  void set secondaryIconName(String value) => _staticInfo.setGPropertyOnReceiver('secondary-icon-name', this, value);
  static const String SECONDARY_ICON_NAME_PROPERTY = 'secondary-icon-name';
  Pixbuf get secondaryIconPixbuf => _staticInfo.getGPropertyOnReceiver('secondary-icon-pixbuf', this);
  void set secondaryIconPixbuf(Pixbuf value) => _staticInfo.setGPropertyOnReceiver('secondary-icon-pixbuf', this, value);
  static const String SECONDARY_ICON_PIXBUF_PROPERTY = 'secondary-icon-pixbuf';
  bool get secondaryIconSensitive => _staticInfo.getGPropertyOnReceiver('secondary-icon-sensitive', this);
  void set secondaryIconSensitive(bool value) => _staticInfo.setGPropertyOnReceiver('secondary-icon-sensitive', this, value);
  static const String SECONDARY_ICON_SENSITIVE_PROPERTY = 'secondary-icon-sensitive';
  String get secondaryIconStock => _staticInfo.getGPropertyOnReceiver('secondary-icon-stock', this);
  void set secondaryIconStock(String value) => _staticInfo.setGPropertyOnReceiver('secondary-icon-stock', this, value);
  static const String SECONDARY_ICON_STOCK_PROPERTY = 'secondary-icon-stock';
  ImageType get secondaryIconStorageType => _staticInfo.getGPropertyOnReceiver('secondary-icon-storage-type', this);
  static const String SECONDARY_ICON_STORAGE_TYPE_PROPERTY = 'secondary-icon-storage-type';
  String get secondaryIconTooltipMarkup => _staticInfo.getGPropertyOnReceiver('secondary-icon-tooltip-markup', this);
  void set secondaryIconTooltipMarkup(String value) => _staticInfo.setGPropertyOnReceiver('secondary-icon-tooltip-markup', this, value);
  static const String SECONDARY_ICON_TOOLTIP_MARKUP_PROPERTY = 'secondary-icon-tooltip-markup';
  String get secondaryIconTooltipText => _staticInfo.getGPropertyOnReceiver('secondary-icon-tooltip-text', this);
  void set secondaryIconTooltipText(String value) => _staticInfo.setGPropertyOnReceiver('secondary-icon-tooltip-text', this, value);
  static const String SECONDARY_ICON_TOOLTIP_TEXT_PROPERTY = 'secondary-icon-tooltip-text';
  int get selectionBound => _staticInfo.getGPropertyOnReceiver('selection-bound', this);
  static const String SELECTION_BOUND_PROPERTY = 'selection-bound';
  ShadowType get shadowType => _staticInfo.getGPropertyOnReceiver('shadow-type', this);
  void set shadowType(ShadowType value) => _staticInfo.setGPropertyOnReceiver('shadow-type', this, value);
  static const String SHADOW_TYPE_PROPERTY = 'shadow-type';
  static const String TABS_PROPERTY = 'tabs';
  static const String TEXT_PROPERTY = 'text';
  static const String TEXT_LENGTH_PROPERTY = 'text-length';
  bool get truncateMultiline => _staticInfo.getGPropertyOnReceiver('truncate-multiline', this);
  void set truncateMultiline(bool value) => _staticInfo.setGPropertyOnReceiver('truncate-multiline', this, value);
  static const String TRUNCATE_MULTILINE_PROPERTY = 'truncate-multiline';
  static const String VISIBILITY_PROPERTY = 'visibility';
  static const String WIDTH_CHARS_PROPERTY = 'width-chars';
  num get xalign => _staticInfo.getGPropertyOnReceiver('xalign', this);
  void set xalign(num value) => _staticInfo.setGPropertyOnReceiver('xalign', this, value);
  static const String XALIGN_PROPERTY = 'xalign';
  factory Entry() => _staticInfo.callStatic('new', []);
  factory Entry.withBuffer(EntryBuffer buffer) => _staticInfo.callStatic('new_with_buffer', [buffer]);
  bool get activatesDefault => _staticInfo.callMethodOnReceiver('get_activates_default', this, []);
  num getAlignment() => _staticInfo.callMethodOnReceiver('get_alignment', this, []);
  AttrList get attributes => _staticInfo.callMethodOnReceiver('get_attributes', this, []);
  EntryBuffer get buffer => _staticInfo.callMethodOnReceiver('get_buffer', this, []);
  EntryCompletion get completion => _staticInfo.callMethodOnReceiver('get_completion', this, []);
  int getCurrentIconDragSource() => _staticInfo.callMethodOnReceiver('get_current_icon_drag_source', this, []);
  Adjustment getCursorHadjustment() => _staticInfo.callMethodOnReceiver('get_cursor_hadjustment', this, []);
  bool get hasFrame => _staticInfo.callMethodOnReceiver('get_has_frame', this, []);
  bool getIconActivatable(EntryIconPosition iconPos) => _staticInfo.callMethodOnReceiver('get_icon_activatable', this, [iconPos]);
  void getIconArea(EntryIconPosition iconPos) => _staticInfo.callMethodOnReceiver('get_icon_area', this, [iconPos]);
  int getIconAtPos(int x, int y) => _staticInfo.callMethodOnReceiver('get_icon_at_pos', this, [x, y]);
  Icon getIconGicon(EntryIconPosition iconPos) => _staticInfo.callMethodOnReceiver('get_icon_gicon', this, [iconPos]);
  String getIconName(EntryIconPosition iconPos) => _staticInfo.callMethodOnReceiver('get_icon_name', this, [iconPos]);
  Pixbuf getIconPixbuf(EntryIconPosition iconPos) => _staticInfo.callMethodOnReceiver('get_icon_pixbuf', this, [iconPos]);
  bool getIconSensitive(EntryIconPosition iconPos) => _staticInfo.callMethodOnReceiver('get_icon_sensitive', this, [iconPos]);
  String getIconStock(EntryIconPosition iconPos) => _staticInfo.callMethodOnReceiver('get_icon_stock', this, [iconPos]);
  ImageType getIconStorageType(EntryIconPosition iconPos) => _staticInfo.callMethodOnReceiver('get_icon_storage_type', this, [iconPos]);
  String getIconTooltipMarkup(EntryIconPosition iconPos) => _staticInfo.callMethodOnReceiver('get_icon_tooltip_markup', this, [iconPos]);
  String getIconTooltipText(EntryIconPosition iconPos) => _staticInfo.callMethodOnReceiver('get_icon_tooltip_text', this, [iconPos]);
  Border get innerBorder => _staticInfo.callMethodOnReceiver('get_inner_border', this, []);
  InputHints get inputHints => _staticInfo.callMethodOnReceiver('get_input_hints', this, []);
  InputPurpose get inputPurpose => _staticInfo.callMethodOnReceiver('get_input_purpose', this, []);
  int get invisibleChar => _staticInfo.callMethodOnReceiver('get_invisible_char', this, []);
  pango.Layout getLayout() => _staticInfo.callMethodOnReceiver('get_layout', this, []);
  void getLayoutOffsets() => _staticInfo.callMethodOnReceiver('get_layout_offsets', this, []);
  int get maxLength => _staticInfo.callMethodOnReceiver('get_max_length', this, []);
  int get maxWidthChars => _staticInfo.callMethodOnReceiver('get_max_width_chars', this, []);
  bool get overwriteMode => _staticInfo.callMethodOnReceiver('get_overwrite_mode', this, []);
  String get placeholderText => _staticInfo.callMethodOnReceiver('get_placeholder_text', this, []);
  num get progressFraction => _staticInfo.callMethodOnReceiver('get_progress_fraction', this, []);
  num get progressPulseStep => _staticInfo.callMethodOnReceiver('get_progress_pulse_step', this, []);
  TabArray get tabs => _staticInfo.callMethodOnReceiver('get_tabs', this, []);
  String get text => _staticInfo.callMethodOnReceiver('get_text', this, []);
  void getTextArea() => _staticInfo.callMethodOnReceiver('get_text_area', this, []);
  int get textLength => _staticInfo.callMethodOnReceiver('get_text_length', this, []);
  bool get visibility => _staticInfo.callMethodOnReceiver('get_visibility', this, []);
  int get widthChars => _staticInfo.callMethodOnReceiver('get_width_chars', this, []);
  void grabFocusWithoutSelecting() => _staticInfo.callMethodOnReceiver('grab_focus_without_selecting', this, []);
  bool imContextFilterKeypress(EventKey event) => _staticInfo.callMethodOnReceiver('im_context_filter_keypress', this, [event]);
  int layoutIndexToTextIndex(int layoutIndex) => _staticInfo.callMethodOnReceiver('layout_index_to_text_index', this, [layoutIndex]);
  void progressPulse() => _staticInfo.callMethodOnReceiver('progress_pulse', this, []);
  void resetImContext() => _staticInfo.callMethodOnReceiver('reset_im_context', this, []);
  void set activatesDefault(bool setting) => _staticInfo.callMethodOnReceiver('set_activates_default', this, [setting]);
  void setAlignment(num xalign) => _staticInfo.callMethodOnReceiver('set_alignment', this, [xalign]);
  void set attributes(AttrList attrs) => _staticInfo.callMethodOnReceiver('set_attributes', this, [attrs]);
  void set buffer(EntryBuffer buffer) => _staticInfo.callMethodOnReceiver('set_buffer', this, [buffer]);
  void set completion(EntryCompletion completion) => _staticInfo.callMethodOnReceiver('set_completion', this, [completion]);
  void setCursorHadjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_cursor_hadjustment', this, [adjustment]);
  void set hasFrame(bool setting) => _staticInfo.callMethodOnReceiver('set_has_frame', this, [setting]);
  void setIconActivatable(EntryIconPosition iconPos, bool activatable) => _staticInfo.callMethodOnReceiver('set_icon_activatable', this, [iconPos, activatable]);
  void setIconDragSource(EntryIconPosition iconPos, TargetList targetList, DragAction actions) => _staticInfo.callMethodOnReceiver('set_icon_drag_source', this, [iconPos, targetList, actions]);
  void setIconFromGicon(EntryIconPosition iconPos, Icon icon) => _staticInfo.callMethodOnReceiver('set_icon_from_gicon', this, [iconPos, icon]);
  void setIconFromIconName(EntryIconPosition iconPos, String iconName) => _staticInfo.callMethodOnReceiver('set_icon_from_icon_name', this, [iconPos, iconName]);
  void setIconFromPixbuf(EntryIconPosition iconPos, Pixbuf pixbuf) => _staticInfo.callMethodOnReceiver('set_icon_from_pixbuf', this, [iconPos, pixbuf]);
  void setIconFromStock(EntryIconPosition iconPos, String stockId) => _staticInfo.callMethodOnReceiver('set_icon_from_stock', this, [iconPos, stockId]);
  void setIconSensitive(EntryIconPosition iconPos, bool sensitive) => _staticInfo.callMethodOnReceiver('set_icon_sensitive', this, [iconPos, sensitive]);
  void setIconTooltipMarkup(EntryIconPosition iconPos, String tooltip) => _staticInfo.callMethodOnReceiver('set_icon_tooltip_markup', this, [iconPos, tooltip]);
  void setIconTooltipText(EntryIconPosition iconPos, String tooltip) => _staticInfo.callMethodOnReceiver('set_icon_tooltip_text', this, [iconPos, tooltip]);
  void set innerBorder(Border border) => _staticInfo.callMethodOnReceiver('set_inner_border', this, [border]);
  void set inputHints(InputHints hints) => _staticInfo.callMethodOnReceiver('set_input_hints', this, [hints]);
  void set inputPurpose(InputPurpose purpose) => _staticInfo.callMethodOnReceiver('set_input_purpose', this, [purpose]);
  void set invisibleChar(int ch) => _staticInfo.callMethodOnReceiver('set_invisible_char', this, [ch]);
  void set maxLength(int max) => _staticInfo.callMethodOnReceiver('set_max_length', this, [max]);
  void set maxWidthChars(int nChars) => _staticInfo.callMethodOnReceiver('set_max_width_chars', this, [nChars]);
  void set overwriteMode(bool overwrite) => _staticInfo.callMethodOnReceiver('set_overwrite_mode', this, [overwrite]);
  void set placeholderText(String text) => _staticInfo.callMethodOnReceiver('set_placeholder_text', this, [text]);
  void set progressFraction(num fraction) => _staticInfo.callMethodOnReceiver('set_progress_fraction', this, [fraction]);
  void set progressPulseStep(num fraction) => _staticInfo.callMethodOnReceiver('set_progress_pulse_step', this, [fraction]);
  void set tabs(TabArray tabs) => _staticInfo.callMethodOnReceiver('set_tabs', this, [tabs]);
  void set text(String text) => _staticInfo.callMethodOnReceiver('set_text', this, [text]);
  void set visibility(bool visible) => _staticInfo.callMethodOnReceiver('set_visibility', this, [visible]);
  void set widthChars(int nChars) => _staticInfo.callMethodOnReceiver('set_width_chars', this, [nChars]);
  int textIndexToLayoutIndex(int textIndex) => _staticInfo.callMethodOnReceiver('text_index_to_layout_index', this, [textIndex]);
  void unsetInvisibleChar() => _staticInfo.callMethodOnReceiver('unset_invisible_char', this, []);
  int _connectToActivate(bool after, void func()) => signalConnect('activate', func, after);
  Stream get onActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToBackspace(bool after, void func()) => signalConnect('backspace', func, after);
  Stream get onBackspace {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToBackspace(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterBackspace {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToBackspace(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCopyClipboard(bool after, void func()) => signalConnect('copy-clipboard', func, after);
  Stream get onCopyClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCopyClipboard(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterCopyClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCopyClipboard(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCutClipboard(bool after, void func()) => signalConnect('cut-clipboard', func, after);
  Stream get onCutClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCutClipboard(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterCutClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCutClipboard(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDeleteFromCursor(bool after, void func(DeleteType type, int count)) => signalConnect('delete-from-cursor', func, after);
  Stream<EntryDeleteFromCursorEvent> get onDeleteFromCursor {
    int signalId;
    StreamController<EntryDeleteFromCursorEvent> controller;
    controller = new StreamController<EntryDeleteFromCursorEvent>(
      onListen: () {
          signalId = _connectToDeleteFromCursor(false, (DeleteType type, int count) {
              var result = new EntryDeleteFromCursorEvent(type, count);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EntryDeleteFromCursorEvent> get afterDeleteFromCursor {
    int signalId;
    StreamController<EntryDeleteFromCursorEvent> controller;
    controller = new StreamController<EntryDeleteFromCursorEvent>(
      onListen: () {
          signalId = _connectToDeleteFromCursor(true, (DeleteType type, int count) {
              var result = new EntryDeleteFromCursorEvent(type, count);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToIconPress(bool after, void func(EntryIconPosition iconPos, EventButton event)) => signalConnect('icon-press', func, after);
  Stream<EntryIconPressEvent> get onIconPress {
    int signalId;
    StreamController<EntryIconPressEvent> controller;
    controller = new StreamController<EntryIconPressEvent>(
      onListen: () {
          signalId = _connectToIconPress(false, (EntryIconPosition iconPos, EventButton event) {
              var result = new EntryIconPressEvent(iconPos, event);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EntryIconPressEvent> get afterIconPress {
    int signalId;
    StreamController<EntryIconPressEvent> controller;
    controller = new StreamController<EntryIconPressEvent>(
      onListen: () {
          signalId = _connectToIconPress(true, (EntryIconPosition iconPos, EventButton event) {
              var result = new EntryIconPressEvent(iconPos, event);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToIconRelease(bool after, void func(EntryIconPosition iconPos, EventButton event)) => signalConnect('icon-release', func, after);
  Stream<EntryIconReleaseEvent> get onIconRelease {
    int signalId;
    StreamController<EntryIconReleaseEvent> controller;
    controller = new StreamController<EntryIconReleaseEvent>(
      onListen: () {
          signalId = _connectToIconRelease(false, (EntryIconPosition iconPos, EventButton event) {
              var result = new EntryIconReleaseEvent(iconPos, event);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EntryIconReleaseEvent> get afterIconRelease {
    int signalId;
    StreamController<EntryIconReleaseEvent> controller;
    controller = new StreamController<EntryIconReleaseEvent>(
      onListen: () {
          signalId = _connectToIconRelease(true, (EntryIconPosition iconPos, EventButton event) {
              var result = new EntryIconReleaseEvent(iconPos, event);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToInsertAtCursor(bool after, void func(String string)) => signalConnect('insert-at-cursor', func, after);
  Stream<String> get onInsertAtCursor {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToInsertAtCursor(false, (String string) {
              controller.add(string);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<String> get afterInsertAtCursor {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToInsertAtCursor(true, (String string) {
              controller.add(string);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveCursor(bool after, void func(MovementStep step, int count, bool extendSelection)) => signalConnect('move-cursor', func, after);
  Stream<EntryMoveCursorEvent> get onMoveCursor {
    int signalId;
    StreamController<EntryMoveCursorEvent> controller;
    controller = new StreamController<EntryMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(false, (MovementStep step, int count, bool extendSelection) {
              var result = new EntryMoveCursorEvent(step, count, extendSelection);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EntryMoveCursorEvent> get afterMoveCursor {
    int signalId;
    StreamController<EntryMoveCursorEvent> controller;
    controller = new StreamController<EntryMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(true, (MovementStep step, int count, bool extendSelection) {
              var result = new EntryMoveCursorEvent(step, count, extendSelection);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPasteClipboard(bool after, void func()) => signalConnect('paste-clipboard', func, after);
  Stream get onPasteClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPasteClipboard(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPasteClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPasteClipboard(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPopulatePopup(bool after, void func(Widget popup)) => signalConnect('populate-popup', func, after);
  Stream<Widget> get onPopulatePopup {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToPopulatePopup(false, (Widget popup) {
              controller.add(popup);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Widget> get afterPopulatePopup {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToPopulatePopup(true, (Widget popup) {
              controller.add(popup);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPreeditChanged(bool after, void func(String preedit)) => signalConnect('preedit-changed', func, after);
  Stream<String> get onPreeditChanged {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToPreeditChanged(false, (String preedit) {
              controller.add(preedit);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<String> get afterPreeditChanged {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToPreeditChanged(true, (String preedit) {
              controller.add(preedit);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToToggleOverwrite(bool after, void func()) => signalConnect('toggle-overwrite', func, after);
  Stream get onToggleOverwrite {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggleOverwrite(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterToggleOverwrite {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggleOverwrite(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class EntryDeleteFromCursorEvent {
  final DeleteType type;
  final int count;

  EntryDeleteFromCursorEvent(this.type, this.count);
}

class EntryIconPressEvent {
  final EntryIconPosition iconPos;
  final EventButton event;

  EntryIconPressEvent(this.iconPos, this.event);
}

class EntryIconReleaseEvent {
  final EntryIconPosition iconPos;
  final EventButton event;

  EntryIconReleaseEvent(this.iconPos, this.event);
}

class EntryMoveCursorEvent {
  final MovementStep step;
  final int count;
  final bool extendSelection;

  EntryMoveCursorEvent(this.step, this.count, this.extendSelection);
}

class EntryAccessible extends WidgetAccessible with atk.Action, Component, EditableText, Text {
  EntryAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'EntryAccessible');

}

class EntryBuffer extends GObjectObject {
  EntryBuffer.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'EntryBuffer');

  static const String LENGTH_PROPERTY = 'length';
  static const String MAX_LENGTH_PROPERTY = 'max-length';
  static const String TEXT_PROPERTY = 'text';
  factory EntryBuffer(String initialChars, int nInitialChars) => _staticInfo.callStatic('new', [initialChars, nInitialChars]);
  int deleteText(int position, int nChars) => _staticInfo.callMethodOnReceiver('delete_text', this, [position, nChars]);
  void emitDeletedText(int position, int nChars) => _staticInfo.callMethodOnReceiver('emit_deleted_text', this, [position, nChars]);
  void emitInsertedText(int position, String chars, int nChars) => _staticInfo.callMethodOnReceiver('emit_inserted_text', this, [position, chars, nChars]);
  int getBytes() => _staticInfo.callMethodOnReceiver('get_bytes', this, []);
  int get length => _staticInfo.callMethodOnReceiver('get_length', this, []);
  int get maxLength => _staticInfo.callMethodOnReceiver('get_max_length', this, []);
  String get text => _staticInfo.callMethodOnReceiver('get_text', this, []);
  int insertText(int position, String chars, int nChars) => _staticInfo.callMethodOnReceiver('insert_text', this, [position, chars, nChars]);
  void set maxLength(int maxLength) => _staticInfo.callMethodOnReceiver('set_max_length', this, [maxLength]);
  void setText(String chars, int nChars) => _staticInfo.callMethodOnReceiver('set_text', this, [chars, nChars]);
  int _connectToDeletedText(bool after, void func(int position, int nChars)) => signalConnect('deleted-text', func, after);
  Stream<EntryBufferDeletedTextEvent> get onDeletedText {
    int signalId;
    StreamController<EntryBufferDeletedTextEvent> controller;
    controller = new StreamController<EntryBufferDeletedTextEvent>(
      onListen: () {
          signalId = _connectToDeletedText(false, (int position, int nChars) {
              var result = new EntryBufferDeletedTextEvent(position, nChars);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EntryBufferDeletedTextEvent> get afterDeletedText {
    int signalId;
    StreamController<EntryBufferDeletedTextEvent> controller;
    controller = new StreamController<EntryBufferDeletedTextEvent>(
      onListen: () {
          signalId = _connectToDeletedText(true, (int position, int nChars) {
              var result = new EntryBufferDeletedTextEvent(position, nChars);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToInsertedText(bool after, void func(int position, String chars, int nChars)) => signalConnect('inserted-text', func, after);
  Stream<EntryBufferInsertedTextEvent> get onInsertedText {
    int signalId;
    StreamController<EntryBufferInsertedTextEvent> controller;
    controller = new StreamController<EntryBufferInsertedTextEvent>(
      onListen: () {
          signalId = _connectToInsertedText(false, (int position, String chars, int nChars) {
              var result = new EntryBufferInsertedTextEvent(position, chars, nChars);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EntryBufferInsertedTextEvent> get afterInsertedText {
    int signalId;
    StreamController<EntryBufferInsertedTextEvent> controller;
    controller = new StreamController<EntryBufferInsertedTextEvent>(
      onListen: () {
          signalId = _connectToInsertedText(true, (int position, String chars, int nChars) {
              var result = new EntryBufferInsertedTextEvent(position, chars, nChars);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class EntryBufferDeletedTextEvent {
  final int position;
  final int nChars;

  EntryBufferDeletedTextEvent(this.position, this.nChars);
}

class EntryBufferInsertedTextEvent {
  final int position;
  final String chars;
  final int nChars;

  EntryBufferInsertedTextEvent(this.position, this.chars, this.nChars);
}

class EntryCompletion extends GObjectObject with Buildable, CellLayout {
  EntryCompletion.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'EntryCompletion');

  CellArea get cellArea => _staticInfo.getGPropertyOnReceiver('cell-area', this);
  void set cellArea(CellArea value) => _staticInfo.setGPropertyOnReceiver('cell-area', this, value);
  static const String CELL_AREA_PROPERTY = 'cell-area';
  static const String INLINE_COMPLETION_PROPERTY = 'inline-completion';
  static const String INLINE_SELECTION_PROPERTY = 'inline-selection';
  static const String MINIMUM_KEY_LENGTH_PROPERTY = 'minimum-key-length';
  static const String MODEL_PROPERTY = 'model';
  static const String POPUP_COMPLETION_PROPERTY = 'popup-completion';
  static const String POPUP_SET_WIDTH_PROPERTY = 'popup-set-width';
  static const String POPUP_SINGLE_MATCH_PROPERTY = 'popup-single-match';
  static const String TEXT_COLUMN_PROPERTY = 'text-column';
  factory EntryCompletion() => _staticInfo.callStatic('new', []);
  factory EntryCompletion.withArea(CellArea area) => _staticInfo.callStatic('new_with_area', [area]);
  void complete() => _staticInfo.callMethodOnReceiver('complete', this, []);
  String computePrefix(String key) => _staticInfo.callMethodOnReceiver('compute_prefix', this, [key]);
  void deleteAction(int index_) => _staticInfo.callMethodOnReceiver('delete_action', this, [index_]);
  String getCompletionPrefix() => _staticInfo.callMethodOnReceiver('get_completion_prefix', this, []);
  Widget getEntry() => _staticInfo.callMethodOnReceiver('get_entry', this, []);
  bool get inlineCompletion => _staticInfo.callMethodOnReceiver('get_inline_completion', this, []);
  bool get inlineSelection => _staticInfo.callMethodOnReceiver('get_inline_selection', this, []);
  int get minimumKeyLength => _staticInfo.callMethodOnReceiver('get_minimum_key_length', this, []);
  TreeModel get model => _staticInfo.callMethodOnReceiver('get_model', this, []);
  bool get popupCompletion => _staticInfo.callMethodOnReceiver('get_popup_completion', this, []);
  bool get popupSetWidth => _staticInfo.callMethodOnReceiver('get_popup_set_width', this, []);
  bool get popupSingleMatch => _staticInfo.callMethodOnReceiver('get_popup_single_match', this, []);
  int get textColumn => _staticInfo.callMethodOnReceiver('get_text_column', this, []);
  void insertActionMarkup(int index_, String markup) => _staticInfo.callMethodOnReceiver('insert_action_markup', this, [index_, markup]);
  void insertActionText(int index_, String text) => _staticInfo.callMethodOnReceiver('insert_action_text', this, [index_, text]);
  void insertPrefix() => _staticInfo.callMethodOnReceiver('insert_prefix', this, []);
  void set inlineCompletion(bool inlineCompletion) => _staticInfo.callMethodOnReceiver('set_inline_completion', this, [inlineCompletion]);
  void set inlineSelection(bool inlineSelection) => _staticInfo.callMethodOnReceiver('set_inline_selection', this, [inlineSelection]);
  void setMatchFunc(EntryCompletionMatchFunc func) => _staticInfo.callMethodOnReceiver('set_match_func', this, [func]);
  void set minimumKeyLength(int length) => _staticInfo.callMethodOnReceiver('set_minimum_key_length', this, [length]);
  void set model(TreeModel model) => _staticInfo.callMethodOnReceiver('set_model', this, [model]);
  void set popupCompletion(bool popupCompletion) => _staticInfo.callMethodOnReceiver('set_popup_completion', this, [popupCompletion]);
  void set popupSetWidth(bool popupSetWidth) => _staticInfo.callMethodOnReceiver('set_popup_set_width', this, [popupSetWidth]);
  void set popupSingleMatch(bool popupSingleMatch) => _staticInfo.callMethodOnReceiver('set_popup_single_match', this, [popupSingleMatch]);
  void set textColumn(int column) => _staticInfo.callMethodOnReceiver('set_text_column', this, [column]);
  int _connectToActionActivated(bool after, void func(int index)) => signalConnect('action-activated', func, after);
  Stream<int> get onActionActivated {
    int signalId;
    StreamController<int> controller;
    controller = new StreamController<int>(
      onListen: () {
          signalId = _connectToActionActivated(false, (int index) {
              controller.add(index);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<int> get afterActionActivated {
    int signalId;
    StreamController<int> controller;
    controller = new StreamController<int>(
      onListen: () {
          signalId = _connectToActionActivated(true, (int index) {
              controller.add(index);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCursorOnMatch(bool after, bool func(TreeModel model, TreeIter iter)) => signalConnect('cursor-on-match', func, after);
  Stream<EntryCompletionCursorOnMatchEvent> get onCursorOnMatch {
    int signalId;
    StreamController<EntryCompletionCursorOnMatchEvent> controller;
    controller = new StreamController<EntryCompletionCursorOnMatchEvent>(
      onListen: () {
          signalId = _connectToCursorOnMatch(false, (TreeModel model, TreeIter iter) {
              var result = new EntryCompletionCursorOnMatchEvent(model, iter);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EntryCompletionCursorOnMatchEvent> get afterCursorOnMatch {
    int signalId;
    StreamController<EntryCompletionCursorOnMatchEvent> controller;
    controller = new StreamController<EntryCompletionCursorOnMatchEvent>(
      onListen: () {
          signalId = _connectToCursorOnMatch(true, (TreeModel model, TreeIter iter) {
              var result = new EntryCompletionCursorOnMatchEvent(model, iter);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToInsertPrefix(bool after, bool func(String prefix)) => signalConnect('insert-prefix', func, after);
  Stream<EntryCompletionInsertPrefixEvent> get onInsertPrefix {
    int signalId;
    StreamController<EntryCompletionInsertPrefixEvent> controller;
    controller = new StreamController<EntryCompletionInsertPrefixEvent>(
      onListen: () {
          signalId = _connectToInsertPrefix(false, (String prefix) {
              var result = new EntryCompletionInsertPrefixEvent(prefix);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EntryCompletionInsertPrefixEvent> get afterInsertPrefix {
    int signalId;
    StreamController<EntryCompletionInsertPrefixEvent> controller;
    controller = new StreamController<EntryCompletionInsertPrefixEvent>(
      onListen: () {
          signalId = _connectToInsertPrefix(true, (String prefix) {
              var result = new EntryCompletionInsertPrefixEvent(prefix);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMatchSelected(bool after, bool func(TreeModel model, TreeIter iter)) => signalConnect('match-selected', func, after);
  Stream<EntryCompletionMatchSelectedEvent> get onMatchSelected {
    int signalId;
    StreamController<EntryCompletionMatchSelectedEvent> controller;
    controller = new StreamController<EntryCompletionMatchSelectedEvent>(
      onListen: () {
          signalId = _connectToMatchSelected(false, (TreeModel model, TreeIter iter) {
              var result = new EntryCompletionMatchSelectedEvent(model, iter);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EntryCompletionMatchSelectedEvent> get afterMatchSelected {
    int signalId;
    StreamController<EntryCompletionMatchSelectedEvent> controller;
    controller = new StreamController<EntryCompletionMatchSelectedEvent>(
      onListen: () {
          signalId = _connectToMatchSelected(true, (TreeModel model, TreeIter iter) {
              var result = new EntryCompletionMatchSelectedEvent(model, iter);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToNoMatches(bool after, void func()) => signalConnect('no-matches', func, after);
  Stream get onNoMatches {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToNoMatches(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterNoMatches {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToNoMatches(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class EntryCompletionCursorOnMatchEvent {
  final TreeModel model;
  final TreeIter iter;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  EntryCompletionCursorOnMatchEvent(this.model, this.iter);
}

class EntryCompletionInsertPrefixEvent {
  final String prefix;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  EntryCompletionInsertPrefixEvent(this.prefix);
}

class EntryCompletionMatchSelectedEvent {
  final TreeModel model;
  final TreeIter iter;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  EntryCompletionMatchSelectedEvent(this.model, this.iter);
}

typedef bool EntryCompletionMatchFunc(EntryCompletion completion, String key, TreeIter iter);
class EntryIconAccessible extends AtkObject with atk.Action, Component {
  EntryIconAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'EntryIconAccessible');

}

class EntryIconPosition extends GEnumBase {
  const EntryIconPosition(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'EntryIconPosition');

  static const EntryIconPosition PRIMARY = const EntryIconPosition(0);
  static const EntryIconPosition SECONDARY = const EntryIconPosition(1);
  String toString() {
    switch(index) {
      case 0: return 'EntryIconPosition.PRIMARY';
      case 1: return 'EntryIconPosition.SECONDARY';
      default: return 'new EntryIconPosition($index)';
    }
  }
}

class EventBox extends Bin with ImplementorIface, Buildable {
  EventBox.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'EventBox');

  static const String ABOVE_CHILD_PROPERTY = 'above-child';
  static const String VISIBLE_WINDOW_PROPERTY = 'visible-window';
  factory EventBox() => _staticInfo.callStatic('new', []);
  bool get aboveChild => _staticInfo.callMethodOnReceiver('get_above_child', this, []);
  bool get visibleWindow => _staticInfo.callMethodOnReceiver('get_visible_window', this, []);
  void set aboveChild(bool aboveChild) => _staticInfo.callMethodOnReceiver('set_above_child', this, [aboveChild]);
  void set visibleWindow(bool visibleWindow) => _staticInfo.callMethodOnReceiver('set_visible_window', this, [visibleWindow]);
}

class EventController extends GObjectObject {
  EventController.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'EventController');

  static const String PROPAGATION_PHASE_PROPERTY = 'propagation-phase';
  void set widget(Widget value) => _staticInfo.setGPropertyOnReceiver('widget', this, value);
  static const String WIDGET_PROPERTY = 'widget';
  PropagationPhase get propagationPhase => _staticInfo.callMethodOnReceiver('get_propagation_phase', this, []);
  Widget get widget_ => _staticInfo.callMethodOnReceiver('get_widget', this, []);
  bool handleEvent(Event event) => _staticInfo.callMethodOnReceiver('handle_event', this, [event]);
  void reset() => _staticInfo.callMethodOnReceiver('reset', this, []);
  void set propagationPhase(PropagationPhase phase) => _staticInfo.callMethodOnReceiver('set_propagation_phase', this, [phase]);
}

class EventSequenceState extends GEnumBase {
  const EventSequenceState(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'EventSequenceState');

  static const EventSequenceState NONE = const EventSequenceState(0);
  static const EventSequenceState CLAIMED = const EventSequenceState(1);
  static const EventSequenceState DENIED = const EventSequenceState(2);
  String toString() {
    switch(index) {
      case 0: return 'EventSequenceState.NONE';
      case 1: return 'EventSequenceState.CLAIMED';
      case 2: return 'EventSequenceState.DENIED';
      default: return 'new EventSequenceState($index)';
    }
  }
}

class Expander extends Bin with ImplementorIface, Buildable {
  Expander.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Expander');

  static const String EXPANDED_PROPERTY = 'expanded';
  static const String LABEL_PROPERTY = 'label';
  static const String LABEL_FILL_PROPERTY = 'label-fill';
  static const String LABEL_WIDGET_PROPERTY = 'label-widget';
  static const String RESIZE_TOPLEVEL_PROPERTY = 'resize-toplevel';
  static const String SPACING_PROPERTY = 'spacing';
  static const String USE_MARKUP_PROPERTY = 'use-markup';
  static const String USE_UNDERLINE_PROPERTY = 'use-underline';
  factory Expander(String label) => _staticInfo.callStatic('new', [label]);
  factory Expander.withMnemonic(String label) => _staticInfo.callStatic('new_with_mnemonic', [label]);
  bool get expanded => _staticInfo.callMethodOnReceiver('get_expanded', this, []);
  String get label => _staticInfo.callMethodOnReceiver('get_label', this, []);
  bool get labelFill => _staticInfo.callMethodOnReceiver('get_label_fill', this, []);
  Widget get labelWidget => _staticInfo.callMethodOnReceiver('get_label_widget', this, []);
  bool get resizeToplevel => _staticInfo.callMethodOnReceiver('get_resize_toplevel', this, []);
  int get spacing => _staticInfo.callMethodOnReceiver('get_spacing', this, []);
  bool get useMarkup => _staticInfo.callMethodOnReceiver('get_use_markup', this, []);
  bool get useUnderline => _staticInfo.callMethodOnReceiver('get_use_underline', this, []);
  void set expanded(bool expanded) => _staticInfo.callMethodOnReceiver('set_expanded', this, [expanded]);
  void set label(String label) => _staticInfo.callMethodOnReceiver('set_label', this, [label]);
  void set labelFill(bool labelFill) => _staticInfo.callMethodOnReceiver('set_label_fill', this, [labelFill]);
  void set labelWidget(Widget labelWidget) => _staticInfo.callMethodOnReceiver('set_label_widget', this, [labelWidget]);
  void set resizeToplevel(bool resizeToplevel) => _staticInfo.callMethodOnReceiver('set_resize_toplevel', this, [resizeToplevel]);
  void set spacing(int spacing) => _staticInfo.callMethodOnReceiver('set_spacing', this, [spacing]);
  void set useMarkup(bool useMarkup) => _staticInfo.callMethodOnReceiver('set_use_markup', this, [useMarkup]);
  void set useUnderline(bool useUnderline) => _staticInfo.callMethodOnReceiver('set_use_underline', this, [useUnderline]);
  int _connectToActivate(bool after, void func()) => signalConnect('activate', func, after);
  Stream get onActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ExpanderAccessible extends ContainerAccessible with atk.Action, Component {
  ExpanderAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ExpanderAccessible');

}

class ExpanderStyle extends GEnumBase {
  const ExpanderStyle(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ExpanderStyle');

  static const ExpanderStyle COLLAPSED = const ExpanderStyle(0);
  static const ExpanderStyle SEMI_COLLAPSED = const ExpanderStyle(1);
  static const ExpanderStyle SEMI_EXPANDED = const ExpanderStyle(2);
  static const ExpanderStyle EXPANDED = const ExpanderStyle(3);
  String toString() {
    switch(index) {
      case 0: return 'ExpanderStyle.COLLAPSED';
      case 1: return 'ExpanderStyle.SEMI_COLLAPSED';
      case 2: return 'ExpanderStyle.SEMI_EXPANDED';
      case 3: return 'ExpanderStyle.EXPANDED';
      default: return 'new ExpanderStyle($index)';
    }
  }
}

abstract class FileChooser extends GObjectBase implements Widget {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FileChooser');



  static const String ACTION_PROPERTY = 'action';
  static const String CREATE_FOLDERS_PROPERTY = 'create-folders';
  static const String DO_OVERWRITE_CONFIRMATION_PROPERTY = 'do-overwrite-confirmation';
  static const String EXTRA_WIDGET_PROPERTY = 'extra-widget';
  static const String FILTER_PROPERTY = 'filter';
  static const String LOCAL_ONLY_PROPERTY = 'local-only';
  static const String PREVIEW_WIDGET_PROPERTY = 'preview-widget';
  static const String PREVIEW_WIDGET_ACTIVE_PROPERTY = 'preview-widget-active';
  static const String SELECT_MULTIPLE_PROPERTY = 'select-multiple';
  static const String SHOW_HIDDEN_PROPERTY = 'show-hidden';
  static const String USE_PREVIEW_LABEL_PROPERTY = 'use-preview-label';
  void addFilter(FileFilter filter) => _staticInfo.callMethodOnReceiver('add_filter', this, [filter]);
  bool addShortcutFolder(String folder) => _staticInfo.callMethodOnReceiver('add_shortcut_folder', this, [folder]);
  bool addShortcutFolderUri(String uri) => _staticInfo.callMethodOnReceiver('add_shortcut_folder_uri', this, [uri]);
  FileChooserAction get action => _staticInfo.callMethodOnReceiver('get_action', this, []);
  bool get createFolders => _staticInfo.callMethodOnReceiver('get_create_folders', this, []);
  String getCurrentFolder() => _staticInfo.callMethodOnReceiver('get_current_folder', this, []);
  File getCurrentFolderFile() => _staticInfo.callMethodOnReceiver('get_current_folder_file', this, []);
  String getCurrentFolderUri() => _staticInfo.callMethodOnReceiver('get_current_folder_uri', this, []);
  String getCurrentName() => _staticInfo.callMethodOnReceiver('get_current_name', this, []);
  bool get doOverwriteConfirmation => _staticInfo.callMethodOnReceiver('get_do_overwrite_confirmation', this, []);
  Widget get extraWidget => _staticInfo.callMethodOnReceiver('get_extra_widget', this, []);
  File getFile() => _staticInfo.callMethodOnReceiver('get_file', this, []);
  String getFilename() => _staticInfo.callMethodOnReceiver('get_filename', this, []);
  SList /* this will fail */ getFilenames() => _staticInfo.callMethodOnReceiver('get_filenames', this, []);
  SList /* this will fail */ getFiles() => _staticInfo.callMethodOnReceiver('get_files', this, []);
  FileFilter get filter => _staticInfo.callMethodOnReceiver('get_filter', this, []);
  bool get localOnly => _staticInfo.callMethodOnReceiver('get_local_only', this, []);
  File getPreviewFile() => _staticInfo.callMethodOnReceiver('get_preview_file', this, []);
  String getPreviewFilename() => _staticInfo.callMethodOnReceiver('get_preview_filename', this, []);
  String getPreviewUri() => _staticInfo.callMethodOnReceiver('get_preview_uri', this, []);
  Widget get previewWidget => _staticInfo.callMethodOnReceiver('get_preview_widget', this, []);
  bool get previewWidgetActive => _staticInfo.callMethodOnReceiver('get_preview_widget_active', this, []);
  bool get selectMultiple => _staticInfo.callMethodOnReceiver('get_select_multiple', this, []);
  bool get showHidden => _staticInfo.callMethodOnReceiver('get_show_hidden', this, []);
  String getUri() => _staticInfo.callMethodOnReceiver('get_uri', this, []);
  SList /* this will fail */ getUris() => _staticInfo.callMethodOnReceiver('get_uris', this, []);
  bool get usePreviewLabel => _staticInfo.callMethodOnReceiver('get_use_preview_label', this, []);
  SList /* this will fail */ listFilters() => _staticInfo.callMethodOnReceiver('list_filters', this, []);
  SList /* this will fail */ listShortcutFolderUris() => _staticInfo.callMethodOnReceiver('list_shortcut_folder_uris', this, []);
  SList /* this will fail */ listShortcutFolders() => _staticInfo.callMethodOnReceiver('list_shortcut_folders', this, []);
  void removeFilter(FileFilter filter) => _staticInfo.callMethodOnReceiver('remove_filter', this, [filter]);
  bool removeShortcutFolder(String folder) => _staticInfo.callMethodOnReceiver('remove_shortcut_folder', this, [folder]);
  bool removeShortcutFolderUri(String uri) => _staticInfo.callMethodOnReceiver('remove_shortcut_folder_uri', this, [uri]);
  void selectAll() => _staticInfo.callMethodOnReceiver('select_all', this, []);
  bool selectFile(File file) => _staticInfo.callMethodOnReceiver('select_file', this, [file]);
  bool selectFilename(String filename) => _staticInfo.callMethodOnReceiver('select_filename', this, [filename]);
  bool selectUri(String uri) => _staticInfo.callMethodOnReceiver('select_uri', this, [uri]);
  void set action(FileChooserAction action) => _staticInfo.callMethodOnReceiver('set_action', this, [action]);
  void set createFolders(bool createFolders) => _staticInfo.callMethodOnReceiver('set_create_folders', this, [createFolders]);
  bool setCurrentFolder(String filename) => _staticInfo.callMethodOnReceiver('set_current_folder', this, [filename]);
  bool setCurrentFolderFile(File file) => _staticInfo.callMethodOnReceiver('set_current_folder_file', this, [file]);
  bool setCurrentFolderUri(String uri) => _staticInfo.callMethodOnReceiver('set_current_folder_uri', this, [uri]);
  void setCurrentName(String name) => _staticInfo.callMethodOnReceiver('set_current_name', this, [name]);
  void set doOverwriteConfirmation(bool doOverwriteConfirmation) => _staticInfo.callMethodOnReceiver('set_do_overwrite_confirmation', this, [doOverwriteConfirmation]);
  void set extraWidget(Widget extraWidget) => _staticInfo.callMethodOnReceiver('set_extra_widget', this, [extraWidget]);
  bool setFile(File file) => _staticInfo.callMethodOnReceiver('set_file', this, [file]);
  bool setFilename(String filename) => _staticInfo.callMethodOnReceiver('set_filename', this, [filename]);
  void set filter(FileFilter filter) => _staticInfo.callMethodOnReceiver('set_filter', this, [filter]);
  void set localOnly(bool localOnly) => _staticInfo.callMethodOnReceiver('set_local_only', this, [localOnly]);
  void set previewWidget(Widget previewWidget) => _staticInfo.callMethodOnReceiver('set_preview_widget', this, [previewWidget]);
  void set previewWidgetActive(bool active) => _staticInfo.callMethodOnReceiver('set_preview_widget_active', this, [active]);
  void set selectMultiple(bool selectMultiple) => _staticInfo.callMethodOnReceiver('set_select_multiple', this, [selectMultiple]);
  void set showHidden(bool showHidden) => _staticInfo.callMethodOnReceiver('set_show_hidden', this, [showHidden]);
  bool setUri(String uri) => _staticInfo.callMethodOnReceiver('set_uri', this, [uri]);
  void set usePreviewLabel(bool useLabel) => _staticInfo.callMethodOnReceiver('set_use_preview_label', this, [useLabel]);
  void unselectAll() => _staticInfo.callMethodOnReceiver('unselect_all', this, []);
  void unselectFile(File file) => _staticInfo.callMethodOnReceiver('unselect_file', this, [file]);
  void unselectFilename(String filename) => _staticInfo.callMethodOnReceiver('unselect_filename', this, [filename]);
  void unselectUri(String uri) => _staticInfo.callMethodOnReceiver('unselect_uri', this, [uri]);
  int connectToConfirmOverwrite(bool after, FileChooserConfirmation func()) => signalConnect('confirm-overwrite', func, after);
  int _connectToCurrentFolderChanged(bool after, void func()) => signalConnect('current-folder-changed', func, after);
  Stream get onCurrentFolderChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCurrentFolderChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterCurrentFolderChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCurrentFolderChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToFileActivated(bool after, void func()) => signalConnect('file-activated', func, after);
  Stream get onFileActivated {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToFileActivated(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterFileActivated {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToFileActivated(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectionChanged(bool after, void func()) => signalConnect('selection-changed', func, after);
  Stream get onSelectionChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectionChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSelectionChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectionChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToUpdatePreview(bool after, void func()) => signalConnect('update-preview', func, after);
  Stream get onUpdatePreview {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUpdatePreview(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterUpdatePreview {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUpdatePreview(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class FileChooserAction extends GEnumBase {
  const FileChooserAction(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FileChooserAction');

  static const FileChooserAction OPEN = const FileChooserAction(0);
  static const FileChooserAction SAVE = const FileChooserAction(1);
  static const FileChooserAction SELECT_FOLDER = const FileChooserAction(2);
  static const FileChooserAction CREATE_FOLDER = const FileChooserAction(3);
  String toString() {
    switch(index) {
      case 0: return 'FileChooserAction.OPEN';
      case 1: return 'FileChooserAction.SAVE';
      case 2: return 'FileChooserAction.SELECT_FOLDER';
      case 3: return 'FileChooserAction.CREATE_FOLDER';
      default: return 'new FileChooserAction($index)';
    }
  }
}

class FileChooserButton extends Box with ImplementorIface, Buildable, FileChooser, Orientable {
  FileChooserButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FileChooserButton');

  void set dialog(FileChooser value) => _staticInfo.setGPropertyOnReceiver('dialog', this, value);
  static const String DIALOG_PROPERTY = 'dialog';
  static const String FOCUS_ON_CLICK_PROPERTY = 'focus-on-click';
  static const String TITLE_PROPERTY = 'title';
  static const String WIDTH_CHARS_PROPERTY = 'width-chars';
  factory FileChooserButton(String title, FileChooserAction action) => _staticInfo.callStatic('new', [title, action]);
  factory FileChooserButton.withDialog(Dialog dialog) => _staticInfo.callStatic('new_with_dialog', [dialog]);
  bool get focusOnClick => _staticInfo.callMethodOnReceiver('get_focus_on_click', this, []);
  String get title => _staticInfo.callMethodOnReceiver('get_title', this, []);
  int get widthChars => _staticInfo.callMethodOnReceiver('get_width_chars', this, []);
  void set focusOnClick(bool focusOnClick) => _staticInfo.callMethodOnReceiver('set_focus_on_click', this, [focusOnClick]);
  void set title(String title) => _staticInfo.callMethodOnReceiver('set_title', this, [title]);
  void set widthChars(int nChars) => _staticInfo.callMethodOnReceiver('set_width_chars', this, [nChars]);
  int _connectToFileSet(bool after, void func()) => signalConnect('file-set', func, after);
  Stream get onFileSet {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToFileSet(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterFileSet {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToFileSet(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class FileChooserConfirmation extends GEnumBase {
  const FileChooserConfirmation(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FileChooserConfirmation');

  static const FileChooserConfirmation CONFIRM = const FileChooserConfirmation(0);
  static const FileChooserConfirmation ACCEPT_FILENAME = const FileChooserConfirmation(1);
  static const FileChooserConfirmation SELECT_AGAIN = const FileChooserConfirmation(2);
  String toString() {
    switch(index) {
      case 0: return 'FileChooserConfirmation.CONFIRM';
      case 1: return 'FileChooserConfirmation.ACCEPT_FILENAME';
      case 2: return 'FileChooserConfirmation.SELECT_AGAIN';
      default: return 'new FileChooserConfirmation($index)';
    }
  }
}

class FileChooserDialog extends Dialog with ImplementorIface, Buildable, FileChooser {
  FileChooserDialog.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FileChooserDialog');

}

class FileChooserErrorCode extends GEnumBase {
  const FileChooserErrorCode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FileChooserError');

  static const FileChooserErrorCode NONEXISTENT = const FileChooserErrorCode(0);
  static const FileChooserErrorCode BAD_FILENAME = const FileChooserErrorCode(1);
  static const FileChooserErrorCode ALREADY_EXISTS = const FileChooserErrorCode(2);
  static const FileChooserErrorCode INCOMPLETE_HOSTNAME = const FileChooserErrorCode(3);
  String toString() {
    switch(index) {
      case 0: return 'FileChooserErrorCode.NONEXISTENT';
      case 1: return 'FileChooserErrorCode.BAD_FILENAME';
      case 2: return 'FileChooserErrorCode.ALREADY_EXISTS';
      case 3: return 'FileChooserErrorCode.INCOMPLETE_HOSTNAME';
      default: return 'new FileChooserErrorCode($index)';
    }
  }
  static int quark() => _staticInfo.callStatic('quark', []);
}

class FileChooserError extends GErrorBase {
  static final int _quark = lookupErrorQuarkFromString('gtk-file-chooser-error-quark');
  FileChooserError(FileChooserErrorCode code, String message)
      : super.fromFields(_quark, code, message);
}

class FileChooserWidget extends Box with ImplementorIface, Buildable, FileChooser, Orientable {
  FileChooserWidget.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FileChooserWidget');

  bool get searchMode => _staticInfo.getGPropertyOnReceiver('search-mode', this);
  void set searchMode(bool value) => _staticInfo.setGPropertyOnReceiver('search-mode', this, value);
  static const String SEARCH_MODE_PROPERTY = 'search-mode';
  String get subtitle => _staticInfo.getGPropertyOnReceiver('subtitle', this);
  static const String SUBTITLE_PROPERTY = 'subtitle';
  factory FileChooserWidget(FileChooserAction action) => _staticInfo.callStatic('new', [action]);
  int _connectToDesktopFolder(bool after, void func()) => signalConnect('desktop-folder', func, after);
  Stream get onDesktopFolder {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDesktopFolder(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterDesktopFolder {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDesktopFolder(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDownFolder(bool after, void func()) => signalConnect('down-folder', func, after);
  Stream get onDownFolder {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDownFolder(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterDownFolder {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDownFolder(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToHomeFolder(bool after, void func()) => signalConnect('home-folder', func, after);
  Stream get onHomeFolder {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToHomeFolder(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterHomeFolder {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToHomeFolder(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToLocationPopup(bool after, void func(String path)) => signalConnect('location-popup', func, after);
  Stream<String> get onLocationPopup {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToLocationPopup(false, (String path) {
              controller.add(path);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<String> get afterLocationPopup {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToLocationPopup(true, (String path) {
              controller.add(path);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToLocationPopupOnPaste(bool after, void func()) => signalConnect('location-popup-on-paste', func, after);
  Stream get onLocationPopupOnPaste {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToLocationPopupOnPaste(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterLocationPopupOnPaste {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToLocationPopupOnPaste(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToLocationTogglePopup(bool after, void func()) => signalConnect('location-toggle-popup', func, after);
  Stream get onLocationTogglePopup {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToLocationTogglePopup(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterLocationTogglePopup {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToLocationTogglePopup(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPlacesShortcut(bool after, void func()) => signalConnect('places-shortcut', func, after);
  Stream get onPlacesShortcut {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPlacesShortcut(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPlacesShortcut {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPlacesShortcut(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToQuickBookmark(bool after, void func(int bookmarkIndex)) => signalConnect('quick-bookmark', func, after);
  Stream<int> get onQuickBookmark {
    int signalId;
    StreamController<int> controller;
    controller = new StreamController<int>(
      onListen: () {
          signalId = _connectToQuickBookmark(false, (int bookmarkIndex) {
              controller.add(bookmarkIndex);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<int> get afterQuickBookmark {
    int signalId;
    StreamController<int> controller;
    controller = new StreamController<int>(
      onListen: () {
          signalId = _connectToQuickBookmark(true, (int bookmarkIndex) {
              controller.add(bookmarkIndex);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRecentShortcut(bool after, void func()) => signalConnect('recent-shortcut', func, after);
  Stream get onRecentShortcut {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToRecentShortcut(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterRecentShortcut {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToRecentShortcut(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSearchShortcut(bool after, void func()) => signalConnect('search-shortcut', func, after);
  Stream get onSearchShortcut {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSearchShortcut(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSearchShortcut {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSearchShortcut(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToShowHidden(bool after, void func()) => signalConnect('show-hidden', func, after);
  Stream get onShowHidden {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToShowHidden(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterShowHidden {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToShowHidden(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToUpFolder(bool after, void func()) => signalConnect('up-folder', func, after);
  Stream get onUpFolder {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUpFolder(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterUpFolder {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUpFolder(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class FileFilter extends InitiallyUnowned with Buildable {
  FileFilter.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FileFilter');

  factory FileFilter() => _staticInfo.callStatic('new', []);
  void addCustom(FileFilterFlags needed, FileFilterFunc func) => _staticInfo.callMethodOnReceiver('add_custom', this, [needed, func]);
  void addMimeType(String mimeType) => _staticInfo.callMethodOnReceiver('add_mime_type', this, [mimeType]);
  void addCairoPattern(String pattern) => _staticInfo.callMethodOnReceiver('add_pattern', this, [pattern]);
  void addPixbufFormats() => _staticInfo.callMethodOnReceiver('add_pixbuf_formats', this, []);
  bool filter(FileFilterInfo filterInfo) => _staticInfo.callMethodOnReceiver('filter', this, [filterInfo]);
  String getName() => _staticInfo.callMethodOnReceiver('get_name', this, []);
  FileFilterFlags getNeeded() => _staticInfo.callMethodOnReceiver('get_needed', this, []);
  void setName(String name) => _staticInfo.callMethodOnReceiver('set_name', this, [name]);
}

class FileFilterFlags extends GEnumBase {
  const FileFilterFlags(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FileFilterFlags');

  static const FileFilterFlags NULL = const FileFilterFlags(0);
  static const FileFilterFlags FILENAME = const FileFilterFlags(1);
  bool get filename => (index & 1) == 1;
  static const FileFilterFlags URI = const FileFilterFlags(2);
  bool get uri => (index & 2) == 2;
  static const FileFilterFlags DISPLAY_NAME = const FileFilterFlags(4);
  bool get displayName => (index & 4) == 4;
  static const FileFilterFlags MIME_TYPE = const FileFilterFlags(8);
  bool get mimeType => (index & 8) == 8;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'FileFilterFlags.FILENAME';
      case 2: return 'FileFilterFlags.URI';
      case 4: return 'FileFilterFlags.DISPLAY_NAME';
      case 8: return 'FileFilterFlags.MIME_TYPE';
      default: return 'new FileFilterFlags($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'FileFilterFlags.NULL';
    }
    List codes = [];
    for (var i=1; i <= 8; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  FileFilterFlags operator|(FileFilterFlags other) =>
    new FileFilterFlags(index | other.index);
  FileFilterFlags operator&(FileFilterFlags other) =>
    new FileFilterFlags(index & other.index);
}

typedef bool FileFilterFunc(FileFilterInfo filterInfo);
class FileFilterInfo extends GObjectBase {
  FileFilterInfo.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FileFilterInfo');

  FileFilterFlags get contains => getFieldOfObject('contains', 0);
  void set contains(FileFilterFlags value) => setFieldOfObject('contains', 0, value);
  String get filename => getFieldOfObject('filename', 1);
  void set filename(String value) => setFieldOfObject('filename', 1, value);
  String get uri => getFieldOfObject('uri', 2);
  void set uri(String value) => setFieldOfObject('uri', 2, value);
  String get displayName => getFieldOfObject('display_name', 3);
  void set displayName(String value) => setFieldOfObject('display_name', 3, value);
  String get mimeType => getFieldOfObject('mime_type', 4);
  void set mimeType(String value) => setFieldOfObject('mime_type', 4, value);
}

class Fixed extends Container with ImplementorIface, Buildable {
  Fixed.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Fixed');

  factory Fixed() => _staticInfo.callStatic('new', []);
  void move(Widget widget, int x, int y) => _staticInfo.callMethodOnReceiver('move', this, [widget, x, y]);
  void put(Widget widget, int x, int y) => _staticInfo.callMethodOnReceiver('put', this, [widget, x, y]);
}

class FixedChild extends GObjectBase {
  FixedChild.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FixedChild');

  Widget get widget => getFieldOfObject('widget', 0);
  void set widget(Widget value) => setFieldOfObject('widget', 0, value);
  int get x => getFieldOfObject('x', 1);
  void set x(int value) => setFieldOfObject('x', 1, value);
  int get y => getFieldOfObject('y', 2);
  void set y(int value) => setFieldOfObject('y', 2, value);
}

class FlowBox extends Container with ImplementorIface, Buildable, Orientable {
  FlowBox.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FlowBox');

  static const String ACTIVATE_ON_SINGLE_CLICK_PROPERTY = 'activate-on-single-click';
  static const String COLUMN_SPACING_PROPERTY = 'column-spacing';
  static const String HOMOGENEOUS_PROPERTY = 'homogeneous';
  static const String MAX_CHILDREN_PER_LINE_PROPERTY = 'max-children-per-line';
  static const String MIN_CHILDREN_PER_LINE_PROPERTY = 'min-children-per-line';
  static const String ROW_SPACING_PROPERTY = 'row-spacing';
  static const String SELECTION_MODE_PROPERTY = 'selection-mode';
  factory FlowBox() => _staticInfo.callStatic('new', []);
  bool get activateOnSingleClick => _staticInfo.callMethodOnReceiver('get_activate_on_single_click', this, []);
  FlowBoxChild getChildAtIndex(int idx) => _staticInfo.callMethodOnReceiver('get_child_at_index', this, [idx]);
  int get columnSpacing => _staticInfo.callMethodOnReceiver('get_column_spacing', this, []);
  bool get homogeneous => _staticInfo.callMethodOnReceiver('get_homogeneous', this, []);
  int get maxChildrenPerLine => _staticInfo.callMethodOnReceiver('get_max_children_per_line', this, []);
  int get minChildrenPerLine => _staticInfo.callMethodOnReceiver('get_min_children_per_line', this, []);
  int get rowSpacing => _staticInfo.callMethodOnReceiver('get_row_spacing', this, []);
  GLibList /* this will fail */ getSelectedChildren() => _staticInfo.callMethodOnReceiver('get_selected_children', this, []);
  SelectionMode get selectionMode => _staticInfo.callMethodOnReceiver('get_selection_mode', this, []);
  void insert(Widget widget, int position) => _staticInfo.callMethodOnReceiver('insert', this, [widget, position]);
  void invalidateFilter() => _staticInfo.callMethodOnReceiver('invalidate_filter', this, []);
  void invalidateSort() => _staticInfo.callMethodOnReceiver('invalidate_sort', this, []);
  void selectAll() => _staticInfo.callMethodOnReceiver('select_all', this, []);
  void selectChild(FlowBoxChild child) => _staticInfo.callMethodOnReceiver('select_child', this, [child]);
  void selectedForeach(FlowBoxForeachFunc func) => _staticInfo.callMethodOnReceiver('selected_foreach', this, [func]);
  void set activateOnSingleClick(bool single) => _staticInfo.callMethodOnReceiver('set_activate_on_single_click', this, [single]);
  void set columnSpacing(int spacing) => _staticInfo.callMethodOnReceiver('set_column_spacing', this, [spacing]);
  void setFilterFunc(FlowBoxFilterFunc filterFunc) => _staticInfo.callMethodOnReceiver('set_filter_func', this, [filterFunc]);
  void setHadjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_hadjustment', this, [adjustment]);
  void set homogeneous(bool homogeneous) => _staticInfo.callMethodOnReceiver('set_homogeneous', this, [homogeneous]);
  void set maxChildrenPerLine(int nChildren) => _staticInfo.callMethodOnReceiver('set_max_children_per_line', this, [nChildren]);
  void set minChildrenPerLine(int nChildren) => _staticInfo.callMethodOnReceiver('set_min_children_per_line', this, [nChildren]);
  void set rowSpacing(int spacing) => _staticInfo.callMethodOnReceiver('set_row_spacing', this, [spacing]);
  void set selectionMode(SelectionMode mode) => _staticInfo.callMethodOnReceiver('set_selection_mode', this, [mode]);
  void setSortFunc(FlowBoxSortFunc sortFunc) => _staticInfo.callMethodOnReceiver('set_sort_func', this, [sortFunc]);
  void setVadjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_vadjustment', this, [adjustment]);
  void unselectAll() => _staticInfo.callMethodOnReceiver('unselect_all', this, []);
  void unselectChild(FlowBoxChild child) => _staticInfo.callMethodOnReceiver('unselect_child', this, [child]);
  int _connectToActivateCursorChild(bool after, void func()) => signalConnect('activate-cursor-child', func, after);
  Stream get onActivateCursorChild {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivateCursorChild(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivateCursorChild {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivateCursorChild(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToChildActivated(bool after, void func(FlowBoxChild child)) => signalConnect('child-activated', func, after);
  Stream<FlowBoxChild> get onChildActivated {
    int signalId;
    StreamController<FlowBoxChild> controller;
    controller = new StreamController<FlowBoxChild>(
      onListen: () {
          signalId = _connectToChildActivated(false, (FlowBoxChild child) {
              controller.add(child);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<FlowBoxChild> get afterChildActivated {
    int signalId;
    StreamController<FlowBoxChild> controller;
    controller = new StreamController<FlowBoxChild>(
      onListen: () {
          signalId = _connectToChildActivated(true, (FlowBoxChild child) {
              controller.add(child);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveCursor(bool after, bool func(MovementStep step, int count)) => signalConnect('move-cursor', func, after);
  Stream<FlowBoxMoveCursorEvent> get onMoveCursor {
    int signalId;
    StreamController<FlowBoxMoveCursorEvent> controller;
    controller = new StreamController<FlowBoxMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(false, (MovementStep step, int count) {
              var result = new FlowBoxMoveCursorEvent(step, count);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<FlowBoxMoveCursorEvent> get afterMoveCursor {
    int signalId;
    StreamController<FlowBoxMoveCursorEvent> controller;
    controller = new StreamController<FlowBoxMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(true, (MovementStep step, int count) {
              var result = new FlowBoxMoveCursorEvent(step, count);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectAll(bool after, void func()) => signalConnect('select-all', func, after);
  Stream get onSelectAll {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectAll(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSelectAll {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectAll(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectedChildrenChanged(bool after, void func()) => signalConnect('selected-children-changed', func, after);
  Stream get onSelectedChildrenChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectedChildrenChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSelectedChildrenChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectedChildrenChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToToggleCursorChild(bool after, void func()) => signalConnect('toggle-cursor-child', func, after);
  Stream get onToggleCursorChild {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggleCursorChild(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterToggleCursorChild {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggleCursorChild(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToUnselectAll(bool after, void func()) => signalConnect('unselect-all', func, after);
  Stream get onUnselectAll {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUnselectAll(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterUnselectAll {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUnselectAll(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class FlowBoxMoveCursorEvent {
  final MovementStep step;
  final int count;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  FlowBoxMoveCursorEvent(this.step, this.count);
}

class FlowBoxAccessible extends ContainerAccessible with Component, Selection {
  FlowBoxAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FlowBoxAccessible');

}

class FlowBoxChild extends Bin with ImplementorIface, Buildable {
  FlowBoxChild.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FlowBoxChild');

  factory FlowBoxChild() => _staticInfo.callStatic('new', []);
  void changed() => _staticInfo.callMethodOnReceiver('changed', this, []);
  int getIndex() => _staticInfo.callMethodOnReceiver('get_index', this, []);
  bool isSelected() => _staticInfo.callMethodOnReceiver('is_selected', this, []);
  int _connectToActivate(bool after, void func()) => signalConnect('activate', func, after);
  Stream get onActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class FlowBoxChildAccessible extends ContainerAccessible with Component {
  FlowBoxChildAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FlowBoxChildAccessible');

}

typedef bool FlowBoxFilterFunc(FlowBoxChild child);
typedef void FlowBoxForeachFunc(FlowBox box, FlowBoxChild child);
typedef int FlowBoxSortFunc(FlowBoxChild child1, FlowBoxChild child2);
class FontButton extends Button with ImplementorIface, Actionable, Activatable, Buildable, FontChooser {
  FontButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FontButton');

  static const String FONT_NAME_PROPERTY = 'font-name';
  static const String SHOW_SIZE_PROPERTY = 'show-size';
  static const String SHOW_STYLE_PROPERTY = 'show-style';
  static const String TITLE_PROPERTY = 'title';
  static const String USE_FONT_PROPERTY = 'use-font';
  static const String USE_SIZE_PROPERTY = 'use-size';
  factory FontButton() => _staticInfo.callStatic('new', []);
  factory FontButton.withFont(String fontname) => _staticInfo.callStatic('new_with_font', [fontname]);
  String get fontName => _staticInfo.callMethodOnReceiver('get_font_name', this, []);
  bool get showSize => _staticInfo.callMethodOnReceiver('get_show_size', this, []);
  bool get showStyle => _staticInfo.callMethodOnReceiver('get_show_style', this, []);
  String get title => _staticInfo.callMethodOnReceiver('get_title', this, []);
  bool get useFont => _staticInfo.callMethodOnReceiver('get_use_font', this, []);
  bool get useSize => _staticInfo.callMethodOnReceiver('get_use_size', this, []);
  bool setFontName(String fontname) => _staticInfo.callMethodOnReceiver('set_font_name', this, [fontname]);
  void set showSize(bool showSize) => _staticInfo.callMethodOnReceiver('set_show_size', this, [showSize]);
  void set showStyle(bool showStyle) => _staticInfo.callMethodOnReceiver('set_show_style', this, [showStyle]);
  void set title(String title) => _staticInfo.callMethodOnReceiver('set_title', this, [title]);
  void set useFont(bool useFont) => _staticInfo.callMethodOnReceiver('set_use_font', this, [useFont]);
  void set useSize(bool useSize) => _staticInfo.callMethodOnReceiver('set_use_size', this, [useSize]);
  int _connectToFontSet(bool after, void func()) => signalConnect('font-set', func, after);
  Stream get onFontSet {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToFontSet(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterFontSet {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToFontSet(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

abstract class FontChooser extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FontChooser');



  static const String FONT_PROPERTY = 'font';
  static const String FONT_DESC_PROPERTY = 'font-desc';
  static const String PREVIEW_TEXT_PROPERTY = 'preview-text';
  static const String SHOW_PREVIEW_ENTRY_PROPERTY = 'show-preview-entry';
  String get font => _staticInfo.callMethodOnReceiver('get_font', this, []);
  FontDescription get fontDesc => _staticInfo.callMethodOnReceiver('get_font_desc', this, []);
  FontFace getFontFace() => _staticInfo.callMethodOnReceiver('get_font_face', this, []);
  FontFamily getFontFamily() => _staticInfo.callMethodOnReceiver('get_font_family', this, []);
  FontMap getFontMap() => _staticInfo.callMethodOnReceiver('get_font_map', this, []);
  int getFontSize() => _staticInfo.callMethodOnReceiver('get_font_size', this, []);
  String get previewText => _staticInfo.callMethodOnReceiver('get_preview_text', this, []);
  bool get showPreviewEntry => _staticInfo.callMethodOnReceiver('get_show_preview_entry', this, []);
  void setFilterFunc(FontFilterFunc filter) => _staticInfo.callMethodOnReceiver('set_filter_func', this, [filter]);
  void set font(String fontname) => _staticInfo.callMethodOnReceiver('set_font', this, [fontname]);
  void set fontDesc(FontDescription fontDesc) => _staticInfo.callMethodOnReceiver('set_font_desc', this, [fontDesc]);
  void setFontMap(FontMap fontmap) => _staticInfo.callMethodOnReceiver('set_font_map', this, [fontmap]);
  void set previewText(String text) => _staticInfo.callMethodOnReceiver('set_preview_text', this, [text]);
  void set showPreviewEntry(bool showPreviewEntry) => _staticInfo.callMethodOnReceiver('set_show_preview_entry', this, [showPreviewEntry]);
  int _connectToFontActivated(bool after, void func(String fontname)) => signalConnect('font-activated', func, after);
  Stream<String> get onFontActivated {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToFontActivated(false, (String fontname) {
              controller.add(fontname);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<String> get afterFontActivated {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToFontActivated(true, (String fontname) {
              controller.add(fontname);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class FontChooserDialog extends Dialog with ImplementorIface, Buildable, FontChooser {
  FontChooserDialog.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FontChooserDialog');

  factory FontChooserDialog(String title, Window parent) => _staticInfo.callStatic('new', [title, parent]);
}

class FontChooserWidget extends Box with ImplementorIface, Buildable, FontChooser, Orientable {
  FontChooserWidget.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FontChooserWidget');

  factory FontChooserWidget() => _staticInfo.callStatic('new', []);
}

typedef bool FontFilterFunc(FontFamily family, FontFace face);
class FontSelection extends Box with ImplementorIface, Buildable, Orientable {
  FontSelection.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FontSelection');

  static const String FONT_NAME_PROPERTY = 'font-name';
  static const String PREVIEW_TEXT_PROPERTY = 'preview-text';
  factory FontSelection() => _staticInfo.callStatic('new', []);
  FontFace getFace() => _staticInfo.callMethodOnReceiver('get_face', this, []);
  Widget getFaceList() => _staticInfo.callMethodOnReceiver('get_face_list', this, []);
  FontFamily getFamily() => _staticInfo.callMethodOnReceiver('get_family', this, []);
  Widget getFamilyList() => _staticInfo.callMethodOnReceiver('get_family_list', this, []);
  String get fontName => _staticInfo.callMethodOnReceiver('get_font_name', this, []);
  Widget getPreviewEntry() => _staticInfo.callMethodOnReceiver('get_preview_entry', this, []);
  String get previewText => _staticInfo.callMethodOnReceiver('get_preview_text', this, []);
  int getSize() => _staticInfo.callMethodOnReceiver('get_size', this, []);
  Widget getSizeEntry() => _staticInfo.callMethodOnReceiver('get_size_entry', this, []);
  Widget getSizeList() => _staticInfo.callMethodOnReceiver('get_size_list', this, []);
  bool setFontName(String fontname) => _staticInfo.callMethodOnReceiver('set_font_name', this, [fontname]);
  void set previewText(String text) => _staticInfo.callMethodOnReceiver('set_preview_text', this, [text]);
}

class FontSelectionDialog extends Dialog with ImplementorIface, Buildable {
  FontSelectionDialog.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FontSelectionDialog');

  factory FontSelectionDialog(String title) => _staticInfo.callStatic('new', [title]);
  Widget getCancelButton() => _staticInfo.callMethodOnReceiver('get_cancel_button', this, []);
  String getFontName() => _staticInfo.callMethodOnReceiver('get_font_name', this, []);
  Widget getFontSelection() => _staticInfo.callMethodOnReceiver('get_font_selection', this, []);
  Widget getOkButton() => _staticInfo.callMethodOnReceiver('get_ok_button', this, []);
  String getPreviewText() => _staticInfo.callMethodOnReceiver('get_preview_text', this, []);
  bool setFontName(String fontname) => _staticInfo.callMethodOnReceiver('set_font_name', this, [fontname]);
  void setPreviewText(String text) => _staticInfo.callMethodOnReceiver('set_preview_text', this, [text]);
}

class Frame extends Bin with ImplementorIface, Buildable {
  Frame.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Frame');

  static const String LABEL_PROPERTY = 'label';
  static const String LABEL_WIDGET_PROPERTY = 'label-widget';
  num get labelXalign => _staticInfo.getGPropertyOnReceiver('label-xalign', this);
  void set labelXalign(num value) => _staticInfo.setGPropertyOnReceiver('label-xalign', this, value);
  static const String LABEL_XALIGN_PROPERTY = 'label-xalign';
  num get labelYalign => _staticInfo.getGPropertyOnReceiver('label-yalign', this);
  void set labelYalign(num value) => _staticInfo.setGPropertyOnReceiver('label-yalign', this, value);
  static const String LABEL_YALIGN_PROPERTY = 'label-yalign';
  static const String SHADOW_TYPE_PROPERTY = 'shadow-type';
  factory Frame(String label) => _staticInfo.callStatic('new', [label]);
  String get label => _staticInfo.callMethodOnReceiver('get_label', this, []);
  void getLabelAlign() => _staticInfo.callMethodOnReceiver('get_label_align', this, []);
  Widget get labelWidget => _staticInfo.callMethodOnReceiver('get_label_widget', this, []);
  ShadowType get shadowType => _staticInfo.callMethodOnReceiver('get_shadow_type', this, []);
  void set label(String label) => _staticInfo.callMethodOnReceiver('set_label', this, [label]);
  void setLabelAlign(num xalign, num yalign) => _staticInfo.callMethodOnReceiver('set_label_align', this, [xalign, yalign]);
  void set labelWidget(Widget labelWidget) => _staticInfo.callMethodOnReceiver('set_label_widget', this, [labelWidget]);
  void set shadowType(ShadowType type) => _staticInfo.callMethodOnReceiver('set_shadow_type', this, [type]);
}

class FrameAccessible extends ContainerAccessible with Component {
  FrameAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'FrameAccessible');

}

class GLArea extends Widget with ImplementorIface, Buildable {
  GLArea.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'GLArea');

  static const String AUTO_RENDER_PROPERTY = 'auto-render';
  static const String CONTEXT_PROPERTY = 'context';
  static const String HAS_ALPHA_PROPERTY = 'has-alpha';
  static const String HAS_DEPTH_BUFFER_PROPERTY = 'has-depth-buffer';
  static const String HAS_STENCIL_BUFFER_PROPERTY = 'has-stencil-buffer';
  factory GLArea() => _staticInfo.callStatic('new', []);
  void attachBuffers() => _staticInfo.callMethodOnReceiver('attach_buffers', this, []);
  bool get autoRender => _staticInfo.callMethodOnReceiver('get_auto_render', this, []);
  GLContext get context => _staticInfo.callMethodOnReceiver('get_context', this, []);
  GErrorBase getError() => _staticInfo.callMethodOnReceiver('get_error', this, []);
  bool get hasAlpha => _staticInfo.callMethodOnReceiver('get_has_alpha', this, []);
  bool get hasDepthBuffer => _staticInfo.callMethodOnReceiver('get_has_depth_buffer', this, []);
  bool get hasStencilBuffer => _staticInfo.callMethodOnReceiver('get_has_stencil_buffer', this, []);
  void getRequiredVersion() => _staticInfo.callMethodOnReceiver('get_required_version', this, []);
  void makeCurrent() => _staticInfo.callMethodOnReceiver('make_current', this, []);
  void queueRender() => _staticInfo.callMethodOnReceiver('queue_render', this, []);
  void set autoRender(bool autoRender) => _staticInfo.callMethodOnReceiver('set_auto_render', this, [autoRender]);
  void setError(GErrorBase error) => _staticInfo.callMethodOnReceiver('set_error', this, [error]);
  void set hasAlpha(bool hasAlpha) => _staticInfo.callMethodOnReceiver('set_has_alpha', this, [hasAlpha]);
  void set hasDepthBuffer(bool hasDepthBuffer) => _staticInfo.callMethodOnReceiver('set_has_depth_buffer', this, [hasDepthBuffer]);
  void set hasStencilBuffer(bool hasStencilBuffer) => _staticInfo.callMethodOnReceiver('set_has_stencil_buffer', this, [hasStencilBuffer]);
  void setRequiredVersion(int major, int minor) => _staticInfo.callMethodOnReceiver('set_required_version', this, [major, minor]);
  int connectToCreateContext(bool after, GLContext func()) => signalConnect('create-context', func, after);
  int _connectToRender(bool after, bool func(GLContext context)) => signalConnect('render', func, after);
  Stream<GLAreaRenderEvent> get onRender {
    int signalId;
    StreamController<GLAreaRenderEvent> controller;
    controller = new StreamController<GLAreaRenderEvent>(
      onListen: () {
          signalId = _connectToRender(false, (GLContext context) {
              var result = new GLAreaRenderEvent(context);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<GLAreaRenderEvent> get afterRender {
    int signalId;
    StreamController<GLAreaRenderEvent> controller;
    controller = new StreamController<GLAreaRenderEvent>(
      onListen: () {
          signalId = _connectToRender(true, (GLContext context) {
              var result = new GLAreaRenderEvent(context);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToResize(bool after, void func(int width, int height)) => signalConnect('resize', func, after);
  Stream<GLAreaResizeEvent> get onResize {
    int signalId;
    StreamController<GLAreaResizeEvent> controller;
    controller = new StreamController<GLAreaResizeEvent>(
      onListen: () {
          signalId = _connectToResize(false, (int width, int height) {
              var result = new GLAreaResizeEvent(width, height);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<GLAreaResizeEvent> get afterResize {
    int signalId;
    StreamController<GLAreaResizeEvent> controller;
    controller = new StreamController<GLAreaResizeEvent>(
      onListen: () {
          signalId = _connectToResize(true, (int width, int height) {
              var result = new GLAreaResizeEvent(width, height);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class GLAreaRenderEvent {
  final GLContext context;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  GLAreaRenderEvent(this.context);
}

class GLAreaResizeEvent {
  final int width;
  final int height;

  GLAreaResizeEvent(this.width, this.height);
}

class Gesture extends EventController {
  Gesture.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Gesture');

  int get nPoints => _staticInfo.getGPropertyOnReceiver('n-points', this);
  void set nPoints(int value) => _staticInfo.setGPropertyOnReceiver('n-points', this, value);
  static const String N_POINTS_PROPERTY = 'n-points';
  static const String WINDOW_PROPERTY = 'window';
  bool getBoundingBox() => _staticInfo.callMethodOnReceiver('get_bounding_box', this, []);
  bool getBoundingBoxCenter() => _staticInfo.callMethodOnReceiver('get_bounding_box_center', this, []);
  Device getDevice() => _staticInfo.callMethodOnReceiver('get_device', this, []);
  GLibList /* this will fail */ getGroup() => _staticInfo.callMethodOnReceiver('get_group', this, []);
  Event getLastEvent(EventSequence sequence) => _staticInfo.callMethodOnReceiver('get_last_event', this, [sequence]);
  EventSequence getLastUpdatedSequence() => _staticInfo.callMethodOnReceiver('get_last_updated_sequence', this, []);
  bool getPoint(EventSequence sequence) => _staticInfo.callMethodOnReceiver('get_point', this, [sequence]);
  EventSequenceState getSequenceState(EventSequence sequence) => _staticInfo.callMethodOnReceiver('get_sequence_state', this, [sequence]);
  GLibList /* this will fail */ getSequences() => _staticInfo.callMethodOnReceiver('get_sequences', this, []);
  gdk.Window get window => _staticInfo.callMethodOnReceiver('get_window', this, []);
  void group(Gesture gesture) => _staticInfo.callMethodOnReceiver('group', this, [gesture]);
  bool handlesSequence(EventSequence sequence) => _staticInfo.callMethodOnReceiver('handles_sequence', this, [sequence]);
  bool isActive() => _staticInfo.callMethodOnReceiver('is_active', this, []);
  bool isGroupedWith(Gesture other) => _staticInfo.callMethodOnReceiver('is_grouped_with', this, [other]);
  bool isRecognized() => _staticInfo.callMethodOnReceiver('is_recognized', this, []);
  bool setSequenceState(EventSequence sequence, EventSequenceState state) => _staticInfo.callMethodOnReceiver('set_sequence_state', this, [sequence, state]);
  bool setState(EventSequenceState state) => _staticInfo.callMethodOnReceiver('set_state', this, [state]);
  void set window(gdk.Window window) => _staticInfo.callMethodOnReceiver('set_window', this, [window]);
  void ungroup() => _staticInfo.callMethodOnReceiver('ungroup', this, []);
  int _connectToBegin(bool after, void func(EventSequence sequence)) => signalConnect('begin', func, after);
  Stream<EventSequence> get onBegin {
    int signalId;
    StreamController<EventSequence> controller;
    controller = new StreamController<EventSequence>(
      onListen: () {
          signalId = _connectToBegin(false, (EventSequence sequence) {
              controller.add(sequence);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EventSequence> get afterBegin {
    int signalId;
    StreamController<EventSequence> controller;
    controller = new StreamController<EventSequence>(
      onListen: () {
          signalId = _connectToBegin(true, (EventSequence sequence) {
              controller.add(sequence);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCancel(bool after, void func(EventSequence sequence)) => signalConnect('cancel', func, after);
  Stream<EventSequence> get onCancel {
    int signalId;
    StreamController<EventSequence> controller;
    controller = new StreamController<EventSequence>(
      onListen: () {
          signalId = _connectToCancel(false, (EventSequence sequence) {
              controller.add(sequence);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EventSequence> get afterCancel {
    int signalId;
    StreamController<EventSequence> controller;
    controller = new StreamController<EventSequence>(
      onListen: () {
          signalId = _connectToCancel(true, (EventSequence sequence) {
              controller.add(sequence);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToEnd(bool after, void func(EventSequence sequence)) => signalConnect('end', func, after);
  Stream<EventSequence> get onEnd {
    int signalId;
    StreamController<EventSequence> controller;
    controller = new StreamController<EventSequence>(
      onListen: () {
          signalId = _connectToEnd(false, (EventSequence sequence) {
              controller.add(sequence);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EventSequence> get afterEnd {
    int signalId;
    StreamController<EventSequence> controller;
    controller = new StreamController<EventSequence>(
      onListen: () {
          signalId = _connectToEnd(true, (EventSequence sequence) {
              controller.add(sequence);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSequenceStateChanged(bool after, void func(EventSequence sequence, EventSequenceState state)) => signalConnect('sequence-state-changed', func, after);
  Stream<GestureSequenceStateChangedEvent> get onSequenceStateChanged {
    int signalId;
    StreamController<GestureSequenceStateChangedEvent> controller;
    controller = new StreamController<GestureSequenceStateChangedEvent>(
      onListen: () {
          signalId = _connectToSequenceStateChanged(false, (EventSequence sequence, EventSequenceState state) {
              var result = new GestureSequenceStateChangedEvent(sequence, state);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<GestureSequenceStateChangedEvent> get afterSequenceStateChanged {
    int signalId;
    StreamController<GestureSequenceStateChangedEvent> controller;
    controller = new StreamController<GestureSequenceStateChangedEvent>(
      onListen: () {
          signalId = _connectToSequenceStateChanged(true, (EventSequence sequence, EventSequenceState state) {
              var result = new GestureSequenceStateChangedEvent(sequence, state);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToUpdate(bool after, void func(EventSequence sequence)) => signalConnect('update', func, after);
  Stream<EventSequence> get onUpdate {
    int signalId;
    StreamController<EventSequence> controller;
    controller = new StreamController<EventSequence>(
      onListen: () {
          signalId = _connectToUpdate(false, (EventSequence sequence) {
              controller.add(sequence);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<EventSequence> get afterUpdate {
    int signalId;
    StreamController<EventSequence> controller;
    controller = new StreamController<EventSequence>(
      onListen: () {
          signalId = _connectToUpdate(true, (EventSequence sequence) {
              controller.add(sequence);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class GestureSequenceStateChangedEvent {
  final EventSequence sequence;
  final EventSequenceState state;

  GestureSequenceStateChangedEvent(this.sequence, this.state);
}

class GestureDrag extends GestureSingle {
  GestureDrag.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'GestureDrag');

  factory GestureDrag(Widget widget) => _staticInfo.callStatic('new', [widget]);
  bool getOffset() => _staticInfo.callMethodOnReceiver('get_offset', this, []);
  bool getStartPoint() => _staticInfo.callMethodOnReceiver('get_start_point', this, []);
  int _connectToDragBegin(bool after, void func(num startX, num startY)) => signalConnect('drag-begin', func, after);
  Stream<GestureDragDragBeginEvent> get onDragBegin {
    int signalId;
    StreamController<GestureDragDragBeginEvent> controller;
    controller = new StreamController<GestureDragDragBeginEvent>(
      onListen: () {
          signalId = _connectToDragBegin(false, (num startX, num startY) {
              var result = new GestureDragDragBeginEvent(startX, startY);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<GestureDragDragBeginEvent> get afterDragBegin {
    int signalId;
    StreamController<GestureDragDragBeginEvent> controller;
    controller = new StreamController<GestureDragDragBeginEvent>(
      onListen: () {
          signalId = _connectToDragBegin(true, (num startX, num startY) {
              var result = new GestureDragDragBeginEvent(startX, startY);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDragEnd(bool after, void func(num offsetX, num offsetY)) => signalConnect('drag-end', func, after);
  Stream<GestureDragDragEndEvent> get onDragEnd {
    int signalId;
    StreamController<GestureDragDragEndEvent> controller;
    controller = new StreamController<GestureDragDragEndEvent>(
      onListen: () {
          signalId = _connectToDragEnd(false, (num offsetX, num offsetY) {
              var result = new GestureDragDragEndEvent(offsetX, offsetY);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<GestureDragDragEndEvent> get afterDragEnd {
    int signalId;
    StreamController<GestureDragDragEndEvent> controller;
    controller = new StreamController<GestureDragDragEndEvent>(
      onListen: () {
          signalId = _connectToDragEnd(true, (num offsetX, num offsetY) {
              var result = new GestureDragDragEndEvent(offsetX, offsetY);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDragUpdate(bool after, void func(num offsetX, num offsetY)) => signalConnect('drag-update', func, after);
  Stream<GestureDragDragUpdateEvent> get onDragUpdate {
    int signalId;
    StreamController<GestureDragDragUpdateEvent> controller;
    controller = new StreamController<GestureDragDragUpdateEvent>(
      onListen: () {
          signalId = _connectToDragUpdate(false, (num offsetX, num offsetY) {
              var result = new GestureDragDragUpdateEvent(offsetX, offsetY);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<GestureDragDragUpdateEvent> get afterDragUpdate {
    int signalId;
    StreamController<GestureDragDragUpdateEvent> controller;
    controller = new StreamController<GestureDragDragUpdateEvent>(
      onListen: () {
          signalId = _connectToDragUpdate(true, (num offsetX, num offsetY) {
              var result = new GestureDragDragUpdateEvent(offsetX, offsetY);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class GestureDragDragBeginEvent {
  final num startX;
  final num startY;

  GestureDragDragBeginEvent(this.startX, this.startY);
}

class GestureDragDragEndEvent {
  final num offsetX;
  final num offsetY;

  GestureDragDragEndEvent(this.offsetX, this.offsetY);
}

class GestureDragDragUpdateEvent {
  final num offsetX;
  final num offsetY;

  GestureDragDragUpdateEvent(this.offsetX, this.offsetY);
}

class GestureLongPress extends GestureSingle {
  GestureLongPress.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'GestureLongPress');

  num get delayFactor => _staticInfo.getGPropertyOnReceiver('delay-factor', this);
  void set delayFactor(num value) => _staticInfo.setGPropertyOnReceiver('delay-factor', this, value);
  static const String DELAY_FACTOR_PROPERTY = 'delay-factor';
  factory GestureLongPress(Widget widget) => _staticInfo.callStatic('new', [widget]);
  int _connectToCancelled(bool after, void func()) => signalConnect('cancelled', func, after);
  Stream get onCancelled {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCancelled(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterCancelled {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCancelled(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPressed(bool after, void func(num x, num y)) => signalConnect('pressed', func, after);
  Stream<GestureLongPressPressedEvent> get onPressed {
    int signalId;
    StreamController<GestureLongPressPressedEvent> controller;
    controller = new StreamController<GestureLongPressPressedEvent>(
      onListen: () {
          signalId = _connectToPressed(false, (num x, num y) {
              var result = new GestureLongPressPressedEvent(x, y);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<GestureLongPressPressedEvent> get afterPressed {
    int signalId;
    StreamController<GestureLongPressPressedEvent> controller;
    controller = new StreamController<GestureLongPressPressedEvent>(
      onListen: () {
          signalId = _connectToPressed(true, (num x, num y) {
              var result = new GestureLongPressPressedEvent(x, y);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class GestureLongPressPressedEvent {
  final num x;
  final num y;

  GestureLongPressPressedEvent(this.x, this.y);
}

class GestureMultiPress extends GestureSingle {
  GestureMultiPress.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'GestureMultiPress');

  factory GestureMultiPress(Widget widget) => _staticInfo.callStatic('new', [widget]);
  bool getArea() => _staticInfo.callMethodOnReceiver('get_area', this, []);
  void setArea(RectangleInt rect) => _staticInfo.callMethodOnReceiver('set_area', this, [rect]);
  int _connectToPressed(bool after, void func(int nPress, num x, num y)) => signalConnect('pressed', func, after);
  Stream<GestureMultiPressPressedEvent> get onPressed {
    int signalId;
    StreamController<GestureMultiPressPressedEvent> controller;
    controller = new StreamController<GestureMultiPressPressedEvent>(
      onListen: () {
          signalId = _connectToPressed(false, (int nPress, num x, num y) {
              var result = new GestureMultiPressPressedEvent(nPress, x, y);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<GestureMultiPressPressedEvent> get afterPressed {
    int signalId;
    StreamController<GestureMultiPressPressedEvent> controller;
    controller = new StreamController<GestureMultiPressPressedEvent>(
      onListen: () {
          signalId = _connectToPressed(true, (int nPress, num x, num y) {
              var result = new GestureMultiPressPressedEvent(nPress, x, y);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToReleased(bool after, void func(int nPress, num x, num y)) => signalConnect('released', func, after);
  Stream<GestureMultiPressReleasedEvent> get onReleased {
    int signalId;
    StreamController<GestureMultiPressReleasedEvent> controller;
    controller = new StreamController<GestureMultiPressReleasedEvent>(
      onListen: () {
          signalId = _connectToReleased(false, (int nPress, num x, num y) {
              var result = new GestureMultiPressReleasedEvent(nPress, x, y);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<GestureMultiPressReleasedEvent> get afterReleased {
    int signalId;
    StreamController<GestureMultiPressReleasedEvent> controller;
    controller = new StreamController<GestureMultiPressReleasedEvent>(
      onListen: () {
          signalId = _connectToReleased(true, (int nPress, num x, num y) {
              var result = new GestureMultiPressReleasedEvent(nPress, x, y);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToStopped(bool after, void func()) => signalConnect('stopped', func, after);
  Stream get onStopped {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToStopped(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterStopped {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToStopped(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class GestureMultiPressPressedEvent {
  final int nPress;
  final num x;
  final num y;

  GestureMultiPressPressedEvent(this.nPress, this.x, this.y);
}

class GestureMultiPressReleasedEvent {
  final int nPress;
  final num x;
  final num y;

  GestureMultiPressReleasedEvent(this.nPress, this.x, this.y);
}

class GesturePan extends GestureDrag {
  GesturePan.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'GesturePan');

  static const String ORIENTATION_PROPERTY = 'orientation';
  factory GesturePan(Widget widget, Orientation orientation) => _staticInfo.callStatic('new', [widget, orientation]);
  Orientation get orientation => _staticInfo.callMethodOnReceiver('get_orientation', this, []);
  void set orientation(Orientation orientation) => _staticInfo.callMethodOnReceiver('set_orientation', this, [orientation]);
  int _connectToPan(bool after, void func(PanDirection direction, num offset)) => signalConnect('pan', func, after);
  Stream<GesturePanPanEvent> get onPan {
    int signalId;
    StreamController<GesturePanPanEvent> controller;
    controller = new StreamController<GesturePanPanEvent>(
      onListen: () {
          signalId = _connectToPan(false, (PanDirection direction, num offset) {
              var result = new GesturePanPanEvent(direction, offset);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<GesturePanPanEvent> get afterPan {
    int signalId;
    StreamController<GesturePanPanEvent> controller;
    controller = new StreamController<GesturePanPanEvent>(
      onListen: () {
          signalId = _connectToPan(true, (PanDirection direction, num offset) {
              var result = new GesturePanPanEvent(direction, offset);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class GesturePanPanEvent {
  final PanDirection direction;
  final num offset;

  GesturePanPanEvent(this.direction, this.offset);
}

class GestureRotate extends Gesture {
  GestureRotate.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'GestureRotate');

  factory GestureRotate(Widget widget) => _staticInfo.callStatic('new', [widget]);
  num getAngleDelta() => _staticInfo.callMethodOnReceiver('get_angle_delta', this, []);
  int _connectToAngleChanged(bool after, void func(num angle, num angleDelta)) => signalConnect('angle-changed', func, after);
  Stream<GestureRotateAngleChangedEvent> get onAngleChanged {
    int signalId;
    StreamController<GestureRotateAngleChangedEvent> controller;
    controller = new StreamController<GestureRotateAngleChangedEvent>(
      onListen: () {
          signalId = _connectToAngleChanged(false, (num angle, num angleDelta) {
              var result = new GestureRotateAngleChangedEvent(angle, angleDelta);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<GestureRotateAngleChangedEvent> get afterAngleChanged {
    int signalId;
    StreamController<GestureRotateAngleChangedEvent> controller;
    controller = new StreamController<GestureRotateAngleChangedEvent>(
      onListen: () {
          signalId = _connectToAngleChanged(true, (num angle, num angleDelta) {
              var result = new GestureRotateAngleChangedEvent(angle, angleDelta);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class GestureRotateAngleChangedEvent {
  final num angle;
  final num angleDelta;

  GestureRotateAngleChangedEvent(this.angle, this.angleDelta);
}

class GestureSingle extends Gesture {
  GestureSingle.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'GestureSingle');

  static const String BUTTON_PROPERTY = 'button';
  static const String EXCLUSIVE_PROPERTY = 'exclusive';
  static const String TOUCH_ONLY_PROPERTY = 'touch-only';
  int get button => _staticInfo.callMethodOnReceiver('get_button', this, []);
  int getCurrentButton() => _staticInfo.callMethodOnReceiver('get_current_button', this, []);
  EventSequence getCurrentSequence() => _staticInfo.callMethodOnReceiver('get_current_sequence', this, []);
  bool get exclusive => _staticInfo.callMethodOnReceiver('get_exclusive', this, []);
  bool get touchOnly => _staticInfo.callMethodOnReceiver('get_touch_only', this, []);
  void set button(int button) => _staticInfo.callMethodOnReceiver('set_button', this, [button]);
  void set exclusive(bool exclusive) => _staticInfo.callMethodOnReceiver('set_exclusive', this, [exclusive]);
  void set touchOnly(bool touchOnly) => _staticInfo.callMethodOnReceiver('set_touch_only', this, [touchOnly]);
}

class GestureSwipe extends GestureSingle {
  GestureSwipe.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'GestureSwipe');

  factory GestureSwipe(Widget widget) => _staticInfo.callStatic('new', [widget]);
  bool getVelocity() => _staticInfo.callMethodOnReceiver('get_velocity', this, []);
  int _connectToSwipe(bool after, void func(num velocityX, num velocityY)) => signalConnect('swipe', func, after);
  Stream<GestureSwipeSwipeEvent> get onSwipe {
    int signalId;
    StreamController<GestureSwipeSwipeEvent> controller;
    controller = new StreamController<GestureSwipeSwipeEvent>(
      onListen: () {
          signalId = _connectToSwipe(false, (num velocityX, num velocityY) {
              var result = new GestureSwipeSwipeEvent(velocityX, velocityY);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<GestureSwipeSwipeEvent> get afterSwipe {
    int signalId;
    StreamController<GestureSwipeSwipeEvent> controller;
    controller = new StreamController<GestureSwipeSwipeEvent>(
      onListen: () {
          signalId = _connectToSwipe(true, (num velocityX, num velocityY) {
              var result = new GestureSwipeSwipeEvent(velocityX, velocityY);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class GestureSwipeSwipeEvent {
  final num velocityX;
  final num velocityY;

  GestureSwipeSwipeEvent(this.velocityX, this.velocityY);
}

class GestureZoom extends Gesture {
  GestureZoom.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'GestureZoom');

  factory GestureZoom(Widget widget) => _staticInfo.callStatic('new', [widget]);
  num getScaleDelta() => _staticInfo.callMethodOnReceiver('get_scale_delta', this, []);
  int _connectToScaleChanged(bool after, void func(num scale)) => signalConnect('scale-changed', func, after);
  Stream<num> get onScaleChanged {
    int signalId;
    StreamController<num> controller;
    controller = new StreamController<num>(
      onListen: () {
          signalId = _connectToScaleChanged(false, (num scale) {
              controller.add(scale);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<num> get afterScaleChanged {
    int signalId;
    StreamController<num> controller;
    controller = new StreamController<num>(
      onListen: () {
          signalId = _connectToScaleChanged(true, (num scale) {
              controller.add(scale);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class Gradient extends GObjectBase {
  Gradient.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Gradient');

  factory Gradient.linear(num x0, num y0, num x1, num y1) => _staticInfo.callStatic('new_linear', [x0, y0, x1, y1]);
  factory Gradient.radial(num x0, num y0, num radius0, num x1, num y1, num radius1) => _staticInfo.callStatic('new_radial', [x0, y0, radius0, x1, y1, radius1]);
  void addColorStop(num offset, SymbolicColor color) => _staticInfo.callMethodOnReceiver('add_color_stop', this, [offset, color]);
  Gradient ref() => _staticInfo.callMethodOnReceiver('ref', this, []);
  bool resolve(StyleProperties props) => _staticInfo.callMethodOnReceiver('resolve', this, [props]);
  CairoPattern resolveForContext(StyleContext context) => _staticInfo.callMethodOnReceiver('resolve_for_context', this, [context]);
  String toString() => _staticInfo.callMethodOnReceiver('to_string', this, []);
  void unref() => _staticInfo.callMethodOnReceiver('unref', this, []);
}

class Grid extends Container with ImplementorIface, Buildable, Orientable {
  Grid.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Grid');

  static const String BASELINE_ROW_PROPERTY = 'baseline-row';
  static const String COLUMN_HOMOGENEOUS_PROPERTY = 'column-homogeneous';
  static const String COLUMN_SPACING_PROPERTY = 'column-spacing';
  static const String ROW_HOMOGENEOUS_PROPERTY = 'row-homogeneous';
  static const String ROW_SPACING_PROPERTY = 'row-spacing';
  factory Grid() => _staticInfo.callStatic('new', []);
  void attach(Widget child, int left, int top, int width, int height) => _staticInfo.callMethodOnReceiver('attach', this, [child, left, top, width, height]);
  void attachNextTo(Widget child, Widget sibling, PositionType side, int width, int height) => _staticInfo.callMethodOnReceiver('attach_next_to', this, [child, sibling, side, width, height]);
  int get baselineRow => _staticInfo.callMethodOnReceiver('get_baseline_row', this, []);
  Widget getChildAt(int left, int top) => _staticInfo.callMethodOnReceiver('get_child_at', this, [left, top]);
  bool get columnHomogeneous => _staticInfo.callMethodOnReceiver('get_column_homogeneous', this, []);
  int get columnSpacing => _staticInfo.callMethodOnReceiver('get_column_spacing', this, []);
  BaselinePosition getRowBaselinePosition(int row) => _staticInfo.callMethodOnReceiver('get_row_baseline_position', this, [row]);
  bool get rowHomogeneous => _staticInfo.callMethodOnReceiver('get_row_homogeneous', this, []);
  int get rowSpacing => _staticInfo.callMethodOnReceiver('get_row_spacing', this, []);
  void insertColumn(int position) => _staticInfo.callMethodOnReceiver('insert_column', this, [position]);
  void insertNextTo(Widget sibling, PositionType side) => _staticInfo.callMethodOnReceiver('insert_next_to', this, [sibling, side]);
  void insertRow(int position) => _staticInfo.callMethodOnReceiver('insert_row', this, [position]);
  void removeColumn(int position) => _staticInfo.callMethodOnReceiver('remove_column', this, [position]);
  void removeRow(int position) => _staticInfo.callMethodOnReceiver('remove_row', this, [position]);
  void set baselineRow(int row) => _staticInfo.callMethodOnReceiver('set_baseline_row', this, [row]);
  void set columnHomogeneous(bool homogeneous) => _staticInfo.callMethodOnReceiver('set_column_homogeneous', this, [homogeneous]);
  void set columnSpacing(int spacing) => _staticInfo.callMethodOnReceiver('set_column_spacing', this, [spacing]);
  void setRowBaselinePosition(int row, BaselinePosition pos) => _staticInfo.callMethodOnReceiver('set_row_baseline_position', this, [row, pos]);
  void set rowHomogeneous(bool homogeneous) => _staticInfo.callMethodOnReceiver('set_row_homogeneous', this, [homogeneous]);
  void set rowSpacing(int spacing) => _staticInfo.callMethodOnReceiver('set_row_spacing', this, [spacing]);
}

class HBox extends Box with ImplementorIface, Buildable, Orientable {
  HBox.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'HBox');

  factory HBox(bool homogeneous, int spacing) => _staticInfo.callStatic('new', [homogeneous, spacing]);
}

class HButtonBox extends ButtonBox with ImplementorIface, Buildable, Orientable {
  HButtonBox.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'HButtonBox');

  factory HButtonBox() => _staticInfo.callStatic('new', []);
}

class HPaned extends Paned with ImplementorIface, Buildable, Orientable {
  HPaned.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'HPaned');

  factory HPaned() => _staticInfo.callStatic('new', []);
}

class HSV extends Widget with ImplementorIface, Buildable {
  HSV.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'HSV');

  factory HSV() => _staticInfo.callStatic('new', []);
  static void toRgb(num h, num s, num v) => _staticInfo.callStatic('to_rgb', [h, s, v]);
  void getColor() => _staticInfo.callMethodOnReceiver('get_color', this, []);
  void getMetrics() => _staticInfo.callMethodOnReceiver('get_metrics', this, []);
  bool isAdjusting() => _staticInfo.callMethodOnReceiver('is_adjusting', this, []);
  void setColor(num h, num s, num v) => _staticInfo.callMethodOnReceiver('set_color', this, [h, s, v]);
  void setMetrics(int size, int ringWidth) => _staticInfo.callMethodOnReceiver('set_metrics', this, [size, ringWidth]);
  int _connectToChanged(bool after, void func()) => signalConnect('changed', func, after);
  Stream get onChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMove(bool after, void func(DirectionType object)) => signalConnect('move', func, after);
  Stream<DirectionType> get onMove {
    int signalId;
    StreamController<DirectionType> controller;
    controller = new StreamController<DirectionType>(
      onListen: () {
          signalId = _connectToMove(false, (DirectionType object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<DirectionType> get afterMove {
    int signalId;
    StreamController<DirectionType> controller;
    controller = new StreamController<DirectionType>(
      onListen: () {
          signalId = _connectToMove(true, (DirectionType object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class HScale extends Scale with ImplementorIface, Buildable, Orientable {
  HScale.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'HScale');

  factory HScale(Adjustment adjustment) => _staticInfo.callStatic('new', [adjustment]);
  factory HScale.withRange(num min, num max, num step) => _staticInfo.callStatic('new_with_range', [min, max, step]);
}

class HScrollbar extends Scrollbar with ImplementorIface, Buildable, Orientable {
  HScrollbar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'HScrollbar');

  factory HScrollbar(Adjustment adjustment) => _staticInfo.callStatic('new', [adjustment]);
}

class HSeparator extends Separator with ImplementorIface, Buildable, Orientable {
  HSeparator.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'HSeparator');

  factory HSeparator() => _staticInfo.callStatic('new', []);
}

class HandleBox extends Bin with ImplementorIface, Buildable {
  HandleBox.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'HandleBox');

  static const String CHILD_DETACHED_PROPERTY = 'child-detached';
  static const String HANDLE_POSITION_PROPERTY = 'handle-position';
  static const String SHADOW_TYPE_PROPERTY = 'shadow-type';
  static const String SNAP_EDGE_PROPERTY = 'snap-edge';
  bool get snapEdgeSet => _staticInfo.getGPropertyOnReceiver('snap-edge-set', this);
  void set snapEdgeSet(bool value) => _staticInfo.setGPropertyOnReceiver('snap-edge-set', this, value);
  static const String SNAP_EDGE_SET_PROPERTY = 'snap-edge-set';
  factory HandleBox() => _staticInfo.callStatic('new', []);
  bool get childDetached => _staticInfo.callMethodOnReceiver('get_child_detached', this, []);
  PositionType get handlePosition => _staticInfo.callMethodOnReceiver('get_handle_position', this, []);
  ShadowType get shadowType => _staticInfo.callMethodOnReceiver('get_shadow_type', this, []);
  PositionType get snapEdge => _staticInfo.callMethodOnReceiver('get_snap_edge', this, []);
  void set handlePosition(PositionType position) => _staticInfo.callMethodOnReceiver('set_handle_position', this, [position]);
  void set shadowType(ShadowType type) => _staticInfo.callMethodOnReceiver('set_shadow_type', this, [type]);
  void set snapEdge(PositionType edge) => _staticInfo.callMethodOnReceiver('set_snap_edge', this, [edge]);
  int _connectToChildAttached(bool after, void func(Widget widget)) => signalConnect('child-attached', func, after);
  Stream<Widget> get onChildAttached {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToChildAttached(false, (Widget widget) {
              controller.add(widget);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Widget> get afterChildAttached {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToChildAttached(true, (Widget widget) {
              controller.add(widget);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToChildDetached(bool after, void func(Widget widget)) => signalConnect('child-detached', func, after);
  Stream<Widget> get onChildDetached {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToChildDetached(false, (Widget widget) {
              controller.add(widget);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Widget> get afterChildDetached {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToChildDetached(true, (Widget widget) {
              controller.add(widget);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class HeaderBar extends Container with ImplementorIface, Buildable {
  HeaderBar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'HeaderBar');

  static const String CUSTOM_TITLE_PROPERTY = 'custom-title';
  static const String DECORATION_LAYOUT_PROPERTY = 'decoration-layout';
  bool get decorationLayoutSet => _staticInfo.getGPropertyOnReceiver('decoration-layout-set', this);
  void set decorationLayoutSet(bool value) => _staticInfo.setGPropertyOnReceiver('decoration-layout-set', this, value);
  static const String DECORATION_LAYOUT_SET_PROPERTY = 'decoration-layout-set';
  static const String HAS_SUBTITLE_PROPERTY = 'has-subtitle';
  static const String SHOW_CLOSE_BUTTON_PROPERTY = 'show-close-button';
  int get spacing => _staticInfo.getGPropertyOnReceiver('spacing', this);
  void set spacing(int value) => _staticInfo.setGPropertyOnReceiver('spacing', this, value);
  static const String SPACING_PROPERTY = 'spacing';
  static const String SUBTITLE_PROPERTY = 'subtitle';
  static const String TITLE_PROPERTY = 'title';
  factory HeaderBar() => _staticInfo.callStatic('new', []);
  Widget get customTitle => _staticInfo.callMethodOnReceiver('get_custom_title', this, []);
  String get decorationLayout => _staticInfo.callMethodOnReceiver('get_decoration_layout', this, []);
  bool get hasSubtitle => _staticInfo.callMethodOnReceiver('get_has_subtitle', this, []);
  bool get showCloseButton => _staticInfo.callMethodOnReceiver('get_show_close_button', this, []);
  String get subtitle => _staticInfo.callMethodOnReceiver('get_subtitle', this, []);
  String get title => _staticInfo.callMethodOnReceiver('get_title', this, []);
  void packEnd(Widget child) => _staticInfo.callMethodOnReceiver('pack_end', this, [child]);
  void packStart(Widget child) => _staticInfo.callMethodOnReceiver('pack_start', this, [child]);
  void set customTitle(Widget titleWidget) => _staticInfo.callMethodOnReceiver('set_custom_title', this, [titleWidget]);
  void set decorationLayout(String layout) => _staticInfo.callMethodOnReceiver('set_decoration_layout', this, [layout]);
  void set hasSubtitle(bool setting) => _staticInfo.callMethodOnReceiver('set_has_subtitle', this, [setting]);
  void set showCloseButton(bool setting) => _staticInfo.callMethodOnReceiver('set_show_close_button', this, [setting]);
  void set subtitle(String subtitle) => _staticInfo.callMethodOnReceiver('set_subtitle', this, [subtitle]);
  void set title(String title) => _staticInfo.callMethodOnReceiver('set_title', this, [title]);
}

class HeaderBarPrivate extends GObjectBase {
  HeaderBarPrivate.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'HeaderBarPrivate');

}

class IMContext extends GObjectObject {
  IMContext.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IMContext');

  InputHints get inputHints => _staticInfo.getGPropertyOnReceiver('input-hints', this);
  void set inputHints(InputHints value) => _staticInfo.setGPropertyOnReceiver('input-hints', this, value);
  static const String INPUT_HINTS_PROPERTY = 'input-hints';
  InputPurpose get inputPurpose => _staticInfo.getGPropertyOnReceiver('input-purpose', this);
  void set inputPurpose(InputPurpose value) => _staticInfo.setGPropertyOnReceiver('input-purpose', this, value);
  static const String INPUT_PURPOSE_PROPERTY = 'input-purpose';
  bool deleteSurrounding(int offset, int nChars) => _staticInfo.callMethodOnReceiver('delete_surrounding', this, [offset, nChars]);
  bool filterKeypress(EventKey event) => _staticInfo.callMethodOnReceiver('filter_keypress', this, [event]);
  void focusIn() => _staticInfo.callMethodOnReceiver('focus_in', this, []);
  void focusOut() => _staticInfo.callMethodOnReceiver('focus_out', this, []);
  void getPreeditString() => _staticInfo.callMethodOnReceiver('get_preedit_string', this, []);
  bool getSurrounding() => _staticInfo.callMethodOnReceiver('get_surrounding', this, []);
  void reset() => _staticInfo.callMethodOnReceiver('reset', this, []);
  void setClientWindow(gdk.Window window) => _staticInfo.callMethodOnReceiver('set_client_window', this, [window]);
  void setCursorLocation(RectangleInt area) => _staticInfo.callMethodOnReceiver('set_cursor_location', this, [area]);
  void setSurrounding(String text, int len, int cursorIndex) => _staticInfo.callMethodOnReceiver('set_surrounding', this, [text, len, cursorIndex]);
  void setUsePreedit(bool usePreedit) => _staticInfo.callMethodOnReceiver('set_use_preedit', this, [usePreedit]);
  int _connectToCommit(bool after, void func(String str)) => signalConnect('commit', func, after);
  Stream<String> get onCommit {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToCommit(false, (String str) {
              controller.add(str);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<String> get afterCommit {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToCommit(true, (String str) {
              controller.add(str);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDeleteSurrounding(bool after, bool func(int offset, int nChars)) => signalConnect('delete-surrounding', func, after);
  Stream<IMContextDeleteSurroundingEvent> get onDeleteSurrounding {
    int signalId;
    StreamController<IMContextDeleteSurroundingEvent> controller;
    controller = new StreamController<IMContextDeleteSurroundingEvent>(
      onListen: () {
          signalId = _connectToDeleteSurrounding(false, (int offset, int nChars) {
              var result = new IMContextDeleteSurroundingEvent(offset, nChars);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<IMContextDeleteSurroundingEvent> get afterDeleteSurrounding {
    int signalId;
    StreamController<IMContextDeleteSurroundingEvent> controller;
    controller = new StreamController<IMContextDeleteSurroundingEvent>(
      onListen: () {
          signalId = _connectToDeleteSurrounding(true, (int offset, int nChars) {
              var result = new IMContextDeleteSurroundingEvent(offset, nChars);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPreeditChanged(bool after, void func()) => signalConnect('preedit-changed', func, after);
  Stream get onPreeditChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPreeditChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPreeditChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPreeditChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPreeditEnd(bool after, void func()) => signalConnect('preedit-end', func, after);
  Stream get onPreeditEnd {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPreeditEnd(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPreeditEnd {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPreeditEnd(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPreeditStart(bool after, void func()) => signalConnect('preedit-start', func, after);
  Stream get onPreeditStart {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPreeditStart(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPreeditStart {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPreeditStart(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRetrieveSurrounding(bool after, bool func()) => signalConnect('retrieve-surrounding', func, after);
  Stream<IMContextRetrieveSurroundingEvent> get onRetrieveSurrounding {
    int signalId;
    StreamController<IMContextRetrieveSurroundingEvent> controller;
    controller = new StreamController<IMContextRetrieveSurroundingEvent>(
      onListen: () {
          signalId = _connectToRetrieveSurrounding(false, () {
              var result = new IMContextRetrieveSurroundingEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<IMContextRetrieveSurroundingEvent> get afterRetrieveSurrounding {
    int signalId;
    StreamController<IMContextRetrieveSurroundingEvent> controller;
    controller = new StreamController<IMContextRetrieveSurroundingEvent>(
      onListen: () {
          signalId = _connectToRetrieveSurrounding(true, () {
              var result = new IMContextRetrieveSurroundingEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class IMContextDeleteSurroundingEvent {
  final int offset;
  final int nChars;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  IMContextDeleteSurroundingEvent(this.offset, this.nChars);
}

class IMContextRetrieveSurroundingEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  IMContextRetrieveSurroundingEvent();
}

class IMContextInfo extends GObjectBase {
  IMContextInfo.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IMContextInfo');

  String get contextId => getFieldOfObject('context_id', 0);
  void set contextId(String value) => setFieldOfObject('context_id', 0, value);
  String get contextName => getFieldOfObject('context_name', 1);
  void set contextName(String value) => setFieldOfObject('context_name', 1, value);
  String get domain => getFieldOfObject('domain', 2);
  void set domain(String value) => setFieldOfObject('domain', 2, value);
  String get domainDirname => getFieldOfObject('domain_dirname', 3);
  void set domainDirname(String value) => setFieldOfObject('domain_dirname', 3, value);
  String get defaultLocales => getFieldOfObject('default_locales', 4);
  void set defaultLocales(String value) => setFieldOfObject('default_locales', 4, value);
}

class IMContextSimple extends IMContext {
  IMContextSimple.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IMContextSimple');

  factory IMContextSimple() => _staticInfo.callStatic('new', []);
}

class IMMulticontext extends IMContext {
  IMMulticontext.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IMMulticontext');

  factory IMMulticontext() => _staticInfo.callStatic('new', []);
  void appendMenuitems(MenuShell menushell) => _staticInfo.callMethodOnReceiver('append_menuitems', this, [menushell]);
  String getContextId() => _staticInfo.callMethodOnReceiver('get_context_id', this, []);
  void setContextId(String contextId) => _staticInfo.callMethodOnReceiver('set_context_id', this, [contextId]);
}

class IMPreeditStyle extends GEnumBase {
  const IMPreeditStyle(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IMPreeditStyle');

  static const IMPreeditStyle NOTHING = const IMPreeditStyle(0);
  static const IMPreeditStyle CALLBACK = const IMPreeditStyle(1);
  static const IMPreeditStyle NONE = const IMPreeditStyle(2);
  String toString() {
    switch(index) {
      case 0: return 'IMPreeditStyle.NOTHING';
      case 1: return 'IMPreeditStyle.CALLBACK';
      case 2: return 'IMPreeditStyle.NONE';
      default: return 'new IMPreeditStyle($index)';
    }
  }
}

class IMStatusStyle extends GEnumBase {
  const IMStatusStyle(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IMStatusStyle');

  static const IMStatusStyle NOTHING = const IMStatusStyle(0);
  static const IMStatusStyle CALLBACK = const IMStatusStyle(1);
  static const IMStatusStyle NONE = const IMStatusStyle(2);
  String toString() {
    switch(index) {
      case 0: return 'IMStatusStyle.NOTHING';
      case 1: return 'IMStatusStyle.CALLBACK';
      case 2: return 'IMStatusStyle.NONE';
      default: return 'new IMStatusStyle($index)';
    }
  }
}

class IconFactory extends GObjectObject with Buildable {
  IconFactory.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IconFactory');

  factory IconFactory() => _staticInfo.callStatic('new', []);
  static IconSet lookupDefault(String stockId) => _staticInfo.callStatic('lookup_default', [stockId]);
  void add(String stockId, IconSet iconSet) => _staticInfo.callMethodOnReceiver('add', this, [stockId, iconSet]);
  void addDefault() => _staticInfo.callMethodOnReceiver('add_default', this, []);
  IconSet lookup(String stockId) => _staticInfo.callMethodOnReceiver('lookup', this, [stockId]);
  void removeDefault() => _staticInfo.callMethodOnReceiver('remove_default', this, []);
}

class IconInfo extends GObjectObject {
  IconInfo.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IconInfo');

  factory IconInfo.forPixbuf(IconTheme iconTheme, Pixbuf pixbuf) => _staticInfo.callStatic('new_for_pixbuf', [iconTheme, pixbuf]);
  bool getAttachPoints() => _staticInfo.callMethodOnReceiver('get_attach_points', this, []);
  int getBaseScale() => _staticInfo.callMethodOnReceiver('get_base_scale', this, []);
  int getBaseSize() => _staticInfo.callMethodOnReceiver('get_base_size', this, []);
  Pixbuf getBuiltinPixbuf() => _staticInfo.callMethodOnReceiver('get_builtin_pixbuf', this, []);
  String getDisplayName() => _staticInfo.callMethodOnReceiver('get_display_name', this, []);
  bool getEmbeddedRect() => _staticInfo.callMethodOnReceiver('get_embedded_rect', this, []);
  String getFilename() => _staticInfo.callMethodOnReceiver('get_filename', this, []);
  bool isSymbolic() => _staticInfo.callMethodOnReceiver('is_symbolic', this, []);
  Pixbuf loadIcon() => _staticInfo.callMethodOnReceiver('load_icon', this, []);
  void loadIconAsync(Cancellable cancellable, AsyncReadyCallback callback) => _staticInfo.callMethodOnReceiver('load_icon_async', this, [cancellable, callback]);
  Pixbuf loadIconFinish(AsyncResult res) => _staticInfo.callMethodOnReceiver('load_icon_finish', this, [res]);
  Surface loadSurface(gdk.Window forWindow) => _staticInfo.callMethodOnReceiver('load_surface', this, [forWindow]);
  Pixbuf loadSymbolic(RGBA fg, RGBA successColor, RGBA warningColor, RGBA errorColor) => _staticInfo.callMethodOnReceiver('load_symbolic', this, [fg, successColor, warningColor, errorColor]);
  void loadSymbolicAsync(RGBA fg, RGBA successColor, RGBA warningColor, RGBA errorColor, Cancellable cancellable, AsyncReadyCallback callback) => _staticInfo.callMethodOnReceiver('load_symbolic_async', this, [fg, successColor, warningColor, errorColor, cancellable, callback]);
  Pixbuf loadSymbolicFinish(AsyncResult res) => _staticInfo.callMethodOnReceiver('load_symbolic_finish', this, [res]);
  Pixbuf loadSymbolicForContext(StyleContext context) => _staticInfo.callMethodOnReceiver('load_symbolic_for_context', this, [context]);
  void loadSymbolicForContextAsync(StyleContext context, Cancellable cancellable, AsyncReadyCallback callback) => _staticInfo.callMethodOnReceiver('load_symbolic_for_context_async', this, [context, cancellable, callback]);
  Pixbuf loadSymbolicForContextFinish(AsyncResult res) => _staticInfo.callMethodOnReceiver('load_symbolic_for_context_finish', this, [res]);
  Pixbuf loadSymbolicForStyle(Style style, StateType state) => _staticInfo.callMethodOnReceiver('load_symbolic_for_style', this, [style, state]);
  void setRawCoordinates(bool rawCoordinates) => _staticInfo.callMethodOnReceiver('set_raw_coordinates', this, [rawCoordinates]);
}

class IconLookupFlags extends GEnumBase {
  const IconLookupFlags(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IconLookupFlags');

  static const IconLookupFlags NULL = const IconLookupFlags(0);
  static const IconLookupFlags NO_SVG = const IconLookupFlags(1);
  bool get noSvg => (index & 1) == 1;
  static const IconLookupFlags FORCE_SVG = const IconLookupFlags(2);
  bool get forceSvg => (index & 2) == 2;
  static const IconLookupFlags USE_BUILTIN = const IconLookupFlags(4);
  bool get useBuiltin => (index & 4) == 4;
  static const IconLookupFlags GENERIC_FALLBACK = const IconLookupFlags(8);
  bool get genericFallback => (index & 8) == 8;
  static const IconLookupFlags FORCE_SIZE = const IconLookupFlags(16);
  bool get forceSize => (index & 16) == 16;
  static const IconLookupFlags FORCE_REGULAR = const IconLookupFlags(32);
  bool get forceRegular => (index & 32) == 32;
  static const IconLookupFlags FORCE_SYMBOLIC = const IconLookupFlags(64);
  bool get forceSymbolic => (index & 64) == 64;
  static const IconLookupFlags DIR_LTR = const IconLookupFlags(128);
  bool get dirLtr => (index & 128) == 128;
  static const IconLookupFlags DIR_RTL = const IconLookupFlags(256);
  bool get dirRtl => (index & 256) == 256;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'IconLookupFlags.NO_SVG';
      case 2: return 'IconLookupFlags.FORCE_SVG';
      case 4: return 'IconLookupFlags.USE_BUILTIN';
      case 8: return 'IconLookupFlags.GENERIC_FALLBACK';
      case 16: return 'IconLookupFlags.FORCE_SIZE';
      case 32: return 'IconLookupFlags.FORCE_REGULAR';
      case 64: return 'IconLookupFlags.FORCE_SYMBOLIC';
      case 128: return 'IconLookupFlags.DIR_LTR';
      default: return 'new IconLookupFlags($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'IconLookupFlags.NULL';
    }
    List codes = [];
    for (var i=1; i <= 256; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  IconLookupFlags operator|(IconLookupFlags other) =>
    new IconLookupFlags(index | other.index);
  IconLookupFlags operator&(IconLookupFlags other) =>
    new IconLookupFlags(index & other.index);
}

class IconSet extends GObjectBase {
  IconSet.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IconSet');

  factory IconSet() => _staticInfo.callStatic('new', []);
  factory IconSet.fromPixbuf(Pixbuf pixbuf) => _staticInfo.callStatic('new_from_pixbuf', [pixbuf]);
  void addSource(IconSource source) => _staticInfo.callMethodOnReceiver('add_source', this, [source]);
  IconSet copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void getSizes() => _staticInfo.callMethodOnReceiver('get_sizes', this, []);
  IconSet ref() => _staticInfo.callMethodOnReceiver('ref', this, []);
  Pixbuf renderIcon(Style style, TextDirection direction, StateType state, int size, Widget widget, String detail) => _staticInfo.callMethodOnReceiver('render_icon', this, [style, direction, state, size, widget, detail]);
  Pixbuf renderIconPixbuf(StyleContext context, int size) => _staticInfo.callMethodOnReceiver('render_icon_pixbuf', this, [context, size]);
  Surface renderIconSurface(StyleContext context, int size, int scale, gdk.Window forWindow) => _staticInfo.callMethodOnReceiver('render_icon_surface', this, [context, size, scale, forWindow]);
  void unref() => _staticInfo.callMethodOnReceiver('unref', this, []);
}

class IconSize extends GEnumBase {
  const IconSize(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IconSize');

  static const IconSize INVALID = const IconSize(0);
  static const IconSize MENU = const IconSize(1);
  static const IconSize SMALL_TOOLBAR = const IconSize(2);
  static const IconSize LARGE_TOOLBAR = const IconSize(3);
  static const IconSize BUTTON = const IconSize(4);
  static const IconSize DND = const IconSize(5);
  static const IconSize DIALOG = const IconSize(6);
  String toString() {
    switch(index) {
      case 0: return 'IconSize.INVALID';
      case 1: return 'IconSize.MENU';
      case 2: return 'IconSize.SMALL_TOOLBAR';
      case 3: return 'IconSize.LARGE_TOOLBAR';
      case 4: return 'IconSize.BUTTON';
      case 5: return 'IconSize.DND';
      case 6: return 'IconSize.DIALOG';
      default: return 'new IconSize($index)';
    }
  }
  static int fromName(String name) => _staticInfo.callStatic('from_name', [name]);
  static String getName(int size) => _staticInfo.callStatic('get_name', [size]);
  static bool lookup(int size) => _staticInfo.callStatic('lookup', [size]);
  static bool lookupForSettings(Settings settings, int size) => _staticInfo.callStatic('lookup_for_settings', [settings, size]);
  static int register(String name, int width, int height) => _staticInfo.callStatic('register', [name, width, height]);
  static void registerAlias(String alias, int target) => _staticInfo.callStatic('register_alias', [alias, target]);
}

class IconSource extends GObjectBase {
  IconSource.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IconSource');

  factory IconSource() => _staticInfo.callStatic('new', []);
  IconSource copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void free() => _staticInfo.callMethodOnReceiver('free', this, []);
  TextDirection getDirection() => _staticInfo.callMethodOnReceiver('get_direction', this, []);
  bool getDirectionWildcarded() => _staticInfo.callMethodOnReceiver('get_direction_wildcarded', this, []);
  String getFilename() => _staticInfo.callMethodOnReceiver('get_filename', this, []);
  String getIconName() => _staticInfo.callMethodOnReceiver('get_icon_name', this, []);
  Pixbuf getPixbuf() => _staticInfo.callMethodOnReceiver('get_pixbuf', this, []);
  int getSize() => _staticInfo.callMethodOnReceiver('get_size', this, []);
  bool getSizeWildcarded() => _staticInfo.callMethodOnReceiver('get_size_wildcarded', this, []);
  StateType getState() => _staticInfo.callMethodOnReceiver('get_state', this, []);
  bool getStateWildcarded() => _staticInfo.callMethodOnReceiver('get_state_wildcarded', this, []);
  void setDirection(TextDirection direction) => _staticInfo.callMethodOnReceiver('set_direction', this, [direction]);
  void setDirectionWildcarded(bool setting) => _staticInfo.callMethodOnReceiver('set_direction_wildcarded', this, [setting]);
  void setFilename(String filename) => _staticInfo.callMethodOnReceiver('set_filename', this, [filename]);
  void setIconName(String iconName) => _staticInfo.callMethodOnReceiver('set_icon_name', this, [iconName]);
  void setPixbuf(Pixbuf pixbuf) => _staticInfo.callMethodOnReceiver('set_pixbuf', this, [pixbuf]);
  void setSize(int size) => _staticInfo.callMethodOnReceiver('set_size', this, [size]);
  void setSizeWildcarded(bool setting) => _staticInfo.callMethodOnReceiver('set_size_wildcarded', this, [setting]);
  void setState(StateType state) => _staticInfo.callMethodOnReceiver('set_state', this, [state]);
  void setStateWildcarded(bool setting) => _staticInfo.callMethodOnReceiver('set_state_wildcarded', this, [setting]);
}

class IconTheme extends GObjectObject {
  IconTheme.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IconTheme');

  factory IconTheme() => _staticInfo.callStatic('new', []);
  static void addBuiltinIcon(String iconName, int size, Pixbuf pixbuf) => _staticInfo.callStatic('add_builtin_icon', [iconName, size, pixbuf]);
  static IconTheme getDefault() => _staticInfo.callStatic('get_default', []);
  static IconTheme getForScreen(Screen screen) => _staticInfo.callStatic('get_for_screen', [screen]);
  void addResourcePath(String path) => _staticInfo.callMethodOnReceiver('add_resource_path', this, [path]);
  void appendSearchPath(String path) => _staticInfo.callMethodOnReceiver('append_search_path', this, [path]);
  IconInfo chooseIcon(List<String> iconNames, int size, IconLookupFlags flags) => _staticInfo.callMethodOnReceiver('choose_icon', this, [iconNames, size, flags]);
  IconInfo chooseIconForScale(List<String> iconNames, int size, int scale, IconLookupFlags flags) => _staticInfo.callMethodOnReceiver('choose_icon_for_scale', this, [iconNames, size, scale, flags]);
  String getExampleIconName() => _staticInfo.callMethodOnReceiver('get_example_icon_name', this, []);
  List<int> getIconSizes(String iconName) => _staticInfo.callMethodOnReceiver('get_icon_sizes', this, [iconName]);
  void getSearchPath() => _staticInfo.callMethodOnReceiver('get_search_path', this, []);
  bool hasIcon(String iconName) => _staticInfo.callMethodOnReceiver('has_icon', this, [iconName]);
  GLibList /* this will fail */ listContexts() => _staticInfo.callMethodOnReceiver('list_contexts', this, []);
  GLibList /* this will fail */ listIcons(String context) => _staticInfo.callMethodOnReceiver('list_icons', this, [context]);
  Pixbuf loadIcon(String iconName, int size, IconLookupFlags flags) => _staticInfo.callMethodOnReceiver('load_icon', this, [iconName, size, flags]);
  Pixbuf loadIconForScale(String iconName, int size, int scale, IconLookupFlags flags) => _staticInfo.callMethodOnReceiver('load_icon_for_scale', this, [iconName, size, scale, flags]);
  Surface loadSurface(String iconName, int size, int scale, gdk.Window forWindow, IconLookupFlags flags) => _staticInfo.callMethodOnReceiver('load_surface', this, [iconName, size, scale, forWindow, flags]);
  IconInfo lookupByGicon(Icon icon, int size, IconLookupFlags flags) => _staticInfo.callMethodOnReceiver('lookup_by_gicon', this, [icon, size, flags]);
  IconInfo lookupByGiconForScale(Icon icon, int size, int scale, IconLookupFlags flags) => _staticInfo.callMethodOnReceiver('lookup_by_gicon_for_scale', this, [icon, size, scale, flags]);
  IconInfo lookupIcon(String iconName, int size, IconLookupFlags flags) => _staticInfo.callMethodOnReceiver('lookup_icon', this, [iconName, size, flags]);
  IconInfo lookupIconForScale(String iconName, int size, int scale, IconLookupFlags flags) => _staticInfo.callMethodOnReceiver('lookup_icon_for_scale', this, [iconName, size, scale, flags]);
  void prependSearchPath(String path) => _staticInfo.callMethodOnReceiver('prepend_search_path', this, [path]);
  bool rescanIfNeeded() => _staticInfo.callMethodOnReceiver('rescan_if_needed', this, []);
  void setCustomTheme(String themeName) => _staticInfo.callMethodOnReceiver('set_custom_theme', this, [themeName]);
  void setScreen(Screen screen) => _staticInfo.callMethodOnReceiver('set_screen', this, [screen]);
  void setSearchPath(List<String> path) => _staticInfo.callMethodOnReceiver('set_search_path', this, [path]);
  int _connectToChanged(bool after, void func()) => signalConnect('changed', func, after);
  Stream get onChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class IconThemeErrorCode extends GEnumBase {
  const IconThemeErrorCode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IconThemeError');

  static const IconThemeErrorCode NOT_FOUND = const IconThemeErrorCode(0);
  static const IconThemeErrorCode FAILED = const IconThemeErrorCode(1);
  String toString() {
    switch(index) {
      case 0: return 'IconThemeErrorCode.NOT_FOUND';
      case 1: return 'IconThemeErrorCode.FAILED';
      default: return 'new IconThemeErrorCode($index)';
    }
  }
  static int quark() => _staticInfo.callStatic('quark', []);
}

class IconThemeError extends GErrorBase {
  static final int _quark = lookupErrorQuarkFromString('gtk-icon-theme-error-quark');
  IconThemeError(IconThemeErrorCode code, String message)
      : super.fromFields(_quark, code, message);
}

class IconView extends Container with ImplementorIface, Buildable, CellLayout, Scrollable {
  IconView.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IconView');

  static const String ACTIVATE_ON_SINGLE_CLICK_PROPERTY = 'activate-on-single-click';
  CellArea get cellArea => _staticInfo.getGPropertyOnReceiver('cell-area', this);
  void set cellArea(CellArea value) => _staticInfo.setGPropertyOnReceiver('cell-area', this, value);
  static const String CELL_AREA_PROPERTY = 'cell-area';
  static const String COLUMN_SPACING_PROPERTY = 'column-spacing';
  static const String COLUMNS_PROPERTY = 'columns';
  static const String ITEM_ORIENTATION_PROPERTY = 'item-orientation';
  static const String ITEM_PADDING_PROPERTY = 'item-padding';
  static const String ITEM_WIDTH_PROPERTY = 'item-width';
  static const String MARGIN_PROPERTY = 'margin';
  static const String MARKUP_COLUMN_PROPERTY = 'markup-column';
  static const String MODEL_PROPERTY = 'model';
  static const String PIXBUF_COLUMN_PROPERTY = 'pixbuf-column';
  static const String REORDERABLE_PROPERTY = 'reorderable';
  static const String ROW_SPACING_PROPERTY = 'row-spacing';
  static const String SELECTION_MODE_PROPERTY = 'selection-mode';
  static const String SPACING_PROPERTY = 'spacing';
  static const String TEXT_COLUMN_PROPERTY = 'text-column';
  static const String TOOLTIP_COLUMN_PROPERTY = 'tooltip-column';
  factory IconView() => _staticInfo.callStatic('new', []);
  factory IconView.withArea(CellArea area) => _staticInfo.callStatic('new_with_area', [area]);
  factory IconView.withModel(TreeModel model) => _staticInfo.callStatic('new_with_model', [model]);
  void convertWidgetToBinWindowCoords(int wx, int wy) => _staticInfo.callMethodOnReceiver('convert_widget_to_bin_window_coords', this, [wx, wy]);
  Surface createDragIcon(TreePath path) => _staticInfo.callMethodOnReceiver('create_drag_icon', this, [path]);
  void enableModelDragDest(List<TargetEntry> targets, DragAction actions) => _staticInfo.callMethodOnReceiver('enable_model_drag_dest', this, [targets, actions]);
  void enableModelDragSource(ModifierType startButtonMask, List<TargetEntry> targets, DragAction actions) => _staticInfo.callMethodOnReceiver('enable_model_drag_source', this, [startButtonMask, targets, actions]);
  bool get activateOnSingleClick => _staticInfo.callMethodOnReceiver('get_activate_on_single_click', this, []);
  bool getCellRect(TreePath path, CellRenderer cell) => _staticInfo.callMethodOnReceiver('get_cell_rect', this, [path, cell]);
  int get columnSpacing => _staticInfo.callMethodOnReceiver('get_column_spacing', this, []);
  int get columns => _staticInfo.callMethodOnReceiver('get_columns', this, []);
  bool getCursor() => _staticInfo.callMethodOnReceiver('get_cursor', this, []);
  bool getDestItemAtPos(int dragX, int dragY) => _staticInfo.callMethodOnReceiver('get_dest_item_at_pos', this, [dragX, dragY]);
  void getDragDestItem() => _staticInfo.callMethodOnReceiver('get_drag_dest_item', this, []);
  bool getItemAtPos(int x, int y) => _staticInfo.callMethodOnReceiver('get_item_at_pos', this, [x, y]);
  int getItemColumn(TreePath path) => _staticInfo.callMethodOnReceiver('get_item_column', this, [path]);
  Orientation get itemOrientation => _staticInfo.callMethodOnReceiver('get_item_orientation', this, []);
  int get itemPadding => _staticInfo.callMethodOnReceiver('get_item_padding', this, []);
  int getItemRow(TreePath path) => _staticInfo.callMethodOnReceiver('get_item_row', this, [path]);
  int get itemWidth => _staticInfo.callMethodOnReceiver('get_item_width', this, []);
  int get margin => _staticInfo.callMethodOnReceiver('get_margin', this, []);
  int get markupColumn => _staticInfo.callMethodOnReceiver('get_markup_column', this, []);
  TreeModel get model => _staticInfo.callMethodOnReceiver('get_model', this, []);
  TreePath getPathAtPos(int x, int y) => _staticInfo.callMethodOnReceiver('get_path_at_pos', this, [x, y]);
  int get pixbufColumn => _staticInfo.callMethodOnReceiver('get_pixbuf_column', this, []);
  bool get reorderable => _staticInfo.callMethodOnReceiver('get_reorderable', this, []);
  int get rowSpacing => _staticInfo.callMethodOnReceiver('get_row_spacing', this, []);
  GLibList /* this will fail */ getSelectedItems() => _staticInfo.callMethodOnReceiver('get_selected_items', this, []);
  SelectionMode get selectionMode => _staticInfo.callMethodOnReceiver('get_selection_mode', this, []);
  int get spacing => _staticInfo.callMethodOnReceiver('get_spacing', this, []);
  int get textColumn => _staticInfo.callMethodOnReceiver('get_text_column', this, []);
  int get tooltipColumn => _staticInfo.callMethodOnReceiver('get_tooltip_column', this, []);
  bool getTooltipContext(int x, int y, bool keyboardTip) => _staticInfo.callMethodOnReceiver('get_tooltip_context', this, [x, y, keyboardTip]);
  bool getVisibleRange() => _staticInfo.callMethodOnReceiver('get_visible_range', this, []);
  void itemActivated(TreePath path) => _staticInfo.callMethodOnReceiver('item_activated', this, [path]);
  bool pathIsSelected(TreePath path) => _staticInfo.callMethodOnReceiver('path_is_selected', this, [path]);
  void scrollToPath(TreePath path, bool useAlign, num rowAlign, num colAlign) => _staticInfo.callMethodOnReceiver('scroll_to_path', this, [path, useAlign, rowAlign, colAlign]);
  void selectAll() => _staticInfo.callMethodOnReceiver('select_all', this, []);
  void selectPath(TreePath path) => _staticInfo.callMethodOnReceiver('select_path', this, [path]);
  void selectedForeach(IconViewForeachFunc func) => _staticInfo.callMethodOnReceiver('selected_foreach', this, [func]);
  void set activateOnSingleClick(bool single) => _staticInfo.callMethodOnReceiver('set_activate_on_single_click', this, [single]);
  void set columnSpacing(int columnSpacing) => _staticInfo.callMethodOnReceiver('set_column_spacing', this, [columnSpacing]);
  void set columns(int columns) => _staticInfo.callMethodOnReceiver('set_columns', this, [columns]);
  void setCursor(TreePath path, CellRenderer cell, bool startEditing) => _staticInfo.callMethodOnReceiver('set_cursor', this, [path, cell, startEditing]);
  void setDragDestItem(TreePath path, IconViewDropPosition pos) => _staticInfo.callMethodOnReceiver('set_drag_dest_item', this, [path, pos]);
  void set itemOrientation(Orientation orientation) => _staticInfo.callMethodOnReceiver('set_item_orientation', this, [orientation]);
  void set itemPadding(int itemPadding) => _staticInfo.callMethodOnReceiver('set_item_padding', this, [itemPadding]);
  void set itemWidth(int itemWidth) => _staticInfo.callMethodOnReceiver('set_item_width', this, [itemWidth]);
  void set margin(int margin) => _staticInfo.callMethodOnReceiver('set_margin', this, [margin]);
  void set markupColumn(int column) => _staticInfo.callMethodOnReceiver('set_markup_column', this, [column]);
  void set model(TreeModel model) => _staticInfo.callMethodOnReceiver('set_model', this, [model]);
  void set pixbufColumn(int column) => _staticInfo.callMethodOnReceiver('set_pixbuf_column', this, [column]);
  void set reorderable(bool reorderable) => _staticInfo.callMethodOnReceiver('set_reorderable', this, [reorderable]);
  void set rowSpacing(int rowSpacing) => _staticInfo.callMethodOnReceiver('set_row_spacing', this, [rowSpacing]);
  void set selectionMode(SelectionMode mode) => _staticInfo.callMethodOnReceiver('set_selection_mode', this, [mode]);
  void set spacing(int spacing) => _staticInfo.callMethodOnReceiver('set_spacing', this, [spacing]);
  void set textColumn(int column) => _staticInfo.callMethodOnReceiver('set_text_column', this, [column]);
  void setTooltipCell(Tooltip tooltip, TreePath path, CellRenderer cell) => _staticInfo.callMethodOnReceiver('set_tooltip_cell', this, [tooltip, path, cell]);
  void set tooltipColumn(int column) => _staticInfo.callMethodOnReceiver('set_tooltip_column', this, [column]);
  void setTooltipItem(Tooltip tooltip, TreePath path) => _staticInfo.callMethodOnReceiver('set_tooltip_item', this, [tooltip, path]);
  void unselectAll() => _staticInfo.callMethodOnReceiver('unselect_all', this, []);
  void unselectPath(TreePath path) => _staticInfo.callMethodOnReceiver('unselect_path', this, [path]);
  void unsetModelDragDest() => _staticInfo.callMethodOnReceiver('unset_model_drag_dest', this, []);
  void unsetModelDragSource() => _staticInfo.callMethodOnReceiver('unset_model_drag_source', this, []);
  int _connectToActivateCursorItem(bool after, bool func()) => signalConnect('activate-cursor-item', func, after);
  Stream<IconViewActivateCursorItemEvent> get onActivateCursorItem {
    int signalId;
    StreamController<IconViewActivateCursorItemEvent> controller;
    controller = new StreamController<IconViewActivateCursorItemEvent>(
      onListen: () {
          signalId = _connectToActivateCursorItem(false, () {
              var result = new IconViewActivateCursorItemEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<IconViewActivateCursorItemEvent> get afterActivateCursorItem {
    int signalId;
    StreamController<IconViewActivateCursorItemEvent> controller;
    controller = new StreamController<IconViewActivateCursorItemEvent>(
      onListen: () {
          signalId = _connectToActivateCursorItem(true, () {
              var result = new IconViewActivateCursorItemEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToItemActivated(bool after, void func(TreePath path)) => signalConnect('item-activated', func, after);
  Stream<TreePath> get onItemActivated {
    int signalId;
    StreamController<TreePath> controller;
    controller = new StreamController<TreePath>(
      onListen: () {
          signalId = _connectToItemActivated(false, (TreePath path) {
              controller.add(path);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreePath> get afterItemActivated {
    int signalId;
    StreamController<TreePath> controller;
    controller = new StreamController<TreePath>(
      onListen: () {
          signalId = _connectToItemActivated(true, (TreePath path) {
              controller.add(path);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveCursor(bool after, bool func(MovementStep step, int count)) => signalConnect('move-cursor', func, after);
  Stream<IconViewMoveCursorEvent> get onMoveCursor {
    int signalId;
    StreamController<IconViewMoveCursorEvent> controller;
    controller = new StreamController<IconViewMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(false, (MovementStep step, int count) {
              var result = new IconViewMoveCursorEvent(step, count);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<IconViewMoveCursorEvent> get afterMoveCursor {
    int signalId;
    StreamController<IconViewMoveCursorEvent> controller;
    controller = new StreamController<IconViewMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(true, (MovementStep step, int count) {
              var result = new IconViewMoveCursorEvent(step, count);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectAll(bool after, void func()) => signalConnect('select-all', func, after);
  Stream get onSelectAll {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectAll(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSelectAll {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectAll(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectCursorItem(bool after, void func()) => signalConnect('select-cursor-item', func, after);
  Stream get onSelectCursorItem {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectCursorItem(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSelectCursorItem {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectCursorItem(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectionChanged(bool after, void func()) => signalConnect('selection-changed', func, after);
  Stream get onSelectionChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectionChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSelectionChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectionChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToToggleCursorItem(bool after, void func()) => signalConnect('toggle-cursor-item', func, after);
  Stream get onToggleCursorItem {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggleCursorItem(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterToggleCursorItem {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggleCursorItem(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToUnselectAll(bool after, void func()) => signalConnect('unselect-all', func, after);
  Stream get onUnselectAll {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUnselectAll(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterUnselectAll {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUnselectAll(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class IconViewActivateCursorItemEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  IconViewActivateCursorItemEvent();
}

class IconViewMoveCursorEvent {
  final MovementStep step;
  final int count;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  IconViewMoveCursorEvent(this.step, this.count);
}

class IconViewAccessible extends ContainerAccessible with Component, Selection {
  IconViewAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IconViewAccessible');

}

class IconViewDropPosition extends GEnumBase {
  const IconViewDropPosition(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'IconViewDropPosition');

  static const IconViewDropPosition NO_DROP = const IconViewDropPosition(0);
  static const IconViewDropPosition DROP_INTO = const IconViewDropPosition(1);
  static const IconViewDropPosition DROP_LEFT = const IconViewDropPosition(2);
  static const IconViewDropPosition DROP_RIGHT = const IconViewDropPosition(3);
  static const IconViewDropPosition DROP_ABOVE = const IconViewDropPosition(4);
  static const IconViewDropPosition DROP_BELOW = const IconViewDropPosition(5);
  String toString() {
    switch(index) {
      case 0: return 'IconViewDropPosition.NO_DROP';
      case 1: return 'IconViewDropPosition.DROP_INTO';
      case 2: return 'IconViewDropPosition.DROP_LEFT';
      case 3: return 'IconViewDropPosition.DROP_RIGHT';
      case 4: return 'IconViewDropPosition.DROP_ABOVE';
      case 5: return 'IconViewDropPosition.DROP_BELOW';
      default: return 'new IconViewDropPosition($index)';
    }
  }
}

typedef void IconViewForeachFunc(IconView iconView, TreePath path);
class Image extends Misc with ImplementorIface, Buildable {
  Image.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Image');

  String get file => _staticInfo.getGPropertyOnReceiver('file', this);
  void set file(String value) => _staticInfo.setGPropertyOnReceiver('file', this, value);
  static const String FILE_PROPERTY = 'file';
  void set gicon(Icon value) => _staticInfo.setGPropertyOnReceiver('gicon', this, value);
  static const String GICON_PROPERTY = 'gicon';
  void set iconName(String value) => _staticInfo.setGPropertyOnReceiver('icon-name', this, value);
  static const String ICON_NAME_PROPERTY = 'icon-name';
  void set iconSet(IconSet value) => _staticInfo.setGPropertyOnReceiver('icon-set', this, value);
  static const String ICON_SET_PROPERTY = 'icon-set';
  int get iconSize => _staticInfo.getGPropertyOnReceiver('icon-size', this);
  void set iconSize(int value) => _staticInfo.setGPropertyOnReceiver('icon-size', this, value);
  static const String ICON_SIZE_PROPERTY = 'icon-size';
  void set pixbuf(Pixbuf value) => _staticInfo.setGPropertyOnReceiver('pixbuf', this, value);
  static const String PIXBUF_PROPERTY = 'pixbuf';
  PixbufAnimation get pixbufAnimation => _staticInfo.getGPropertyOnReceiver('pixbuf-animation', this);
  void set pixbufAnimation(PixbufAnimation value) => _staticInfo.setGPropertyOnReceiver('pixbuf-animation', this, value);
  static const String PIXBUF_ANIMATION_PROPERTY = 'pixbuf-animation';
  static const String PIXEL_SIZE_PROPERTY = 'pixel-size';
  String get resource => _staticInfo.getGPropertyOnReceiver('resource', this);
  void set resource(String value) => _staticInfo.setGPropertyOnReceiver('resource', this, value);
  static const String RESOURCE_PROPERTY = 'resource';
  void set stock(String value) => _staticInfo.setGPropertyOnReceiver('stock', this, value);
  static const String STOCK_PROPERTY = 'stock';
  static const String STORAGE_TYPE_PROPERTY = 'storage-type';
  Surface get surface => _staticInfo.getGPropertyOnReceiver('surface', this);
  void set surface(Surface value) => _staticInfo.setGPropertyOnReceiver('surface', this, value);
  static const String SURFACE_PROPERTY = 'surface';
  bool get useFallback => _staticInfo.getGPropertyOnReceiver('use-fallback', this);
  void set useFallback(bool value) => _staticInfo.setGPropertyOnReceiver('use-fallback', this, value);
  static const String USE_FALLBACK_PROPERTY = 'use-fallback';
  factory Image() => _staticInfo.callStatic('new', []);
  factory Image.fromAnimation(PixbufAnimation animation) => _staticInfo.callStatic('new_from_animation', [animation]);
  factory Image.fromFile(String filename) => _staticInfo.callStatic('new_from_file', [filename]);
  factory Image.fromGicon(Icon icon, int size) => _staticInfo.callStatic('new_from_gicon', [icon, size]);
  factory Image.fromIconName(String iconName, int size) => _staticInfo.callStatic('new_from_icon_name', [iconName, size]);
  factory Image.fromIconSet(IconSet iconSet, int size) => _staticInfo.callStatic('new_from_icon_set', [iconSet, size]);
  factory Image.fromPixbuf(Pixbuf pixbuf) => _staticInfo.callStatic('new_from_pixbuf', [pixbuf]);
  factory Image.fromResource(String resourcePath) => _staticInfo.callStatic('new_from_resource', [resourcePath]);
  factory Image.fromStock(String stockId, int size) => _staticInfo.callStatic('new_from_stock', [stockId, size]);
  factory Image.fromSurface(Surface surface) => _staticInfo.callStatic('new_from_surface', [surface]);
  void clear() => _staticInfo.callMethodOnReceiver('clear', this, []);
  PixbufAnimation getAnimation() => _staticInfo.callMethodOnReceiver('get_animation', this, []);
  void getGicon() => _staticInfo.callMethodOnReceiver('get_gicon', this, []);
  void getIconName() => _staticInfo.callMethodOnReceiver('get_icon_name', this, []);
  void getIconSet() => _staticInfo.callMethodOnReceiver('get_icon_set', this, []);
  Pixbuf get pixbuf_ => _staticInfo.callMethodOnReceiver('get_pixbuf', this, []);
  int get pixelSize => _staticInfo.callMethodOnReceiver('get_pixel_size', this, []);
  void getStock() => _staticInfo.callMethodOnReceiver('get_stock', this, []);
  ImageType get storageType => _staticInfo.callMethodOnReceiver('get_storage_type', this, []);
  void setFromAnimation(PixbufAnimation animation) => _staticInfo.callMethodOnReceiver('set_from_animation', this, [animation]);
  void setFromFile(String filename) => _staticInfo.callMethodOnReceiver('set_from_file', this, [filename]);
  void setFromGicon(Icon icon, int size) => _staticInfo.callMethodOnReceiver('set_from_gicon', this, [icon, size]);
  void setFromIconName(String iconName, int size) => _staticInfo.callMethodOnReceiver('set_from_icon_name', this, [iconName, size]);
  void setFromIconSet(IconSet iconSet, int size) => _staticInfo.callMethodOnReceiver('set_from_icon_set', this, [iconSet, size]);
  void setFromPixbuf(Pixbuf pixbuf) => _staticInfo.callMethodOnReceiver('set_from_pixbuf', this, [pixbuf]);
  void setFromResource(String resourcePath) => _staticInfo.callMethodOnReceiver('set_from_resource', this, [resourcePath]);
  void setFromStock(String stockId, int size) => _staticInfo.callMethodOnReceiver('set_from_stock', this, [stockId, size]);
  void setFromSurface(Surface surface) => _staticInfo.callMethodOnReceiver('set_from_surface', this, [surface]);
  void set pixelSize(int pixelSize) => _staticInfo.callMethodOnReceiver('set_pixel_size', this, [pixelSize]);
}

class ImageAccessible extends WidgetAccessible with Component, atk.Image {
  ImageAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ImageAccessible');

}

class ImageCellAccessible extends RendererCellAccessible with atk.Action, Component, atk.Image {
  ImageCellAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ImageCellAccessible');

}

class ImageMenuItem extends MenuItem with ImplementorIface, Actionable, Activatable, Buildable {
  ImageMenuItem.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ImageMenuItem');

  static const String ACCEL_GROUP_PROPERTY = 'accel-group';
  static const String ALWAYS_SHOW_IMAGE_PROPERTY = 'always-show-image';
  static const String IMAGE_PROPERTY = 'image';
  static const String USE_STOCK_PROPERTY = 'use-stock';
  factory ImageMenuItem() => _staticInfo.callStatic('new', []);
  factory ImageMenuItem.fromStock(String stockId, AccelGroup accelGroup) => _staticInfo.callStatic('new_from_stock', [stockId, accelGroup]);
  factory ImageMenuItem.withLabel(String label) => _staticInfo.callStatic('new_with_label', [label]);
  factory ImageMenuItem.withMnemonic(String label) => _staticInfo.callStatic('new_with_mnemonic', [label]);
  bool get alwaysShowImage => _staticInfo.callMethodOnReceiver('get_always_show_image', this, []);
  Widget get image => _staticInfo.callMethodOnReceiver('get_image', this, []);
  bool get useStock => _staticInfo.callMethodOnReceiver('get_use_stock', this, []);
  void set accelGroup(AccelGroup accelGroup) => _staticInfo.callMethodOnReceiver('set_accel_group', this, [accelGroup]);
  void set alwaysShowImage(bool alwaysShow) => _staticInfo.callMethodOnReceiver('set_always_show_image', this, [alwaysShow]);
  void set image(Widget image) => _staticInfo.callMethodOnReceiver('set_image', this, [image]);
  void set useStock(bool useStock) => _staticInfo.callMethodOnReceiver('set_use_stock', this, [useStock]);
}

class ImageType extends GEnumBase {
  const ImageType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ImageType');

  static const ImageType EMPTY = const ImageType(0);
  static const ImageType PIXBUF = const ImageType(1);
  static const ImageType STOCK = const ImageType(2);
  static const ImageType ICON_SET = const ImageType(3);
  static const ImageType ANIMATION = const ImageType(4);
  static const ImageType ICON_NAME = const ImageType(5);
  static const ImageType GICON = const ImageType(6);
  static const ImageType SURFACE = const ImageType(7);
  String toString() {
    switch(index) {
      case 0: return 'ImageType.EMPTY';
      case 1: return 'ImageType.PIXBUF';
      case 2: return 'ImageType.STOCK';
      case 3: return 'ImageType.ICON_SET';
      case 4: return 'ImageType.ANIMATION';
      case 5: return 'ImageType.ICON_NAME';
      case 6: return 'ImageType.GICON';
      case 7: return 'ImageType.SURFACE';
      default: return 'new ImageType($index)';
    }
  }
}

class InfoBar extends Box with ImplementorIface, Buildable, Orientable {
  InfoBar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'InfoBar');

  static const String MESSAGE_TYPE_PROPERTY = 'message-type';
  static const String SHOW_CLOSE_BUTTON_PROPERTY = 'show-close-button';
  factory InfoBar() => _staticInfo.callStatic('new', []);
  void addActionWidget(Widget child, int responseId) => _staticInfo.callMethodOnReceiver('add_action_widget', this, [child, responseId]);
  Button addButton(String buttonText, int responseId) => _staticInfo.callMethodOnReceiver('add_button', this, [buttonText, responseId]);
  Widget getActionArea() => _staticInfo.callMethodOnReceiver('get_action_area', this, []);
  Widget getContentArea() => _staticInfo.callMethodOnReceiver('get_content_area', this, []);
  MessageType get messageType => _staticInfo.callMethodOnReceiver('get_message_type', this, []);
  bool get showCloseButton => _staticInfo.callMethodOnReceiver('get_show_close_button', this, []);
  void response(int responseId) => _staticInfo.callMethodOnReceiver('response', this, [responseId]);
  void setDefaultResponse(int responseId) => _staticInfo.callMethodOnReceiver('set_default_response', this, [responseId]);
  void set messageType(MessageType messageType) => _staticInfo.callMethodOnReceiver('set_message_type', this, [messageType]);
  void setResponseSensitive(int responseId, bool setting) => _staticInfo.callMethodOnReceiver('set_response_sensitive', this, [responseId, setting]);
  void set showCloseButton(bool setting) => _staticInfo.callMethodOnReceiver('set_show_close_button', this, [setting]);
  int _connectToClose(bool after, void func()) => signalConnect('close', func, after);
  Stream get onClose {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClose(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterClose {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClose(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToResponse(bool after, void func(int responseId)) => signalConnect('response', func, after);
  Stream<int> get onResponse {
    int signalId;
    StreamController<int> controller;
    controller = new StreamController<int>(
      onListen: () {
          signalId = _connectToResponse(false, (int responseId) {
              controller.add(responseId);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<int> get afterResponse {
    int signalId;
    StreamController<int> controller;
    controller = new StreamController<int>(
      onListen: () {
          signalId = _connectToResponse(true, (int responseId) {
              controller.add(responseId);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class InputHints extends GEnumBase {
  const InputHints(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'InputHints');

  static const InputHints NONE = const InputHints(0);
  bool get none => (index & 0) == 0;
  static const InputHints SPELLCHECK = const InputHints(1);
  bool get spellcheck => (index & 1) == 1;
  static const InputHints NO_SPELLCHECK = const InputHints(2);
  bool get noSpellcheck => (index & 2) == 2;
  static const InputHints WORD_COMPLETION = const InputHints(4);
  bool get wordCompletion => (index & 4) == 4;
  static const InputHints LOWERCASE = const InputHints(8);
  bool get lowercase => (index & 8) == 8;
  static const InputHints UPPERCASE_CHARS = const InputHints(16);
  bool get uppercaseChars => (index & 16) == 16;
  static const InputHints UPPERCASE_WORDS = const InputHints(32);
  bool get uppercaseWords => (index & 32) == 32;
  static const InputHints UPPERCASE_SENTENCES = const InputHints(64);
  bool get uppercaseSentences => (index & 64) == 64;
  static const InputHints INHIBIT_OSK = const InputHints(128);
  bool get inhibitOsk => (index & 128) == 128;
  static const InputHints VERTICAL_WRITING = const InputHints(256);
  bool get verticalWriting => (index & 256) == 256;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'InputHints.SPELLCHECK';
      case 2: return 'InputHints.NO_SPELLCHECK';
      case 4: return 'InputHints.WORD_COMPLETION';
      case 8: return 'InputHints.LOWERCASE';
      case 16: return 'InputHints.UPPERCASE_CHARS';
      case 32: return 'InputHints.UPPERCASE_WORDS';
      case 64: return 'InputHints.UPPERCASE_SENTENCES';
      case 128: return 'InputHints.INHIBIT_OSK';
      default: return 'new InputHints($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'InputHints.NONE';
    }
    List codes = [];
    for (var i=1; i <= 256; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  InputHints operator|(InputHints other) =>
    new InputHints(index | other.index);
  InputHints operator&(InputHints other) =>
    new InputHints(index & other.index);
}

class InputPurpose extends GEnumBase {
  const InputPurpose(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'InputPurpose');

  static const InputPurpose FREE_FORM = const InputPurpose(0);
  static const InputPurpose ALPHA = const InputPurpose(1);
  static const InputPurpose DIGITS = const InputPurpose(2);
  static const InputPurpose NUMBER = const InputPurpose(3);
  static const InputPurpose PHONE = const InputPurpose(4);
  static const InputPurpose URL = const InputPurpose(5);
  static const InputPurpose EMAIL = const InputPurpose(6);
  static const InputPurpose NAME = const InputPurpose(7);
  static const InputPurpose PASSWORD = const InputPurpose(8);
  static const InputPurpose PIN = const InputPurpose(9);
  String toString() {
    switch(index) {
      case 0: return 'InputPurpose.FREE_FORM';
      case 1: return 'InputPurpose.ALPHA';
      case 2: return 'InputPurpose.DIGITS';
      case 3: return 'InputPurpose.NUMBER';
      case 4: return 'InputPurpose.PHONE';
      case 5: return 'InputPurpose.URL';
      case 6: return 'InputPurpose.EMAIL';
      case 7: return 'InputPurpose.NAME';
      case 8: return 'InputPurpose.PASSWORD';
      case 9: return 'InputPurpose.PIN';
      default: return 'new InputPurpose($index)';
    }
  }
}

class Invisible extends Widget with ImplementorIface, Buildable {
  Invisible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Invisible');

  static const String SCREEN_PROPERTY = 'screen';
  factory Invisible() => _staticInfo.callStatic('new', []);
  factory Invisible.forScreen(Screen screen) => _staticInfo.callStatic('new_for_screen', [screen]);
  Screen get screen => _staticInfo.callMethodOnReceiver('get_screen', this, []);
  void set screen(Screen screen) => _staticInfo.callMethodOnReceiver('set_screen', this, [screen]);
}

class JunctionSides extends GEnumBase {
  const JunctionSides(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'JunctionSides');

  static const JunctionSides NONE = const JunctionSides(0);
  bool get none => (index & 0) == 0;
  static const JunctionSides CORNER_TOPLEFT = const JunctionSides(1);
  bool get cornerTopleft => (index & 1) == 1;
  static const JunctionSides CORNER_TOPRIGHT = const JunctionSides(2);
  bool get cornerTopright => (index & 2) == 2;
  static const JunctionSides CORNER_BOTTOMLEFT = const JunctionSides(4);
  bool get cornerBottomleft => (index & 4) == 4;
  static const JunctionSides CORNER_BOTTOMRIGHT = const JunctionSides(8);
  bool get cornerBottomright => (index & 8) == 8;
  static const JunctionSides TOP = const JunctionSides(3);
  bool get top => (index & 3) == 3;
  static const JunctionSides BOTTOM = const JunctionSides(12);
  bool get bottom => (index & 12) == 12;
  static const JunctionSides LEFT = const JunctionSides(5);
  bool get left => (index & 5) == 5;
  static const JunctionSides RIGHT = const JunctionSides(10);
  bool get right => (index & 10) == 10;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'JunctionSides.CORNER_TOPLEFT';
      case 2: return 'JunctionSides.CORNER_TOPRIGHT';
      case 4: return 'JunctionSides.CORNER_BOTTOMLEFT';
      case 8: return 'JunctionSides.CORNER_BOTTOMRIGHT';
      default: return 'new JunctionSides($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'JunctionSides.NONE';
    }
    List codes = [];
    for (var i=1; i <= 8; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  JunctionSides operator|(JunctionSides other) =>
    new JunctionSides(index | other.index);
  JunctionSides operator&(JunctionSides other) =>
    new JunctionSides(index & other.index);
}

class Justification extends GEnumBase {
  const Justification(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Justification');

  static const Justification LEFT = const Justification(0);
  static const Justification RIGHT = const Justification(1);
  static const Justification CENTER = const Justification(2);
  static const Justification FILL = const Justification(3);
  String toString() {
    switch(index) {
      case 0: return 'Justification.LEFT';
      case 1: return 'Justification.RIGHT';
      case 2: return 'Justification.CENTER';
      case 3: return 'Justification.FILL';
      default: return 'new Justification($index)';
    }
  }
}

typedef int KeySnoopFunc(Widget grabWidget, EventKey event);
class Label extends Misc with ImplementorIface, Buildable {
  Label.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Label');

  static const String ANGLE_PROPERTY = 'angle';
  static const String ATTRIBUTES_PROPERTY = 'attributes';
  int get cursorPosition => _staticInfo.getGPropertyOnReceiver('cursor-position', this);
  static const String CURSOR_POSITION_PROPERTY = 'cursor-position';
  static const String ELLIPSIZE_PROPERTY = 'ellipsize';
  static const String JUSTIFY_PROPERTY = 'justify';
  static const String LABEL_PROPERTY = 'label';
  static const String LINES_PROPERTY = 'lines';
  static const String MAX_WIDTH_CHARS_PROPERTY = 'max-width-chars';
  static const String MNEMONIC_KEYVAL_PROPERTY = 'mnemonic-keyval';
  static const String MNEMONIC_WIDGET_PROPERTY = 'mnemonic-widget';
  static const String PATTERN_PROPERTY = 'pattern';
  static const String SELECTABLE_PROPERTY = 'selectable';
  int get selectionBound => _staticInfo.getGPropertyOnReceiver('selection-bound', this);
  static const String SELECTION_BOUND_PROPERTY = 'selection-bound';
  static const String SINGLE_LINE_MODE_PROPERTY = 'single-line-mode';
  static const String TRACK_VISITED_LINKS_PROPERTY = 'track-visited-links';
  static const String USE_MARKUP_PROPERTY = 'use-markup';
  static const String USE_UNDERLINE_PROPERTY = 'use-underline';
  static const String WIDTH_CHARS_PROPERTY = 'width-chars';
  bool get wrap => _staticInfo.getGPropertyOnReceiver('wrap', this);
  void set wrap(bool value) => _staticInfo.setGPropertyOnReceiver('wrap', this, value);
  static const String WRAP_PROPERTY = 'wrap';
  WrapMode get wrapMode => _staticInfo.getGPropertyOnReceiver('wrap-mode', this);
  void set wrapMode(WrapMode value) => _staticInfo.setGPropertyOnReceiver('wrap-mode', this, value);
  static const String WRAP_MODE_PROPERTY = 'wrap-mode';
  static const String XALIGN_PROPERTY = 'xalign';
  static const String YALIGN_PROPERTY = 'yalign';
  factory Label(String str) => _staticInfo.callStatic('new', [str]);
  factory Label.withMnemonic(String str) => _staticInfo.callStatic('new_with_mnemonic', [str]);
  num get angle => _staticInfo.callMethodOnReceiver('get_angle', this, []);
  AttrList get attributes => _staticInfo.callMethodOnReceiver('get_attributes', this, []);
  String getCurrentUri() => _staticInfo.callMethodOnReceiver('get_current_uri', this, []);
  EllipsizeMode get ellipsize => _staticInfo.callMethodOnReceiver('get_ellipsize', this, []);
  Justification get justify => _staticInfo.callMethodOnReceiver('get_justify', this, []);
  String get label => _staticInfo.callMethodOnReceiver('get_label', this, []);
  pango.Layout getLayout() => _staticInfo.callMethodOnReceiver('get_layout', this, []);
  void getLayoutOffsets() => _staticInfo.callMethodOnReceiver('get_layout_offsets', this, []);
  bool getLineWrap() => _staticInfo.callMethodOnReceiver('get_line_wrap', this, []);
  WrapMode getLineWrapMode() => _staticInfo.callMethodOnReceiver('get_line_wrap_mode', this, []);
  int get lines => _staticInfo.callMethodOnReceiver('get_lines', this, []);
  int get maxWidthChars => _staticInfo.callMethodOnReceiver('get_max_width_chars', this, []);
  int get mnemonicKeyval => _staticInfo.callMethodOnReceiver('get_mnemonic_keyval', this, []);
  Widget get mnemonicWidget => _staticInfo.callMethodOnReceiver('get_mnemonic_widget', this, []);
  bool get selectable => _staticInfo.callMethodOnReceiver('get_selectable', this, []);
  bool getSelectionBounds() => _staticInfo.callMethodOnReceiver('get_selection_bounds', this, []);
  bool get singleLineMode => _staticInfo.callMethodOnReceiver('get_single_line_mode', this, []);
  String getText() => _staticInfo.callMethodOnReceiver('get_text', this, []);
  bool get trackVisitedLinks => _staticInfo.callMethodOnReceiver('get_track_visited_links', this, []);
  bool get useMarkup => _staticInfo.callMethodOnReceiver('get_use_markup', this, []);
  bool get useUnderline => _staticInfo.callMethodOnReceiver('get_use_underline', this, []);
  int get widthChars => _staticInfo.callMethodOnReceiver('get_width_chars', this, []);
  num get xalign => _staticInfo.callMethodOnReceiver('get_xalign', this, []);
  num get yalign => _staticInfo.callMethodOnReceiver('get_yalign', this, []);
  void selectRegion(int startOffset, int endOffset) => _staticInfo.callMethodOnReceiver('select_region', this, [startOffset, endOffset]);
  void set angle(num angle) => _staticInfo.callMethodOnReceiver('set_angle', this, [angle]);
  void set attributes(AttrList attrs) => _staticInfo.callMethodOnReceiver('set_attributes', this, [attrs]);
  void set ellipsize(EllipsizeMode mode) => _staticInfo.callMethodOnReceiver('set_ellipsize', this, [mode]);
  void set justify(Justification jtype) => _staticInfo.callMethodOnReceiver('set_justify', this, [jtype]);
  void set label(String str) => _staticInfo.callMethodOnReceiver('set_label', this, [str]);
  void setLineWrap(bool wrap) => _staticInfo.callMethodOnReceiver('set_line_wrap', this, [wrap]);
  void setLineWrapMode(WrapMode wrapMode) => _staticInfo.callMethodOnReceiver('set_line_wrap_mode', this, [wrapMode]);
  void set lines(int lines) => _staticInfo.callMethodOnReceiver('set_lines', this, [lines]);
  void setMarkup(String str) => _staticInfo.callMethodOnReceiver('set_markup', this, [str]);
  void setMarkupWithMnemonic(String str) => _staticInfo.callMethodOnReceiver('set_markup_with_mnemonic', this, [str]);
  void set maxWidthChars(int nChars) => _staticInfo.callMethodOnReceiver('set_max_width_chars', this, [nChars]);
  void set mnemonicWidget(Widget widget) => _staticInfo.callMethodOnReceiver('set_mnemonic_widget', this, [widget]);
  void set pattern(String pattern) => _staticInfo.callMethodOnReceiver('set_pattern', this, [pattern]);
  void set selectable(bool setting) => _staticInfo.callMethodOnReceiver('set_selectable', this, [setting]);
  void set singleLineMode(bool singleLineMode) => _staticInfo.callMethodOnReceiver('set_single_line_mode', this, [singleLineMode]);
  void setText(String str) => _staticInfo.callMethodOnReceiver('set_text', this, [str]);
  void setTextWithMnemonic(String str) => _staticInfo.callMethodOnReceiver('set_text_with_mnemonic', this, [str]);
  void set trackVisitedLinks(bool trackLinks) => _staticInfo.callMethodOnReceiver('set_track_visited_links', this, [trackLinks]);
  void set useMarkup(bool setting) => _staticInfo.callMethodOnReceiver('set_use_markup', this, [setting]);
  void set useUnderline(bool setting) => _staticInfo.callMethodOnReceiver('set_use_underline', this, [setting]);
  void set widthChars(int nChars) => _staticInfo.callMethodOnReceiver('set_width_chars', this, [nChars]);
  void set xalign(num xalign) => _staticInfo.callMethodOnReceiver('set_xalign', this, [xalign]);
  void set yalign(num yalign) => _staticInfo.callMethodOnReceiver('set_yalign', this, [yalign]);
  int _connectToActivateCurrentLink(bool after, void func()) => signalConnect('activate-current-link', func, after);
  Stream get onActivateCurrentLink {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivateCurrentLink(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivateCurrentLink {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivateCurrentLink(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToActivateLink(bool after, bool func(String uri)) => signalConnect('activate-link', func, after);
  Stream<LabelActivateLinkEvent> get onActivateLink {
    int signalId;
    StreamController<LabelActivateLinkEvent> controller;
    controller = new StreamController<LabelActivateLinkEvent>(
      onListen: () {
          signalId = _connectToActivateLink(false, (String uri) {
              var result = new LabelActivateLinkEvent(uri);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<LabelActivateLinkEvent> get afterActivateLink {
    int signalId;
    StreamController<LabelActivateLinkEvent> controller;
    controller = new StreamController<LabelActivateLinkEvent>(
      onListen: () {
          signalId = _connectToActivateLink(true, (String uri) {
              var result = new LabelActivateLinkEvent(uri);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCopyClipboard(bool after, void func()) => signalConnect('copy-clipboard', func, after);
  Stream get onCopyClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCopyClipboard(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterCopyClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCopyClipboard(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveCursor(bool after, void func(MovementStep step, int count, bool extendSelection)) => signalConnect('move-cursor', func, after);
  Stream<LabelMoveCursorEvent> get onMoveCursor {
    int signalId;
    StreamController<LabelMoveCursorEvent> controller;
    controller = new StreamController<LabelMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(false, (MovementStep step, int count, bool extendSelection) {
              var result = new LabelMoveCursorEvent(step, count, extendSelection);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<LabelMoveCursorEvent> get afterMoveCursor {
    int signalId;
    StreamController<LabelMoveCursorEvent> controller;
    controller = new StreamController<LabelMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(true, (MovementStep step, int count, bool extendSelection) {
              var result = new LabelMoveCursorEvent(step, count, extendSelection);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPopulatePopup(bool after, void func(Menu menu)) => signalConnect('populate-popup', func, after);
  Stream<Menu> get onPopulatePopup {
    int signalId;
    StreamController<Menu> controller;
    controller = new StreamController<Menu>(
      onListen: () {
          signalId = _connectToPopulatePopup(false, (Menu menu) {
              controller.add(menu);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Menu> get afterPopulatePopup {
    int signalId;
    StreamController<Menu> controller;
    controller = new StreamController<Menu>(
      onListen: () {
          signalId = _connectToPopulatePopup(true, (Menu menu) {
              controller.add(menu);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class LabelActivateLinkEvent {
  final String uri;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  LabelActivateLinkEvent(this.uri);
}

class LabelMoveCursorEvent {
  final MovementStep step;
  final int count;
  final bool extendSelection;

  LabelMoveCursorEvent(this.step, this.count, this.extendSelection);
}

class LabelAccessible extends WidgetAccessible with Component, Hypertext, Text {
  LabelAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'LabelAccessible');

}

class LabelSelectionInfo extends GObjectBase {
  LabelSelectionInfo.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'LabelSelectionInfo');

}

class Layout extends Container with ImplementorIface, Buildable, Scrollable {
  Layout.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Layout');

  int get height => _staticInfo.getGPropertyOnReceiver('height', this);
  void set height(int value) => _staticInfo.setGPropertyOnReceiver('height', this, value);
  static const String HEIGHT_PROPERTY = 'height';
  int get width => _staticInfo.getGPropertyOnReceiver('width', this);
  void set width(int value) => _staticInfo.setGPropertyOnReceiver('width', this, value);
  static const String WIDTH_PROPERTY = 'width';
  factory Layout(Adjustment hadjustment, Adjustment vadjustment) => _staticInfo.callStatic('new', [hadjustment, vadjustment]);
  gdk.Window getBinWindow() => _staticInfo.callMethodOnReceiver('get_bin_window', this, []);
  Adjustment getHadjustment() => _staticInfo.callMethodOnReceiver('get_hadjustment', this, []);
  void getSize() => _staticInfo.callMethodOnReceiver('get_size', this, []);
  Adjustment getVadjustment() => _staticInfo.callMethodOnReceiver('get_vadjustment', this, []);
  void move(Widget childWidget, int x, int y) => _staticInfo.callMethodOnReceiver('move', this, [childWidget, x, y]);
  void put(Widget childWidget, int x, int y) => _staticInfo.callMethodOnReceiver('put', this, [childWidget, x, y]);
  void setHadjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_hadjustment', this, [adjustment]);
  void setSize(int width, int height) => _staticInfo.callMethodOnReceiver('set_size', this, [width, height]);
  void setVadjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_vadjustment', this, [adjustment]);
}

class LevelBar extends Widget with ImplementorIface, Buildable, Orientable {
  LevelBar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'LevelBar');

  static const String INVERTED_PROPERTY = 'inverted';
  static const String MAX_VALUE_PROPERTY = 'max-value';
  static const String MIN_VALUE_PROPERTY = 'min-value';
  static const String MODE_PROPERTY = 'mode';
  static const String VALUE_PROPERTY = 'value';
  factory LevelBar() => _staticInfo.callStatic('new', []);
  factory LevelBar.forInterval(num minValue, num maxValue) => _staticInfo.callStatic('new_for_interval', [minValue, maxValue]);
  void addOffsetValue(String name, num value) => _staticInfo.callMethodOnReceiver('add_offset_value', this, [name, value]);
  bool get inverted => _staticInfo.callMethodOnReceiver('get_inverted', this, []);
  num get maxValue => _staticInfo.callMethodOnReceiver('get_max_value', this, []);
  num get minValue => _staticInfo.callMethodOnReceiver('get_min_value', this, []);
  LevelBarMode get mode => _staticInfo.callMethodOnReceiver('get_mode', this, []);
  bool getOffsetValue(String name) => _staticInfo.callMethodOnReceiver('get_offset_value', this, [name]);
  num get value => _staticInfo.callMethodOnReceiver('get_value', this, []);
  void removeOffsetValue(String name) => _staticInfo.callMethodOnReceiver('remove_offset_value', this, [name]);
  void set inverted(bool inverted) => _staticInfo.callMethodOnReceiver('set_inverted', this, [inverted]);
  void set maxValue(num value) => _staticInfo.callMethodOnReceiver('set_max_value', this, [value]);
  void set minValue(num value) => _staticInfo.callMethodOnReceiver('set_min_value', this, [value]);
  void set mode(LevelBarMode mode) => _staticInfo.callMethodOnReceiver('set_mode', this, [mode]);
  void set value(num value) => _staticInfo.callMethodOnReceiver('set_value', this, [value]);
  int _connectToOffsetChanged(bool after, void func(String name)) => signalConnect('offset-changed', func, after);
  Stream<String> get onOffsetChanged {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToOffsetChanged(false, (String name) {
              controller.add(name);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<String> get afterOffsetChanged {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToOffsetChanged(true, (String name) {
              controller.add(name);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class LevelBarAccessible extends WidgetAccessible with Component, atk.Value {
  LevelBarAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'LevelBarAccessible');

}

class LevelBarMode extends GEnumBase {
  const LevelBarMode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'LevelBarMode');

  static const LevelBarMode CONTINUOUS = const LevelBarMode(0);
  static const LevelBarMode DISCRETE = const LevelBarMode(1);
  String toString() {
    switch(index) {
      case 0: return 'LevelBarMode.CONTINUOUS';
      case 1: return 'LevelBarMode.DISCRETE';
      default: return 'new LevelBarMode($index)';
    }
  }
}

class License extends GEnumBase {
  const License(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'License');

  static const License UNKNOWN = const License(0);
  static const License CUSTOM = const License(1);
  static const License GPL_2_0 = const License(2);
  static const License GPL_3_0 = const License(3);
  static const License LGPL_2_1 = const License(4);
  static const License LGPL_3_0 = const License(5);
  static const License BSD = const License(6);
  static const License MIT_X11 = const License(7);
  static const License ARTISTIC = const License(8);
  static const License GPL_2_0_ONLY = const License(9);
  static const License GPL_3_0_ONLY = const License(10);
  static const License LGPL_2_1_ONLY = const License(11);
  static const License LGPL_3_0_ONLY = const License(12);
  String toString() {
    switch(index) {
      case 0: return 'License.UNKNOWN';
      case 1: return 'License.CUSTOM';
      case 2: return 'License.GPL_2_0';
      case 3: return 'License.GPL_3_0';
      case 4: return 'License.LGPL_2_1';
      case 5: return 'License.LGPL_3_0';
      case 6: return 'License.BSD';
      case 7: return 'License.MIT_X11';
      case 8: return 'License.ARTISTIC';
      case 9: return 'License.GPL_2_0_ONLY';
      case 10: return 'License.GPL_3_0_ONLY';
      case 11: return 'License.LGPL_2_1_ONLY';
      case 12: return 'License.LGPL_3_0_ONLY';
      default: return 'new License($index)';
    }
  }
}

class LinkButton extends Button with ImplementorIface, Actionable, Activatable, Buildable {
  LinkButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'LinkButton');

  static const String URI_PROPERTY = 'uri';
  static const String VISITED_PROPERTY = 'visited';
  factory LinkButton(String uri) => _staticInfo.callStatic('new', [uri]);
  factory LinkButton.withLabel(String uri, String label) => _staticInfo.callStatic('new_with_label', [uri, label]);
  String get uri => _staticInfo.callMethodOnReceiver('get_uri', this, []);
  bool get visited => _staticInfo.callMethodOnReceiver('get_visited', this, []);
  void set uri(String uri) => _staticInfo.callMethodOnReceiver('set_uri', this, [uri]);
  void set visited(bool visited) => _staticInfo.callMethodOnReceiver('set_visited', this, [visited]);
  int _connectToActivateLink(bool after, bool func()) => signalConnect('activate-link', func, after);
  Stream<LinkButtonActivateLinkEvent> get onActivateLink {
    int signalId;
    StreamController<LinkButtonActivateLinkEvent> controller;
    controller = new StreamController<LinkButtonActivateLinkEvent>(
      onListen: () {
          signalId = _connectToActivateLink(false, () {
              var result = new LinkButtonActivateLinkEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<LinkButtonActivateLinkEvent> get afterActivateLink {
    int signalId;
    StreamController<LinkButtonActivateLinkEvent> controller;
    controller = new StreamController<LinkButtonActivateLinkEvent>(
      onListen: () {
          signalId = _connectToActivateLink(true, () {
              var result = new LinkButtonActivateLinkEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class LinkButtonActivateLinkEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  LinkButtonActivateLinkEvent();
}

class LinkButtonAccessible extends ButtonAccessible with atk.Action, Component, HyperlinkImpl, atk.Image {
  LinkButtonAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'LinkButtonAccessible');

}

class ListBox extends Container with ImplementorIface, Buildable {
  ListBox.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ListBox');

  static const String ACTIVATE_ON_SINGLE_CLICK_PROPERTY = 'activate-on-single-click';
  static const String SELECTION_MODE_PROPERTY = 'selection-mode';
  factory ListBox() => _staticInfo.callStatic('new', []);
  void bindModel(ListModel model, ListBoxCreateWidgetFunc createWidgetFunc) => _staticInfo.callMethodOnReceiver('bind_model', this, [model, createWidgetFunc]);
  void dragHighlightRow(ListBoxRow row) => _staticInfo.callMethodOnReceiver('drag_highlight_row', this, [row]);
  void dragUnhighlightRow() => _staticInfo.callMethodOnReceiver('drag_unhighlight_row', this, []);
  bool get activateOnSingleClick => _staticInfo.callMethodOnReceiver('get_activate_on_single_click', this, []);
  Adjustment getAdjustment() => _staticInfo.callMethodOnReceiver('get_adjustment', this, []);
  ListBoxRow getRowAtIndex(int index_) => _staticInfo.callMethodOnReceiver('get_row_at_index', this, [index_]);
  ListBoxRow getRowAtY(int y) => _staticInfo.callMethodOnReceiver('get_row_at_y', this, [y]);
  ListBoxRow getSelectedRow() => _staticInfo.callMethodOnReceiver('get_selected_row', this, []);
  GLibList /* this will fail */ getSelectedRows() => _staticInfo.callMethodOnReceiver('get_selected_rows', this, []);
  SelectionMode get selectionMode => _staticInfo.callMethodOnReceiver('get_selection_mode', this, []);
  void insert(Widget child, int position) => _staticInfo.callMethodOnReceiver('insert', this, [child, position]);
  void invalidateFilter() => _staticInfo.callMethodOnReceiver('invalidate_filter', this, []);
  void invalidateHeaders() => _staticInfo.callMethodOnReceiver('invalidate_headers', this, []);
  void invalidateSort() => _staticInfo.callMethodOnReceiver('invalidate_sort', this, []);
  void prepend(Widget child) => _staticInfo.callMethodOnReceiver('prepend', this, [child]);
  void selectAll() => _staticInfo.callMethodOnReceiver('select_all', this, []);
  void selectRow(ListBoxRow row) => _staticInfo.callMethodOnReceiver('select_row', this, [row]);
  void selectedForeach(ListBoxForeachFunc func) => _staticInfo.callMethodOnReceiver('selected_foreach', this, [func]);
  void set activateOnSingleClick(bool single) => _staticInfo.callMethodOnReceiver('set_activate_on_single_click', this, [single]);
  void setAdjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_adjustment', this, [adjustment]);
  void setFilterFunc(ListBoxFilterFunc filterFunc) => _staticInfo.callMethodOnReceiver('set_filter_func', this, [filterFunc]);
  void setHeaderFunc(ListBoxUpdateHeaderFunc updateHeader) => _staticInfo.callMethodOnReceiver('set_header_func', this, [updateHeader]);
  void setPlaceholder(Widget placeholder) => _staticInfo.callMethodOnReceiver('set_placeholder', this, [placeholder]);
  void set selectionMode(SelectionMode mode) => _staticInfo.callMethodOnReceiver('set_selection_mode', this, [mode]);
  void setSortFunc(ListBoxSortFunc sortFunc) => _staticInfo.callMethodOnReceiver('set_sort_func', this, [sortFunc]);
  void unselectAll() => _staticInfo.callMethodOnReceiver('unselect_all', this, []);
  void unselectRow(ListBoxRow row) => _staticInfo.callMethodOnReceiver('unselect_row', this, [row]);
  int _connectToActivateCursorRow(bool after, void func()) => signalConnect('activate-cursor-row', func, after);
  Stream get onActivateCursorRow {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivateCursorRow(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivateCursorRow {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivateCursorRow(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveCursor(bool after, void func(MovementStep object, int p0)) => signalConnect('move-cursor', func, after);
  Stream<ListBoxMoveCursorEvent> get onMoveCursor {
    int signalId;
    StreamController<ListBoxMoveCursorEvent> controller;
    controller = new StreamController<ListBoxMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(false, (MovementStep object, int p0) {
              var result = new ListBoxMoveCursorEvent(object, p0);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ListBoxMoveCursorEvent> get afterMoveCursor {
    int signalId;
    StreamController<ListBoxMoveCursorEvent> controller;
    controller = new StreamController<ListBoxMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(true, (MovementStep object, int p0) {
              var result = new ListBoxMoveCursorEvent(object, p0);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRowActivated(bool after, void func(ListBoxRow row)) => signalConnect('row-activated', func, after);
  Stream<ListBoxRow> get onRowActivated {
    int signalId;
    StreamController<ListBoxRow> controller;
    controller = new StreamController<ListBoxRow>(
      onListen: () {
          signalId = _connectToRowActivated(false, (ListBoxRow row) {
              controller.add(row);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ListBoxRow> get afterRowActivated {
    int signalId;
    StreamController<ListBoxRow> controller;
    controller = new StreamController<ListBoxRow>(
      onListen: () {
          signalId = _connectToRowActivated(true, (ListBoxRow row) {
              controller.add(row);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRowSelected(bool after, void func(ListBoxRow row)) => signalConnect('row-selected', func, after);
  Stream<ListBoxRow> get onRowSelected {
    int signalId;
    StreamController<ListBoxRow> controller;
    controller = new StreamController<ListBoxRow>(
      onListen: () {
          signalId = _connectToRowSelected(false, (ListBoxRow row) {
              controller.add(row);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ListBoxRow> get afterRowSelected {
    int signalId;
    StreamController<ListBoxRow> controller;
    controller = new StreamController<ListBoxRow>(
      onListen: () {
          signalId = _connectToRowSelected(true, (ListBoxRow row) {
              controller.add(row);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectAll(bool after, void func()) => signalConnect('select-all', func, after);
  Stream get onSelectAll {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectAll(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSelectAll {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectAll(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectedRowsChanged(bool after, void func()) => signalConnect('selected-rows-changed', func, after);
  Stream get onSelectedRowsChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectedRowsChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSelectedRowsChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectedRowsChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToToggleCursorRow(bool after, void func()) => signalConnect('toggle-cursor-row', func, after);
  Stream get onToggleCursorRow {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggleCursorRow(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterToggleCursorRow {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggleCursorRow(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToUnselectAll(bool after, void func()) => signalConnect('unselect-all', func, after);
  Stream get onUnselectAll {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUnselectAll(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterUnselectAll {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUnselectAll(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ListBoxMoveCursorEvent {
  final MovementStep object;
  final int p0;

  ListBoxMoveCursorEvent(this.object, this.p0);
}

class ListBoxAccessible extends ContainerAccessible with Component, Selection {
  ListBoxAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ListBoxAccessible');

}

typedef Widget ListBoxCreateWidgetFunc(GObjectObject item);
typedef bool ListBoxFilterFunc(ListBoxRow row);
typedef void ListBoxForeachFunc(ListBox box, ListBoxRow row);
class ListBoxRow extends Bin with ImplementorIface, Buildable {
  ListBoxRow.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ListBoxRow');

  static const String ACTIVATABLE_PROPERTY = 'activatable';
  static const String SELECTABLE_PROPERTY = 'selectable';
  factory ListBoxRow() => _staticInfo.callStatic('new', []);
  void changed() => _staticInfo.callMethodOnReceiver('changed', this, []);
  bool get activatable => _staticInfo.callMethodOnReceiver('get_activatable', this, []);
  Widget getHeader() => _staticInfo.callMethodOnReceiver('get_header', this, []);
  int getIndex() => _staticInfo.callMethodOnReceiver('get_index', this, []);
  bool get selectable => _staticInfo.callMethodOnReceiver('get_selectable', this, []);
  bool isSelected() => _staticInfo.callMethodOnReceiver('is_selected', this, []);
  void set activatable(bool activatable) => _staticInfo.callMethodOnReceiver('set_activatable', this, [activatable]);
  void setHeader(Widget header) => _staticInfo.callMethodOnReceiver('set_header', this, [header]);
  void set selectable(bool selectable) => _staticInfo.callMethodOnReceiver('set_selectable', this, [selectable]);
  int _connectToActivate(bool after, void func()) => signalConnect('activate', func, after);
  Stream get onActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ListBoxRowAccessible extends ContainerAccessible with Component {
  ListBoxRowAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ListBoxRowAccessible');

}

typedef int ListBoxSortFunc(ListBoxRow row1, ListBoxRow row2);
typedef void ListBoxUpdateHeaderFunc(ListBoxRow row, ListBoxRow before);
class ListStore extends GObjectObject with Buildable, TreeDragDest, TreeDragSource, TreeModel, TreeSortable {
  ListStore.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ListStore');

  factory ListStore(List<int> types) => _staticInfo.callStatic('new', [types]);
  void append() => _staticInfo.callMethodOnReceiver('append', this, []);
  void clear() => _staticInfo.callMethodOnReceiver('clear', this, []);
  void insert(int position) => _staticInfo.callMethodOnReceiver('insert', this, [position]);
  void insertAfter(TreeIter sibling) => _staticInfo.callMethodOnReceiver('insert_after', this, [sibling]);
  void insertBefore(TreeIter sibling) => _staticInfo.callMethodOnReceiver('insert_before', this, [sibling]);
  void insertWithValuesv(int position, List<int> columns, List<Value> values) => _staticInfo.callMethodOnReceiver('insert_with_valuesv', this, [position, columns, values]);
  bool iterIsValid(TreeIter iter) => _staticInfo.callMethodOnReceiver('iter_is_valid', this, [iter]);
  void moveAfter(TreeIter iter, TreeIter position) => _staticInfo.callMethodOnReceiver('move_after', this, [iter, position]);
  void moveBefore(TreeIter iter, TreeIter position) => _staticInfo.callMethodOnReceiver('move_before', this, [iter, position]);
  void prepend() => _staticInfo.callMethodOnReceiver('prepend', this, []);
  bool remove(TreeIter iter) => _staticInfo.callMethodOnReceiver('remove', this, [iter]);
  void reorder(List<int> newOrder) => _staticInfo.callMethodOnReceiver('reorder', this, [newOrder]);
  void setColumnTypes(List<int> types) => _staticInfo.callMethodOnReceiver('set_column_types', this, [types]);
  void setValue(TreeIter iter, int column, Value value) => _staticInfo.callMethodOnReceiver('set_value', this, [iter, column, value]);
  void set_(TreeIter iter, List<int> columns, List<Value> values) => _staticInfo.callMethodOnReceiver('set', this, [iter, columns, values]);
  void swap(TreeIter a, TreeIter b) => _staticInfo.callMethodOnReceiver('swap', this, [a, b]);
}

class LockButton extends Button with ImplementorIface, Actionable, Activatable, Buildable {
  LockButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'LockButton');

  static const String PERMISSION_PROPERTY = 'permission';
  String get textLock => _staticInfo.getGPropertyOnReceiver('text-lock', this);
  void set textLock(String value) => _staticInfo.setGPropertyOnReceiver('text-lock', this, value);
  static const String TEXT_LOCK_PROPERTY = 'text-lock';
  String get textUnlock => _staticInfo.getGPropertyOnReceiver('text-unlock', this);
  void set textUnlock(String value) => _staticInfo.setGPropertyOnReceiver('text-unlock', this, value);
  static const String TEXT_UNLOCK_PROPERTY = 'text-unlock';
  String get tooltipLock => _staticInfo.getGPropertyOnReceiver('tooltip-lock', this);
  void set tooltipLock(String value) => _staticInfo.setGPropertyOnReceiver('tooltip-lock', this, value);
  static const String TOOLTIP_LOCK_PROPERTY = 'tooltip-lock';
  String get tooltipNotAuthorized => _staticInfo.getGPropertyOnReceiver('tooltip-not-authorized', this);
  void set tooltipNotAuthorized(String value) => _staticInfo.setGPropertyOnReceiver('tooltip-not-authorized', this, value);
  static const String TOOLTIP_NOT_AUTHORIZED_PROPERTY = 'tooltip-not-authorized';
  String get tooltipUnlock => _staticInfo.getGPropertyOnReceiver('tooltip-unlock', this);
  void set tooltipUnlock(String value) => _staticInfo.setGPropertyOnReceiver('tooltip-unlock', this, value);
  static const String TOOLTIP_UNLOCK_PROPERTY = 'tooltip-unlock';
  factory LockButton(Permission permission) => _staticInfo.callStatic('new', [permission]);
  Permission get permission => _staticInfo.callMethodOnReceiver('get_permission', this, []);
  void set permission(Permission permission) => _staticInfo.callMethodOnReceiver('set_permission', this, [permission]);
}

class LockButtonAccessible extends ButtonAccessible with atk.Action, Component, atk.Image {
  LockButtonAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'LockButtonAccessible');

}

class Menu extends MenuShell with ImplementorIface, Buildable {
  Menu.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Menu');

  static const String ACCEL_GROUP_PROPERTY = 'accel-group';
  static const String ACCEL_PATH_PROPERTY = 'accel-path';
  static const String ACTIVE_PROPERTY = 'active';
  void set attachWidget(Widget value) => _staticInfo.setGPropertyOnReceiver('attach-widget', this, value);
  static const String ATTACH_WIDGET_PROPERTY = 'attach-widget';
  static const String MONITOR_PROPERTY = 'monitor';
  static const String RESERVE_TOGGLE_SIZE_PROPERTY = 'reserve-toggle-size';
  static const String TEAROFF_STATE_PROPERTY = 'tearoff-state';
  String get tearoffTitle => _staticInfo.getGPropertyOnReceiver('tearoff-title', this);
  void set tearoffTitle(String value) => _staticInfo.setGPropertyOnReceiver('tearoff-title', this, value);
  static const String TEAROFF_TITLE_PROPERTY = 'tearoff-title';
  factory Menu() => _staticInfo.callStatic('new', []);
  factory Menu.fromModel(MenuModel model) => _staticInfo.callStatic('new_from_model', [model]);
  static GLibList /* this will fail */ getForAttachWidget(Widget widget) => _staticInfo.callStatic('get_for_attach_widget', [widget]);
  void attach(Widget child, int leftAttach, int rightAttach, int topAttach, int bottomAttach) => _staticInfo.callMethodOnReceiver('attach', this, [child, leftAttach, rightAttach, topAttach, bottomAttach]);
  void attachToWidget(Widget attachWidget, MenuDetachFunc detacher) => _staticInfo.callMethodOnReceiver('attach_to_widget', this, [attachWidget, detacher]);
  void detach() => _staticInfo.callMethodOnReceiver('detach', this, []);
  AccelGroup get accelGroup => _staticInfo.callMethodOnReceiver('get_accel_group', this, []);
  String get accelPath => _staticInfo.callMethodOnReceiver('get_accel_path', this, []);
  Widget get menuActive => _staticInfo.callMethodOnReceiver('get_active', this, []);
  Widget get attachWidget_ => _staticInfo.callMethodOnReceiver('get_attach_widget', this, []);
  int get monitor => _staticInfo.callMethodOnReceiver('get_monitor', this, []);
  bool get reserveToggleSize => _staticInfo.callMethodOnReceiver('get_reserve_toggle_size', this, []);
  bool get tearoffState => _staticInfo.callMethodOnReceiver('get_tearoff_state', this, []);
  String getTitle() => _staticInfo.callMethodOnReceiver('get_title', this, []);
  void popdown() => _staticInfo.callMethodOnReceiver('popdown', this, []);
  void popup(Widget parentMenuShell, Widget parentMenuItem, MenuPositionFunc func, int button, int activateTime) => _staticInfo.callMethodOnReceiver('popup', this, [parentMenuShell, parentMenuItem, func, button, activateTime]);
  void popupForDevice(Device device, Widget parentMenuShell, Widget parentMenuItem, MenuPositionFunc func, int button, int activateTime) => _staticInfo.callMethodOnReceiver('popup_for_device', this, [device, parentMenuShell, parentMenuItem, func, button, activateTime]);
  void reorderChild(Widget child, int position) => _staticInfo.callMethodOnReceiver('reorder_child', this, [child, position]);
  void reposition() => _staticInfo.callMethodOnReceiver('reposition', this, []);
  void set accelGroup(AccelGroup accelGroup) => _staticInfo.callMethodOnReceiver('set_accel_group', this, [accelGroup]);
  void set accelPath(String accelPath) => _staticInfo.callMethodOnReceiver('set_accel_path', this, [accelPath]);
  void set active(int index) => _staticInfo.callMethodOnReceiver('set_active', this, [index]);
  void set monitor(int monitorNum) => _staticInfo.callMethodOnReceiver('set_monitor', this, [monitorNum]);
  void set reserveToggleSize(bool reserveToggleSize) => _staticInfo.callMethodOnReceiver('set_reserve_toggle_size', this, [reserveToggleSize]);
  void setScreen(Screen screen) => _staticInfo.callMethodOnReceiver('set_screen', this, [screen]);
  void set tearoffState(bool tornOff) => _staticInfo.callMethodOnReceiver('set_tearoff_state', this, [tornOff]);
  void setTitle(String title) => _staticInfo.callMethodOnReceiver('set_title', this, [title]);
  int _connectToMoveScroll(bool after, void func(ScrollType scrollType)) => signalConnect('move-scroll', func, after);
  Stream<ScrollType> get onMoveScroll {
    int signalId;
    StreamController<ScrollType> controller;
    controller = new StreamController<ScrollType>(
      onListen: () {
          signalId = _connectToMoveScroll(false, (ScrollType scrollType) {
              controller.add(scrollType);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ScrollType> get afterMoveScroll {
    int signalId;
    StreamController<ScrollType> controller;
    controller = new StreamController<ScrollType>(
      onListen: () {
          signalId = _connectToMoveScroll(true, (ScrollType scrollType) {
              controller.add(scrollType);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class MenuAccessible extends MenuShellAccessible with Component, Selection {
  MenuAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MenuAccessible');

}

class MenuBar extends MenuShell with ImplementorIface, Buildable {
  MenuBar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MenuBar');

  static const String CHILD_PACK_DIRECTION_PROPERTY = 'child-pack-direction';
  static const String PACK_DIRECTION_PROPERTY = 'pack-direction';
  factory MenuBar() => _staticInfo.callStatic('new', []);
  factory MenuBar.fromModel(MenuModel model) => _staticInfo.callStatic('new_from_model', [model]);
  PackDirection get childPackDirection => _staticInfo.callMethodOnReceiver('get_child_pack_direction', this, []);
  PackDirection get packDirection => _staticInfo.callMethodOnReceiver('get_pack_direction', this, []);
  void set childPackDirection(PackDirection childPackDir) => _staticInfo.callMethodOnReceiver('set_child_pack_direction', this, [childPackDir]);
  void set packDirection(PackDirection packDir) => _staticInfo.callMethodOnReceiver('set_pack_direction', this, [packDir]);
}

class MenuButton extends ToggleButton with ImplementorIface, Actionable, Activatable, Buildable {
  MenuButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MenuButton');

  static const String ALIGN_WIDGET_PROPERTY = 'align-widget';
  static const String DIRECTION_PROPERTY = 'direction';
  static const String MENU_MODEL_PROPERTY = 'menu-model';
  static const String POPOVER_PROPERTY = 'popover';
  static const String POPUP_PROPERTY = 'popup';
  static const String USE_POPOVER_PROPERTY = 'use-popover';
  factory MenuButton() => _staticInfo.callStatic('new', []);
  Widget get alignWidget => _staticInfo.callMethodOnReceiver('get_align_widget', this, []);
  ArrowType get direction => _staticInfo.callMethodOnReceiver('get_direction', this, []);
  MenuModel get menuModel => _staticInfo.callMethodOnReceiver('get_menu_model', this, []);
  Popover get popover => _staticInfo.callMethodOnReceiver('get_popover', this, []);
  Menu get popup => _staticInfo.callMethodOnReceiver('get_popup', this, []);
  bool get usePopover => _staticInfo.callMethodOnReceiver('get_use_popover', this, []);
  void set alignWidget(Widget alignWidget) => _staticInfo.callMethodOnReceiver('set_align_widget', this, [alignWidget]);
  void set direction(ArrowType direction) => _staticInfo.callMethodOnReceiver('set_direction', this, [direction]);
  void set menuModel(MenuModel menuModel) => _staticInfo.callMethodOnReceiver('set_menu_model', this, [menuModel]);
  void set popover(Widget popover) => _staticInfo.callMethodOnReceiver('set_popover', this, [popover]);
  void set popup(Widget menu) => _staticInfo.callMethodOnReceiver('set_popup', this, [menu]);
  void set usePopover(bool usePopover) => _staticInfo.callMethodOnReceiver('set_use_popover', this, [usePopover]);
}

class MenuButtonAccessible extends ToggleButtonAccessible with atk.Action, Component, atk.Image {
  MenuButtonAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MenuButtonAccessible');

}

typedef void MenuDetachFunc(Widget attachWidget, Menu menu);
class MenuDirectionType extends GEnumBase {
  const MenuDirectionType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MenuDirectionType');

  static const MenuDirectionType PARENT = const MenuDirectionType(0);
  static const MenuDirectionType CHILD = const MenuDirectionType(1);
  static const MenuDirectionType NEXT = const MenuDirectionType(2);
  static const MenuDirectionType PREV = const MenuDirectionType(3);
  String toString() {
    switch(index) {
      case 0: return 'MenuDirectionType.PARENT';
      case 1: return 'MenuDirectionType.CHILD';
      case 2: return 'MenuDirectionType.NEXT';
      case 3: return 'MenuDirectionType.PREV';
      default: return 'new MenuDirectionType($index)';
    }
  }
}

class MenuItem extends Bin with ImplementorIface, Actionable, Activatable, Buildable {
  MenuItem.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MenuItem');

  static const String ACCEL_PATH_PROPERTY = 'accel-path';
  static const String LABEL_PROPERTY = 'label';
  static const String RIGHT_JUSTIFIED_PROPERTY = 'right-justified';
  static const String SUBMENU_PROPERTY = 'submenu';
  static const String USE_UNDERLINE_PROPERTY = 'use-underline';
  factory MenuItem() => _staticInfo.callStatic('new', []);
  factory MenuItem.withLabel(String label) => _staticInfo.callStatic('new_with_label', [label]);
  factory MenuItem.withMnemonic(String label) => _staticInfo.callStatic('new_with_mnemonic', [label]);
  void menuItemActivate() => _staticInfo.callMethodOnReceiver('activate', this, []);
  void deselect() => _staticInfo.callMethodOnReceiver('deselect', this, []);
  String get accelPath => _staticInfo.callMethodOnReceiver('get_accel_path', this, []);
  String get label => _staticInfo.callMethodOnReceiver('get_label', this, []);
  bool getReserveIndicator() => _staticInfo.callMethodOnReceiver('get_reserve_indicator', this, []);
  bool get rightJustified => _staticInfo.callMethodOnReceiver('get_right_justified', this, []);
  Widget get submenu => _staticInfo.callMethodOnReceiver('get_submenu', this, []);
  bool get useUnderline => _staticInfo.callMethodOnReceiver('get_use_underline', this, []);
  void select() => _staticInfo.callMethodOnReceiver('select', this, []);
  void set accelPath(String accelPath) => _staticInfo.callMethodOnReceiver('set_accel_path', this, [accelPath]);
  void set label(String label) => _staticInfo.callMethodOnReceiver('set_label', this, [label]);
  void setReserveIndicator(bool reserve) => _staticInfo.callMethodOnReceiver('set_reserve_indicator', this, [reserve]);
  void set rightJustified(bool rightJustified) => _staticInfo.callMethodOnReceiver('set_right_justified', this, [rightJustified]);
  void set submenu(Menu submenu) => _staticInfo.callMethodOnReceiver('set_submenu', this, [submenu]);
  void set useUnderline(bool setting) => _staticInfo.callMethodOnReceiver('set_use_underline', this, [setting]);
  void toggleSizeAllocate(int allocation) => _staticInfo.callMethodOnReceiver('toggle_size_allocate', this, [allocation]);
  void toggleSizeRequest(int requisition) => _staticInfo.callMethodOnReceiver('toggle_size_request', this, [requisition]);
  int _connectToActivate(bool after, void func()) => signalConnect('activate', func, after);
  Stream get onActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToActivateItem(bool after, void func()) => signalConnect('activate-item', func, after);
  Stream get onActivateItem {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivateItem(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivateItem {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivateItem(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDeselect(bool after, void func()) => signalConnect('deselect', func, after);
  Stream get onDeselect {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDeselect(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterDeselect {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDeselect(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelect(bool after, void func()) => signalConnect('select', func, after);
  Stream get onSelect {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelect(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSelect {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelect(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToToggleSizeAllocate(bool after, void func(int object)) => signalConnect('toggle-size-allocate', func, after);
  Stream<int> get onToggleSizeAllocate {
    int signalId;
    StreamController<int> controller;
    controller = new StreamController<int>(
      onListen: () {
          signalId = _connectToToggleSizeAllocate(false, (int object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<int> get afterToggleSizeAllocate {
    int signalId;
    StreamController<int> controller;
    controller = new StreamController<int>(
      onListen: () {
          signalId = _connectToToggleSizeAllocate(true, (int object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToToggleSizeRequest(bool after, void func(dynamic object /* this will fail */)) => signalConnect('toggle-size-request', func, after);
  Stream<dynamic> get onToggleSizeRequest {
    int signalId;
    StreamController<dynamic> controller;
    controller = new StreamController<dynamic>(
      onListen: () {
          signalId = _connectToToggleSizeRequest(false, (dynamic object /* this will fail */) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<dynamic> get afterToggleSizeRequest {
    int signalId;
    StreamController<dynamic> controller;
    controller = new StreamController<dynamic>(
      onListen: () {
          signalId = _connectToToggleSizeRequest(true, (dynamic object /* this will fail */) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class MenuItemAccessible extends ContainerAccessible with atk.Action, Component, Selection {
  MenuItemAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MenuItemAccessible');

}

typedef List MenuPositionFunc(Menu menu, int x, int y);
class MenuShell extends Container with ImplementorIface, Buildable {
  MenuShell.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MenuShell');

  static const String TAKE_FOCUS_PROPERTY = 'take-focus';
  void activateItem(Widget menuItem, bool forceDeactivate) => _staticInfo.callMethodOnReceiver('activate_item', this, [menuItem, forceDeactivate]);
  void append(MenuItem child) => _staticInfo.callMethodOnReceiver('append', this, [child]);
  void bindModel(MenuModel model, String actionNamespace, bool withSeparators) => _staticInfo.callMethodOnReceiver('bind_model', this, [model, actionNamespace, withSeparators]);
  void cancel() => _staticInfo.callMethodOnReceiver('cancel', this, []);
  void deactivate() => _staticInfo.callMethodOnReceiver('deactivate', this, []);
  void deselect() => _staticInfo.callMethodOnReceiver('deselect', this, []);
  Widget getParentShell() => _staticInfo.callMethodOnReceiver('get_parent_shell', this, []);
  Widget getSelectedItem() => _staticInfo.callMethodOnReceiver('get_selected_item', this, []);
  bool get takeFocus => _staticInfo.callMethodOnReceiver('get_take_focus', this, []);
  void insert(Widget child, int position) => _staticInfo.callMethodOnReceiver('insert', this, [child, position]);
  void prepend(Widget child) => _staticInfo.callMethodOnReceiver('prepend', this, [child]);
  void selectFirst(bool searchSensitive) => _staticInfo.callMethodOnReceiver('select_first', this, [searchSensitive]);
  void selectItem(Widget menuItem) => _staticInfo.callMethodOnReceiver('select_item', this, [menuItem]);
  void set takeFocus(bool takeFocus) => _staticInfo.callMethodOnReceiver('set_take_focus', this, [takeFocus]);
  int _connectToActivateCurrent(bool after, void func(bool forceHide)) => signalConnect('activate-current', func, after);
  Stream<bool> get onActivateCurrent {
    int signalId;
    StreamController<bool> controller;
    controller = new StreamController<bool>(
      onListen: () {
          signalId = _connectToActivateCurrent(false, (bool forceHide) {
              controller.add(forceHide);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<bool> get afterActivateCurrent {
    int signalId;
    StreamController<bool> controller;
    controller = new StreamController<bool>(
      onListen: () {
          signalId = _connectToActivateCurrent(true, (bool forceHide) {
              controller.add(forceHide);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCancel(bool after, void func()) => signalConnect('cancel', func, after);
  Stream get onCancel {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCancel(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterCancel {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCancel(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCycleFocus(bool after, void func(DirectionType direction)) => signalConnect('cycle-focus', func, after);
  Stream<DirectionType> get onCycleFocus {
    int signalId;
    StreamController<DirectionType> controller;
    controller = new StreamController<DirectionType>(
      onListen: () {
          signalId = _connectToCycleFocus(false, (DirectionType direction) {
              controller.add(direction);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<DirectionType> get afterCycleFocus {
    int signalId;
    StreamController<DirectionType> controller;
    controller = new StreamController<DirectionType>(
      onListen: () {
          signalId = _connectToCycleFocus(true, (DirectionType direction) {
              controller.add(direction);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDeactivate(bool after, void func()) => signalConnect('deactivate', func, after);
  Stream get onDeactivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDeactivate(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterDeactivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDeactivate(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToInsert(bool after, void func(Widget child, int position)) => signalConnect('insert', func, after);
  Stream<MenuShellInsertEvent> get onInsert {
    int signalId;
    StreamController<MenuShellInsertEvent> controller;
    controller = new StreamController<MenuShellInsertEvent>(
      onListen: () {
          signalId = _connectToInsert(false, (Widget child, int position) {
              var result = new MenuShellInsertEvent(child, position);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<MenuShellInsertEvent> get afterInsert {
    int signalId;
    StreamController<MenuShellInsertEvent> controller;
    controller = new StreamController<MenuShellInsertEvent>(
      onListen: () {
          signalId = _connectToInsert(true, (Widget child, int position) {
              var result = new MenuShellInsertEvent(child, position);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveCurrent(bool after, void func(MenuDirectionType direction)) => signalConnect('move-current', func, after);
  Stream<MenuDirectionType> get onMoveCurrent {
    int signalId;
    StreamController<MenuDirectionType> controller;
    controller = new StreamController<MenuDirectionType>(
      onListen: () {
          signalId = _connectToMoveCurrent(false, (MenuDirectionType direction) {
              controller.add(direction);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<MenuDirectionType> get afterMoveCurrent {
    int signalId;
    StreamController<MenuDirectionType> controller;
    controller = new StreamController<MenuDirectionType>(
      onListen: () {
          signalId = _connectToMoveCurrent(true, (MenuDirectionType direction) {
              controller.add(direction);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveSelected(bool after, bool func(int distance)) => signalConnect('move-selected', func, after);
  Stream<MenuShellMoveSelectedEvent> get onMoveSelected {
    int signalId;
    StreamController<MenuShellMoveSelectedEvent> controller;
    controller = new StreamController<MenuShellMoveSelectedEvent>(
      onListen: () {
          signalId = _connectToMoveSelected(false, (int distance) {
              var result = new MenuShellMoveSelectedEvent(distance);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<MenuShellMoveSelectedEvent> get afterMoveSelected {
    int signalId;
    StreamController<MenuShellMoveSelectedEvent> controller;
    controller = new StreamController<MenuShellMoveSelectedEvent>(
      onListen: () {
          signalId = _connectToMoveSelected(true, (int distance) {
              var result = new MenuShellMoveSelectedEvent(distance);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectionDone(bool after, void func()) => signalConnect('selection-done', func, after);
  Stream get onSelectionDone {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectionDone(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSelectionDone {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectionDone(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class MenuShellInsertEvent {
  final Widget child;
  final int position;

  MenuShellInsertEvent(this.child, this.position);
}

class MenuShellMoveSelectedEvent {
  final int distance;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  MenuShellMoveSelectedEvent(this.distance);
}

class MenuShellAccessible extends ContainerAccessible with Component, Selection {
  MenuShellAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MenuShellAccessible');

}

class MenuToolButton extends ToolButton with ImplementorIface, Actionable, Activatable, Buildable {
  MenuToolButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MenuToolButton');

  static const String MENU_PROPERTY = 'menu';
  factory MenuToolButton(Widget iconWidget, String label) => _staticInfo.callStatic('new', [iconWidget, label]);
  factory MenuToolButton.fromStock(String stockId) => _staticInfo.callStatic('new_from_stock', [stockId]);
  Widget get menu => _staticInfo.callMethodOnReceiver('get_menu', this, []);
  void setArrowTooltipMarkup(String markup) => _staticInfo.callMethodOnReceiver('set_arrow_tooltip_markup', this, [markup]);
  void setArrowTooltipText(String text) => _staticInfo.callMethodOnReceiver('set_arrow_tooltip_text', this, [text]);
  void set menu(Widget menu) => _staticInfo.callMethodOnReceiver('set_menu', this, [menu]);
  int _connectToShowMenu(bool after, void func()) => signalConnect('show-menu', func, after);
  Stream get onShowMenu {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToShowMenu(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterShowMenu {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToShowMenu(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class MessageDialog extends Dialog with ImplementorIface, Buildable {
  MessageDialog.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MessageDialog');

  void set buttons(ButtonsType value) => _staticInfo.setGPropertyOnReceiver('buttons', this, value);
  static const String BUTTONS_PROPERTY = 'buttons';
  static const String IMAGE_PROPERTY = 'image';
  static const String MESSAGE_AREA_PROPERTY = 'message-area';
  MessageType get messageType => _staticInfo.getGPropertyOnReceiver('message-type', this);
  void set messageType(MessageType value) => _staticInfo.setGPropertyOnReceiver('message-type', this, value);
  static const String MESSAGE_TYPE_PROPERTY = 'message-type';
  String get secondaryText => _staticInfo.getGPropertyOnReceiver('secondary-text', this);
  void set secondaryText(String value) => _staticInfo.setGPropertyOnReceiver('secondary-text', this, value);
  static const String SECONDARY_TEXT_PROPERTY = 'secondary-text';
  bool get secondaryUseMarkup => _staticInfo.getGPropertyOnReceiver('secondary-use-markup', this);
  void set secondaryUseMarkup(bool value) => _staticInfo.setGPropertyOnReceiver('secondary-use-markup', this, value);
  static const String SECONDARY_USE_MARKUP_PROPERTY = 'secondary-use-markup';
  String get text => _staticInfo.getGPropertyOnReceiver('text', this);
  void set text(String value) => _staticInfo.setGPropertyOnReceiver('text', this, value);
  static const String TEXT_PROPERTY = 'text';
  bool get useMarkup => _staticInfo.getGPropertyOnReceiver('use-markup', this);
  void set useMarkup(bool value) => _staticInfo.setGPropertyOnReceiver('use-markup', this, value);
  static const String USE_MARKUP_PROPERTY = 'use-markup';
  Widget get image => _staticInfo.callMethodOnReceiver('get_image', this, []);
  Widget get messageArea => _staticInfo.callMethodOnReceiver('get_message_area', this, []);
  void set image(Widget image) => _staticInfo.callMethodOnReceiver('set_image', this, [image]);
  void setMarkup(String str) => _staticInfo.callMethodOnReceiver('set_markup', this, [str]);
}

class MessageType extends GEnumBase {
  const MessageType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MessageType');

  static const MessageType INFO = const MessageType(0);
  static const MessageType WARNING = const MessageType(1);
  static const MessageType QUESTION = const MessageType(2);
  static const MessageType ERROR = const MessageType(3);
  static const MessageType OTHER = const MessageType(4);
  String toString() {
    switch(index) {
      case 0: return 'MessageType.INFO';
      case 1: return 'MessageType.WARNING';
      case 2: return 'MessageType.QUESTION';
      case 3: return 'MessageType.ERROR';
      case 4: return 'MessageType.OTHER';
      default: return 'new MessageType($index)';
    }
  }
}

class Misc extends Widget with ImplementorIface, Buildable {
  Misc.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Misc');

  num get xalign => _staticInfo.getGPropertyOnReceiver('xalign', this);
  void set xalign(num value) => _staticInfo.setGPropertyOnReceiver('xalign', this, value);
  static const String XALIGN_PROPERTY = 'xalign';
  int get xpad => _staticInfo.getGPropertyOnReceiver('xpad', this);
  void set xpad(int value) => _staticInfo.setGPropertyOnReceiver('xpad', this, value);
  static const String XPAD_PROPERTY = 'xpad';
  num get yalign => _staticInfo.getGPropertyOnReceiver('yalign', this);
  void set yalign(num value) => _staticInfo.setGPropertyOnReceiver('yalign', this, value);
  static const String YALIGN_PROPERTY = 'yalign';
  int get ypad => _staticInfo.getGPropertyOnReceiver('ypad', this);
  void set ypad(int value) => _staticInfo.setGPropertyOnReceiver('ypad', this, value);
  static const String YPAD_PROPERTY = 'ypad';
  void getAlignment() => _staticInfo.callMethodOnReceiver('get_alignment', this, []);
  void getPadding() => _staticInfo.callMethodOnReceiver('get_padding', this, []);
  void setAlignment(num xalign, num yalign) => _staticInfo.callMethodOnReceiver('set_alignment', this, [xalign, yalign]);
  void setPadding(int xpad, int ypad) => _staticInfo.callMethodOnReceiver('set_padding', this, [xpad, ypad]);
}

class ModelButton extends Button with ImplementorIface, Actionable, Activatable, Buildable {
  ModelButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ModelButton');

  bool get active => _staticInfo.getGPropertyOnReceiver('active', this);
  void set active(bool value) => _staticInfo.setGPropertyOnReceiver('active', this, value);
  static const String ACTIVE_PROPERTY = 'active';
  bool get centered => _staticInfo.getGPropertyOnReceiver('centered', this);
  void set centered(bool value) => _staticInfo.setGPropertyOnReceiver('centered', this, value);
  static const String CENTERED_PROPERTY = 'centered';
  Icon get icon => _staticInfo.getGPropertyOnReceiver('icon', this);
  void set icon(Icon value) => _staticInfo.setGPropertyOnReceiver('icon', this, value);
  static const String ICON_PROPERTY = 'icon';
  bool get iconic => _staticInfo.getGPropertyOnReceiver('iconic', this);
  void set iconic(bool value) => _staticInfo.setGPropertyOnReceiver('iconic', this, value);
  static const String ICONIC_PROPERTY = 'iconic';
  bool get inverted => _staticInfo.getGPropertyOnReceiver('inverted', this);
  void set inverted(bool value) => _staticInfo.setGPropertyOnReceiver('inverted', this, value);
  static const String INVERTED_PROPERTY = 'inverted';
  String get menuName => _staticInfo.getGPropertyOnReceiver('menu-name', this);
  void set menuName(String value) => _staticInfo.setGPropertyOnReceiver('menu-name', this, value);
  static const String MENU_NAME_PROPERTY = 'menu-name';
  ButtonRole get role => _staticInfo.getGPropertyOnReceiver('role', this);
  void set role(ButtonRole value) => _staticInfo.setGPropertyOnReceiver('role', this, value);
  static const String ROLE_PROPERTY = 'role';
  String get text => _staticInfo.getGPropertyOnReceiver('text', this);
  void set text(String value) => _staticInfo.setGPropertyOnReceiver('text', this, value);
  static const String TEXT_PROPERTY = 'text';
  factory ModelButton() => _staticInfo.callStatic('new', []);
}

typedef void ModuleDisplayInitFunc(Display display);
typedef void ModuleInitFunc(List<String> argv);
class MountOperation extends gio.MountOperation {
  MountOperation.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MountOperation');

  bool get isShowing => _staticInfo.getGPropertyOnReceiver('is-showing', this);
  static const String IS_SHOWING_PROPERTY = 'is-showing';
  static const String PARENT_PROPERTY = 'parent';
  static const String SCREEN_PROPERTY = 'screen';
  factory MountOperation(Window parent) => _staticInfo.callStatic('new', [parent]);
  Window get parent => _staticInfo.callMethodOnReceiver('get_parent', this, []);
  Screen get screen => _staticInfo.callMethodOnReceiver('get_screen', this, []);
  bool getIsShowing() => _staticInfo.callMethodOnReceiver('is_showing', this, []);
  void set parent(Window parent) => _staticInfo.callMethodOnReceiver('set_parent', this, [parent]);
  void set screen(Screen screen) => _staticInfo.callMethodOnReceiver('set_screen', this, [screen]);
}

class MovementStep extends GEnumBase {
  const MovementStep(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'MovementStep');

  static const MovementStep LOGICAL_POSITIONS = const MovementStep(0);
  static const MovementStep VISUAL_POSITIONS = const MovementStep(1);
  static const MovementStep WORDS = const MovementStep(2);
  static const MovementStep DISPLAY_LINES = const MovementStep(3);
  static const MovementStep DISPLAY_LINE_ENDS = const MovementStep(4);
  static const MovementStep PARAGRAPHS = const MovementStep(5);
  static const MovementStep PARAGRAPH_ENDS = const MovementStep(6);
  static const MovementStep PAGES = const MovementStep(7);
  static const MovementStep BUFFER_ENDS = const MovementStep(8);
  static const MovementStep HORIZONTAL_PAGES = const MovementStep(9);
  String toString() {
    switch(index) {
      case 0: return 'MovementStep.LOGICAL_POSITIONS';
      case 1: return 'MovementStep.VISUAL_POSITIONS';
      case 2: return 'MovementStep.WORDS';
      case 3: return 'MovementStep.DISPLAY_LINES';
      case 4: return 'MovementStep.DISPLAY_LINE_ENDS';
      case 5: return 'MovementStep.PARAGRAPHS';
      case 6: return 'MovementStep.PARAGRAPH_ENDS';
      case 7: return 'MovementStep.PAGES';
      case 8: return 'MovementStep.BUFFER_ENDS';
      case 9: return 'MovementStep.HORIZONTAL_PAGES';
      default: return 'new MovementStep($index)';
    }
  }
}

class Notebook extends Container with ImplementorIface, Buildable {
  Notebook.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Notebook');

  bool get enablePopup => _staticInfo.getGPropertyOnReceiver('enable-popup', this);
  void set enablePopup(bool value) => _staticInfo.setGPropertyOnReceiver('enable-popup', this, value);
  static const String ENABLE_POPUP_PROPERTY = 'enable-popup';
  static const String GROUP_NAME_PROPERTY = 'group-name';
  int get page => _staticInfo.getGPropertyOnReceiver('page', this);
  void set page(int value) => _staticInfo.setGPropertyOnReceiver('page', this, value);
  static const String PAGE_PROPERTY = 'page';
  static const String SCROLLABLE_PROPERTY = 'scrollable';
  static const String SHOW_BORDER_PROPERTY = 'show-border';
  static const String SHOW_TABS_PROPERTY = 'show-tabs';
  static const String TAB_POS_PROPERTY = 'tab-pos';
  factory Notebook() => _staticInfo.callStatic('new', []);
  int appendPage(Widget child, Widget tabLabel) => _staticInfo.callMethodOnReceiver('append_page', this, [child, tabLabel]);
  int appendPageMenu(Widget child, Widget tabLabel, Widget menuLabel) => _staticInfo.callMethodOnReceiver('append_page_menu', this, [child, tabLabel, menuLabel]);
  void detachTab(Widget child) => _staticInfo.callMethodOnReceiver('detach_tab', this, [child]);
  Widget getActionWidget(PackType packType) => _staticInfo.callMethodOnReceiver('get_action_widget', this, [packType]);
  int getCurrentPage() => _staticInfo.callMethodOnReceiver('get_current_page', this, []);
  String get groupName => _staticInfo.callMethodOnReceiver('get_group_name', this, []);
  Widget getMenuLabel(Widget child) => _staticInfo.callMethodOnReceiver('get_menu_label', this, [child]);
  String getMenuLabelText(Widget child) => _staticInfo.callMethodOnReceiver('get_menu_label_text', this, [child]);
  int getNPages() => _staticInfo.callMethodOnReceiver('get_n_pages', this, []);
  Widget getNthPage(int pageNum) => _staticInfo.callMethodOnReceiver('get_nth_page', this, [pageNum]);
  bool get scrollable => _staticInfo.callMethodOnReceiver('get_scrollable', this, []);
  bool get showBorder => _staticInfo.callMethodOnReceiver('get_show_border', this, []);
  bool get showTabs => _staticInfo.callMethodOnReceiver('get_show_tabs', this, []);
  bool getTabDetachable(Widget child) => _staticInfo.callMethodOnReceiver('get_tab_detachable', this, [child]);
  int getTabHborder() => _staticInfo.callMethodOnReceiver('get_tab_hborder', this, []);
  Widget getTabLabel(Widget child) => _staticInfo.callMethodOnReceiver('get_tab_label', this, [child]);
  String getTabLabelText(Widget child) => _staticInfo.callMethodOnReceiver('get_tab_label_text', this, [child]);
  PositionType get tabPos => _staticInfo.callMethodOnReceiver('get_tab_pos', this, []);
  bool getTabReorderable(Widget child) => _staticInfo.callMethodOnReceiver('get_tab_reorderable', this, [child]);
  int getTabVborder() => _staticInfo.callMethodOnReceiver('get_tab_vborder', this, []);
  int insertPage(Widget child, Widget tabLabel, int position) => _staticInfo.callMethodOnReceiver('insert_page', this, [child, tabLabel, position]);
  int insertPageMenu(Widget child, Widget tabLabel, Widget menuLabel, int position) => _staticInfo.callMethodOnReceiver('insert_page_menu', this, [child, tabLabel, menuLabel, position]);
  void nextPage() => _staticInfo.callMethodOnReceiver('next_page', this, []);
  int pageNum(Widget child) => _staticInfo.callMethodOnReceiver('page_num', this, [child]);
  void popupDisable() => _staticInfo.callMethodOnReceiver('popup_disable', this, []);
  void popupEnable() => _staticInfo.callMethodOnReceiver('popup_enable', this, []);
  int prependPage(Widget child, Widget tabLabel) => _staticInfo.callMethodOnReceiver('prepend_page', this, [child, tabLabel]);
  int prependPageMenu(Widget child, Widget tabLabel, Widget menuLabel) => _staticInfo.callMethodOnReceiver('prepend_page_menu', this, [child, tabLabel, menuLabel]);
  void prevPage() => _staticInfo.callMethodOnReceiver('prev_page', this, []);
  void removePage(int pageNum) => _staticInfo.callMethodOnReceiver('remove_page', this, [pageNum]);
  void reorderChild(Widget child, int position) => _staticInfo.callMethodOnReceiver('reorder_child', this, [child, position]);
  void setActionWidget(Widget widget, PackType packType) => _staticInfo.callMethodOnReceiver('set_action_widget', this, [widget, packType]);
  void setCurrentPage(int pageNum) => _staticInfo.callMethodOnReceiver('set_current_page', this, [pageNum]);
  void set groupName(String groupName) => _staticInfo.callMethodOnReceiver('set_group_name', this, [groupName]);
  void setMenuLabel(Widget child, Widget menuLabel) => _staticInfo.callMethodOnReceiver('set_menu_label', this, [child, menuLabel]);
  void setMenuLabelText(Widget child, String menuText) => _staticInfo.callMethodOnReceiver('set_menu_label_text', this, [child, menuText]);
  void set scrollable(bool scrollable) => _staticInfo.callMethodOnReceiver('set_scrollable', this, [scrollable]);
  void set showBorder(bool showBorder) => _staticInfo.callMethodOnReceiver('set_show_border', this, [showBorder]);
  void set showTabs(bool showTabs) => _staticInfo.callMethodOnReceiver('set_show_tabs', this, [showTabs]);
  void setTabDetachable(Widget child, bool detachable) => _staticInfo.callMethodOnReceiver('set_tab_detachable', this, [child, detachable]);
  void setTabLabel(Widget child, Widget tabLabel) => _staticInfo.callMethodOnReceiver('set_tab_label', this, [child, tabLabel]);
  void setTabLabelText(Widget child, String tabText) => _staticInfo.callMethodOnReceiver('set_tab_label_text', this, [child, tabText]);
  void set tabPos(PositionType pos) => _staticInfo.callMethodOnReceiver('set_tab_pos', this, [pos]);
  void setTabReorderable(Widget child, bool reorderable) => _staticInfo.callMethodOnReceiver('set_tab_reorderable', this, [child, reorderable]);
  int _connectToChangeCurrentPage(bool after, bool func(int object)) => signalConnect('change-current-page', func, after);
  Stream<NotebookChangeCurrentPageEvent> get onChangeCurrentPage {
    int signalId;
    StreamController<NotebookChangeCurrentPageEvent> controller;
    controller = new StreamController<NotebookChangeCurrentPageEvent>(
      onListen: () {
          signalId = _connectToChangeCurrentPage(false, (int object) {
              var result = new NotebookChangeCurrentPageEvent(object);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<NotebookChangeCurrentPageEvent> get afterChangeCurrentPage {
    int signalId;
    StreamController<NotebookChangeCurrentPageEvent> controller;
    controller = new StreamController<NotebookChangeCurrentPageEvent>(
      onListen: () {
          signalId = _connectToChangeCurrentPage(true, (int object) {
              var result = new NotebookChangeCurrentPageEvent(object);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int connectToCreateWindow(bool after, Notebook func(Widget page, int x, int y)) => signalConnect('create-window', func, after);
  int _connectToFocusTab(bool after, bool func(NotebookTab object)) => signalConnect('focus-tab', func, after);
  Stream<NotebookFocusTabEvent> get onFocusTab {
    int signalId;
    StreamController<NotebookFocusTabEvent> controller;
    controller = new StreamController<NotebookFocusTabEvent>(
      onListen: () {
          signalId = _connectToFocusTab(false, (NotebookTab object) {
              var result = new NotebookFocusTabEvent(object);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<NotebookFocusTabEvent> get afterFocusTab {
    int signalId;
    StreamController<NotebookFocusTabEvent> controller;
    controller = new StreamController<NotebookFocusTabEvent>(
      onListen: () {
          signalId = _connectToFocusTab(true, (NotebookTab object) {
              var result = new NotebookFocusTabEvent(object);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveFocusOut(bool after, void func(DirectionType object)) => signalConnect('move-focus-out', func, after);
  Stream<DirectionType> get onMoveFocusOut {
    int signalId;
    StreamController<DirectionType> controller;
    controller = new StreamController<DirectionType>(
      onListen: () {
          signalId = _connectToMoveFocusOut(false, (DirectionType object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<DirectionType> get afterMoveFocusOut {
    int signalId;
    StreamController<DirectionType> controller;
    controller = new StreamController<DirectionType>(
      onListen: () {
          signalId = _connectToMoveFocusOut(true, (DirectionType object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPageAdded(bool after, void func(Widget child, int pageNum)) => signalConnect('page-added', func, after);
  Stream<NotebookPageAddedEvent> get onPageAdded {
    int signalId;
    StreamController<NotebookPageAddedEvent> controller;
    controller = new StreamController<NotebookPageAddedEvent>(
      onListen: () {
          signalId = _connectToPageAdded(false, (Widget child, int pageNum) {
              var result = new NotebookPageAddedEvent(child, pageNum);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<NotebookPageAddedEvent> get afterPageAdded {
    int signalId;
    StreamController<NotebookPageAddedEvent> controller;
    controller = new StreamController<NotebookPageAddedEvent>(
      onListen: () {
          signalId = _connectToPageAdded(true, (Widget child, int pageNum) {
              var result = new NotebookPageAddedEvent(child, pageNum);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPageRemoved(bool after, void func(Widget child, int pageNum)) => signalConnect('page-removed', func, after);
  Stream<NotebookPageRemovedEvent> get onPageRemoved {
    int signalId;
    StreamController<NotebookPageRemovedEvent> controller;
    controller = new StreamController<NotebookPageRemovedEvent>(
      onListen: () {
          signalId = _connectToPageRemoved(false, (Widget child, int pageNum) {
              var result = new NotebookPageRemovedEvent(child, pageNum);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<NotebookPageRemovedEvent> get afterPageRemoved {
    int signalId;
    StreamController<NotebookPageRemovedEvent> controller;
    controller = new StreamController<NotebookPageRemovedEvent>(
      onListen: () {
          signalId = _connectToPageRemoved(true, (Widget child, int pageNum) {
              var result = new NotebookPageRemovedEvent(child, pageNum);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPageReordered(bool after, void func(Widget child, int pageNum)) => signalConnect('page-reordered', func, after);
  Stream<NotebookPageReorderedEvent> get onPageReordered {
    int signalId;
    StreamController<NotebookPageReorderedEvent> controller;
    controller = new StreamController<NotebookPageReorderedEvent>(
      onListen: () {
          signalId = _connectToPageReordered(false, (Widget child, int pageNum) {
              var result = new NotebookPageReorderedEvent(child, pageNum);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<NotebookPageReorderedEvent> get afterPageReordered {
    int signalId;
    StreamController<NotebookPageReorderedEvent> controller;
    controller = new StreamController<NotebookPageReorderedEvent>(
      onListen: () {
          signalId = _connectToPageReordered(true, (Widget child, int pageNum) {
              var result = new NotebookPageReorderedEvent(child, pageNum);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToReorderTab(bool after, bool func(DirectionType object, bool p0)) => signalConnect('reorder-tab', func, after);
  Stream<NotebookReorderTabEvent> get onReorderTab {
    int signalId;
    StreamController<NotebookReorderTabEvent> controller;
    controller = new StreamController<NotebookReorderTabEvent>(
      onListen: () {
          signalId = _connectToReorderTab(false, (DirectionType object, bool p0) {
              var result = new NotebookReorderTabEvent(object, p0);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<NotebookReorderTabEvent> get afterReorderTab {
    int signalId;
    StreamController<NotebookReorderTabEvent> controller;
    controller = new StreamController<NotebookReorderTabEvent>(
      onListen: () {
          signalId = _connectToReorderTab(true, (DirectionType object, bool p0) {
              var result = new NotebookReorderTabEvent(object, p0);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectPage(bool after, bool func(bool object)) => signalConnect('select-page', func, after);
  Stream<NotebookSelectPageEvent> get onSelectPage {
    int signalId;
    StreamController<NotebookSelectPageEvent> controller;
    controller = new StreamController<NotebookSelectPageEvent>(
      onListen: () {
          signalId = _connectToSelectPage(false, (bool object) {
              var result = new NotebookSelectPageEvent(object);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<NotebookSelectPageEvent> get afterSelectPage {
    int signalId;
    StreamController<NotebookSelectPageEvent> controller;
    controller = new StreamController<NotebookSelectPageEvent>(
      onListen: () {
          signalId = _connectToSelectPage(true, (bool object) {
              var result = new NotebookSelectPageEvent(object);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSwitchPage(bool after, void func(Widget page, int pageNum)) => signalConnect('switch-page', func, after);
  Stream<NotebookSwitchPageEvent> get onSwitchPage {
    int signalId;
    StreamController<NotebookSwitchPageEvent> controller;
    controller = new StreamController<NotebookSwitchPageEvent>(
      onListen: () {
          signalId = _connectToSwitchPage(false, (Widget page, int pageNum) {
              var result = new NotebookSwitchPageEvent(page, pageNum);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<NotebookSwitchPageEvent> get afterSwitchPage {
    int signalId;
    StreamController<NotebookSwitchPageEvent> controller;
    controller = new StreamController<NotebookSwitchPageEvent>(
      onListen: () {
          signalId = _connectToSwitchPage(true, (Widget page, int pageNum) {
              var result = new NotebookSwitchPageEvent(page, pageNum);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class NotebookChangeCurrentPageEvent {
  final int object;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  NotebookChangeCurrentPageEvent(this.object);
}

class NotebookFocusTabEvent {
  final NotebookTab object;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  NotebookFocusTabEvent(this.object);
}

class NotebookPageAddedEvent {
  final Widget child;
  final int pageNum;

  NotebookPageAddedEvent(this.child, this.pageNum);
}

class NotebookPageRemovedEvent {
  final Widget child;
  final int pageNum;

  NotebookPageRemovedEvent(this.child, this.pageNum);
}

class NotebookPageReorderedEvent {
  final Widget child;
  final int pageNum;

  NotebookPageReorderedEvent(this.child, this.pageNum);
}

class NotebookReorderTabEvent {
  final DirectionType object;
  final bool p0;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  NotebookReorderTabEvent(this.object, this.p0);
}

class NotebookSelectPageEvent {
  final bool object;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  NotebookSelectPageEvent(this.object);
}

class NotebookSwitchPageEvent {
  final Widget page;
  final int pageNum;

  NotebookSwitchPageEvent(this.page, this.pageNum);
}

class NotebookAccessible extends ContainerAccessible with Component, Selection {
  NotebookAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'NotebookAccessible');

}

class NotebookPageAccessible extends AtkObject with Component {
  NotebookPageAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'NotebookPageAccessible');

  factory NotebookPageAccessible(NotebookAccessible notebook, Widget child) => _staticInfo.callStatic('new', [notebook, child]);
  void invalidate() => _staticInfo.callMethodOnReceiver('invalidate', this, []);
}

class NotebookTab extends GEnumBase {
  const NotebookTab(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'NotebookTab');

  static const NotebookTab FIRST = const NotebookTab(0);
  static const NotebookTab LAST = const NotebookTab(1);
  String toString() {
    switch(index) {
      case 0: return 'NotebookTab.FIRST';
      case 1: return 'NotebookTab.LAST';
      default: return 'new NotebookTab($index)';
    }
  }
}

class NumberUpLayout extends GEnumBase {
  const NumberUpLayout(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'NumberUpLayout');

  static const NumberUpLayout LRTB = const NumberUpLayout(0);
  static const NumberUpLayout LRBT = const NumberUpLayout(1);
  static const NumberUpLayout RLTB = const NumberUpLayout(2);
  static const NumberUpLayout RLBT = const NumberUpLayout(3);
  static const NumberUpLayout TBLR = const NumberUpLayout(4);
  static const NumberUpLayout TBRL = const NumberUpLayout(5);
  static const NumberUpLayout BTLR = const NumberUpLayout(6);
  static const NumberUpLayout BTRL = const NumberUpLayout(7);
  String toString() {
    switch(index) {
      case 0: return 'NumberUpLayout.LRTB';
      case 1: return 'NumberUpLayout.LRBT';
      case 2: return 'NumberUpLayout.RLTB';
      case 3: return 'NumberUpLayout.RLBT';
      case 4: return 'NumberUpLayout.TBLR';
      case 5: return 'NumberUpLayout.TBRL';
      case 6: return 'NumberUpLayout.BTLR';
      case 7: return 'NumberUpLayout.BTRL';
      default: return 'new NumberUpLayout($index)';
    }
  }
}

class NumerableIcon extends EmblemedIcon with Icon {
  NumerableIcon.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'NumerableIcon');

  Icon get backgroundIcon => _staticInfo.getGPropertyOnReceiver('background-icon', this);
  void set backgroundIcon(Icon value) => _staticInfo.setGPropertyOnReceiver('background-icon', this, value);
  static const String BACKGROUND_ICON_PROPERTY = 'background-icon';
  static const String BACKGROUND_ICON_NAME_PROPERTY = 'background-icon-name';
  static const String COUNT_PROPERTY = 'count';
  static const String LABEL_PROPERTY = 'label';
  static const String STYLE_CONTEXT_PROPERTY = 'style-context';
  static Icon new_(Icon baseIcon) => _staticInfo.callStatic('new', [baseIcon]);
  static Icon newWithStyleContext(Icon baseIcon, StyleContext context) => _staticInfo.callStatic('new_with_style_context', [baseIcon, context]);
  Icon getBackgroundGicon() => _staticInfo.callMethodOnReceiver('get_background_gicon', this, []);
  String get backgroundIconName => _staticInfo.callMethodOnReceiver('get_background_icon_name', this, []);
  int get count => _staticInfo.callMethodOnReceiver('get_count', this, []);
  String get label => _staticInfo.callMethodOnReceiver('get_label', this, []);
  StyleContext get styleContext => _staticInfo.callMethodOnReceiver('get_style_context', this, []);
  void setBackgroundGicon(Icon icon) => _staticInfo.callMethodOnReceiver('set_background_gicon', this, [icon]);
  void set backgroundIconName(String iconName) => _staticInfo.callMethodOnReceiver('set_background_icon_name', this, [iconName]);
  void set count(int count) => _staticInfo.callMethodOnReceiver('set_count', this, [count]);
  void set label(String label) => _staticInfo.callMethodOnReceiver('set_label', this, [label]);
  void set styleContext(StyleContext style) => _staticInfo.callMethodOnReceiver('set_style_context', this, [style]);
}

class OffscreenWindow extends Window with ImplementorIface, Buildable {
  OffscreenWindow.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'OffscreenWindow');

  factory OffscreenWindow() => _staticInfo.callStatic('new', []);
  Pixbuf getPixbuf() => _staticInfo.callMethodOnReceiver('get_pixbuf', this, []);
  Surface getSurface() => _staticInfo.callMethodOnReceiver('get_surface', this, []);
}

abstract class Orientable extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Orientable');



  static const String ORIENTATION_PROPERTY = 'orientation';
  Orientation get orientation => _staticInfo.callMethodOnReceiver('get_orientation', this, []);
  void set orientation(Orientation orientation) => _staticInfo.callMethodOnReceiver('set_orientation', this, [orientation]);
}

class Orientation extends GEnumBase {
  const Orientation(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Orientation');

  static const Orientation HORIZONTAL = const Orientation(0);
  static const Orientation VERTICAL = const Orientation(1);
  String toString() {
    switch(index) {
      case 0: return 'Orientation.HORIZONTAL';
      case 1: return 'Orientation.VERTICAL';
      default: return 'new Orientation($index)';
    }
  }
}

class Overlay extends Bin with ImplementorIface, Buildable {
  Overlay.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Overlay');

  factory Overlay() => _staticInfo.callStatic('new', []);
  void addOverlay(Widget widget) => _staticInfo.callMethodOnReceiver('add_overlay', this, [widget]);
  bool getOverlayPassThrough(Widget widget) => _staticInfo.callMethodOnReceiver('get_overlay_pass_through', this, [widget]);
  void reorderOverlay(Widget child, int position) => _staticInfo.callMethodOnReceiver('reorder_overlay', this, [child, position]);
  void setOverlayPassThrough(Widget widget, bool passThrough) => _staticInfo.callMethodOnReceiver('set_overlay_pass_through', this, [widget, passThrough]);
  int connectToGetChildPosition(bool after, List func(Widget widget)) => signalConnect('get-child-position', func, after);
}

class PackDirection extends GEnumBase {
  const PackDirection(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PackDirection');

  static const PackDirection LTR = const PackDirection(0);
  static const PackDirection RTL = const PackDirection(1);
  static const PackDirection TTB = const PackDirection(2);
  static const PackDirection BTT = const PackDirection(3);
  String toString() {
    switch(index) {
      case 0: return 'PackDirection.LTR';
      case 1: return 'PackDirection.RTL';
      case 2: return 'PackDirection.TTB';
      case 3: return 'PackDirection.BTT';
      default: return 'new PackDirection($index)';
    }
  }
}

class PackType extends GEnumBase {
  const PackType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PackType');

  static const PackType START = const PackType(0);
  static const PackType END = const PackType(1);
  String toString() {
    switch(index) {
      case 0: return 'PackType.START';
      case 1: return 'PackType.END';
      default: return 'new PackType($index)';
    }
  }
}

class PageOrientation extends GEnumBase {
  const PageOrientation(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PageOrientation');

  static const PageOrientation PORTRAIT = const PageOrientation(0);
  static const PageOrientation LANDSCAPE = const PageOrientation(1);
  static const PageOrientation REVERSE_PORTRAIT = const PageOrientation(2);
  static const PageOrientation REVERSE_LANDSCAPE = const PageOrientation(3);
  String toString() {
    switch(index) {
      case 0: return 'PageOrientation.PORTRAIT';
      case 1: return 'PageOrientation.LANDSCAPE';
      case 2: return 'PageOrientation.REVERSE_PORTRAIT';
      case 3: return 'PageOrientation.REVERSE_LANDSCAPE';
      default: return 'new PageOrientation($index)';
    }
  }
}

class PageRange extends GObjectBase {
  PageRange.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PageRange');

  int get start => getFieldOfObject('start', 0);
  void set start(int value) => setFieldOfObject('start', 0, value);
  int get end => getFieldOfObject('end', 1);
  void set end(int value) => setFieldOfObject('end', 1, value);
}

class PageSet extends GEnumBase {
  const PageSet(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PageSet');

  static const PageSet ALL = const PageSet(0);
  static const PageSet EVEN = const PageSet(1);
  static const PageSet ODD = const PageSet(2);
  String toString() {
    switch(index) {
      case 0: return 'PageSet.ALL';
      case 1: return 'PageSet.EVEN';
      case 2: return 'PageSet.ODD';
      default: return 'new PageSet($index)';
    }
  }
}

class PageSetup extends GObjectObject {
  PageSetup.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PageSetup');

  factory PageSetup() => _staticInfo.callStatic('new', []);
  factory PageSetup.fromFile(String fileName) => _staticInfo.callStatic('new_from_file', [fileName]);
  factory PageSetup.fromKeyFile(KeyFile keyFile, String groupName) => _staticInfo.callStatic('new_from_key_file', [keyFile, groupName]);
  PageSetup copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  num getBottomMargin(Unit unit) => _staticInfo.callMethodOnReceiver('get_bottom_margin', this, [unit]);
  num getLeftMargin(Unit unit) => _staticInfo.callMethodOnReceiver('get_left_margin', this, [unit]);
  PageOrientation getOrientation() => _staticInfo.callMethodOnReceiver('get_orientation', this, []);
  num getPageHeight(Unit unit) => _staticInfo.callMethodOnReceiver('get_page_height', this, [unit]);
  num getPageWidth(Unit unit) => _staticInfo.callMethodOnReceiver('get_page_width', this, [unit]);
  num getPaperHeight(Unit unit) => _staticInfo.callMethodOnReceiver('get_paper_height', this, [unit]);
  PaperSize getPaperSize() => _staticInfo.callMethodOnReceiver('get_paper_size', this, []);
  num getPaperWidth(Unit unit) => _staticInfo.callMethodOnReceiver('get_paper_width', this, [unit]);
  num getRightMargin(Unit unit) => _staticInfo.callMethodOnReceiver('get_right_margin', this, [unit]);
  num getTopMargin(Unit unit) => _staticInfo.callMethodOnReceiver('get_top_margin', this, [unit]);
  bool loadFile(String fileName) => _staticInfo.callMethodOnReceiver('load_file', this, [fileName]);
  bool loadKeyFile(KeyFile keyFile, String groupName) => _staticInfo.callMethodOnReceiver('load_key_file', this, [keyFile, groupName]);
  void setBottomMargin(num margin, Unit unit) => _staticInfo.callMethodOnReceiver('set_bottom_margin', this, [margin, unit]);
  void setLeftMargin(num margin, Unit unit) => _staticInfo.callMethodOnReceiver('set_left_margin', this, [margin, unit]);
  void setOrientation(PageOrientation orientation) => _staticInfo.callMethodOnReceiver('set_orientation', this, [orientation]);
  void setPaperSize(PaperSize size) => _staticInfo.callMethodOnReceiver('set_paper_size', this, [size]);
  void setPaperSizeAndDefaultMargins(PaperSize size) => _staticInfo.callMethodOnReceiver('set_paper_size_and_default_margins', this, [size]);
  void setRightMargin(num margin, Unit unit) => _staticInfo.callMethodOnReceiver('set_right_margin', this, [margin, unit]);
  void setTopMargin(num margin, Unit unit) => _staticInfo.callMethodOnReceiver('set_top_margin', this, [margin, unit]);
  bool toFile(String fileName) => _staticInfo.callMethodOnReceiver('to_file', this, [fileName]);
  void toKeyFile(KeyFile keyFile, String groupName) => _staticInfo.callMethodOnReceiver('to_key_file', this, [keyFile, groupName]);
}

typedef void PageSetupDoneFunc(PageSetup pageSetup);
class PanDirection extends GEnumBase {
  const PanDirection(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PanDirection');

  static const PanDirection LEFT = const PanDirection(0);
  static const PanDirection RIGHT = const PanDirection(1);
  static const PanDirection UP = const PanDirection(2);
  static const PanDirection DOWN = const PanDirection(3);
  String toString() {
    switch(index) {
      case 0: return 'PanDirection.LEFT';
      case 1: return 'PanDirection.RIGHT';
      case 2: return 'PanDirection.UP';
      case 3: return 'PanDirection.DOWN';
      default: return 'new PanDirection($index)';
    }
  }
}

class Paned extends Container with ImplementorIface, Buildable, Orientable {
  Paned.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Paned');

  int get maxPosition => _staticInfo.getGPropertyOnReceiver('max-position', this);
  static const String MAX_POSITION_PROPERTY = 'max-position';
  int get minPosition => _staticInfo.getGPropertyOnReceiver('min-position', this);
  static const String MIN_POSITION_PROPERTY = 'min-position';
  static const String POSITION_PROPERTY = 'position';
  bool get positionSet => _staticInfo.getGPropertyOnReceiver('position-set', this);
  void set positionSet(bool value) => _staticInfo.setGPropertyOnReceiver('position-set', this, value);
  static const String POSITION_SET_PROPERTY = 'position-set';
  static const String WIDE_HANDLE_PROPERTY = 'wide-handle';
  factory Paned(Orientation orientation) => _staticInfo.callStatic('new', [orientation]);
  void add1(Widget child) => _staticInfo.callMethodOnReceiver('add1', this, [child]);
  void add2(Widget child) => _staticInfo.callMethodOnReceiver('add2', this, [child]);
  Widget getChild1() => _staticInfo.callMethodOnReceiver('get_child1', this, []);
  Widget getChild2() => _staticInfo.callMethodOnReceiver('get_child2', this, []);
  gdk.Window getHandleWindow() => _staticInfo.callMethodOnReceiver('get_handle_window', this, []);
  int get position => _staticInfo.callMethodOnReceiver('get_position', this, []);
  bool get wideHandle => _staticInfo.callMethodOnReceiver('get_wide_handle', this, []);
  void pack1(Widget child, bool resize, bool shrink) => _staticInfo.callMethodOnReceiver('pack1', this, [child, resize, shrink]);
  void pack2(Widget child, bool resize, bool shrink) => _staticInfo.callMethodOnReceiver('pack2', this, [child, resize, shrink]);
  void set position(int position) => _staticInfo.callMethodOnReceiver('set_position', this, [position]);
  void set wideHandle(bool wide) => _staticInfo.callMethodOnReceiver('set_wide_handle', this, [wide]);
  int _connectToAcceptPosition(bool after, bool func()) => signalConnect('accept-position', func, after);
  Stream<PanedAcceptPositionEvent> get onAcceptPosition {
    int signalId;
    StreamController<PanedAcceptPositionEvent> controller;
    controller = new StreamController<PanedAcceptPositionEvent>(
      onListen: () {
          signalId = _connectToAcceptPosition(false, () {
              var result = new PanedAcceptPositionEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PanedAcceptPositionEvent> get afterAcceptPosition {
    int signalId;
    StreamController<PanedAcceptPositionEvent> controller;
    controller = new StreamController<PanedAcceptPositionEvent>(
      onListen: () {
          signalId = _connectToAcceptPosition(true, () {
              var result = new PanedAcceptPositionEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCancelPosition(bool after, bool func()) => signalConnect('cancel-position', func, after);
  Stream<PanedCancelPositionEvent> get onCancelPosition {
    int signalId;
    StreamController<PanedCancelPositionEvent> controller;
    controller = new StreamController<PanedCancelPositionEvent>(
      onListen: () {
          signalId = _connectToCancelPosition(false, () {
              var result = new PanedCancelPositionEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PanedCancelPositionEvent> get afterCancelPosition {
    int signalId;
    StreamController<PanedCancelPositionEvent> controller;
    controller = new StreamController<PanedCancelPositionEvent>(
      onListen: () {
          signalId = _connectToCancelPosition(true, () {
              var result = new PanedCancelPositionEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCycleChildFocus(bool after, bool func(bool reversed)) => signalConnect('cycle-child-focus', func, after);
  Stream<PanedCycleChildFocusEvent> get onCycleChildFocus {
    int signalId;
    StreamController<PanedCycleChildFocusEvent> controller;
    controller = new StreamController<PanedCycleChildFocusEvent>(
      onListen: () {
          signalId = _connectToCycleChildFocus(false, (bool reversed) {
              var result = new PanedCycleChildFocusEvent(reversed);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PanedCycleChildFocusEvent> get afterCycleChildFocus {
    int signalId;
    StreamController<PanedCycleChildFocusEvent> controller;
    controller = new StreamController<PanedCycleChildFocusEvent>(
      onListen: () {
          signalId = _connectToCycleChildFocus(true, (bool reversed) {
              var result = new PanedCycleChildFocusEvent(reversed);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCycleHandleFocus(bool after, bool func(bool reversed)) => signalConnect('cycle-handle-focus', func, after);
  Stream<PanedCycleHandleFocusEvent> get onCycleHandleFocus {
    int signalId;
    StreamController<PanedCycleHandleFocusEvent> controller;
    controller = new StreamController<PanedCycleHandleFocusEvent>(
      onListen: () {
          signalId = _connectToCycleHandleFocus(false, (bool reversed) {
              var result = new PanedCycleHandleFocusEvent(reversed);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PanedCycleHandleFocusEvent> get afterCycleHandleFocus {
    int signalId;
    StreamController<PanedCycleHandleFocusEvent> controller;
    controller = new StreamController<PanedCycleHandleFocusEvent>(
      onListen: () {
          signalId = _connectToCycleHandleFocus(true, (bool reversed) {
              var result = new PanedCycleHandleFocusEvent(reversed);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveHandle(bool after, bool func(ScrollType scrollType)) => signalConnect('move-handle', func, after);
  Stream<PanedMoveHandleEvent> get onMoveHandle {
    int signalId;
    StreamController<PanedMoveHandleEvent> controller;
    controller = new StreamController<PanedMoveHandleEvent>(
      onListen: () {
          signalId = _connectToMoveHandle(false, (ScrollType scrollType) {
              var result = new PanedMoveHandleEvent(scrollType);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PanedMoveHandleEvent> get afterMoveHandle {
    int signalId;
    StreamController<PanedMoveHandleEvent> controller;
    controller = new StreamController<PanedMoveHandleEvent>(
      onListen: () {
          signalId = _connectToMoveHandle(true, (ScrollType scrollType) {
              var result = new PanedMoveHandleEvent(scrollType);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToToggleHandleFocus(bool after, bool func()) => signalConnect('toggle-handle-focus', func, after);
  Stream<PanedToggleHandleFocusEvent> get onToggleHandleFocus {
    int signalId;
    StreamController<PanedToggleHandleFocusEvent> controller;
    controller = new StreamController<PanedToggleHandleFocusEvent>(
      onListen: () {
          signalId = _connectToToggleHandleFocus(false, () {
              var result = new PanedToggleHandleFocusEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PanedToggleHandleFocusEvent> get afterToggleHandleFocus {
    int signalId;
    StreamController<PanedToggleHandleFocusEvent> controller;
    controller = new StreamController<PanedToggleHandleFocusEvent>(
      onListen: () {
          signalId = _connectToToggleHandleFocus(true, () {
              var result = new PanedToggleHandleFocusEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class PanedAcceptPositionEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  PanedAcceptPositionEvent();
}

class PanedCancelPositionEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  PanedCancelPositionEvent();
}

class PanedCycleChildFocusEvent {
  final bool reversed;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  PanedCycleChildFocusEvent(this.reversed);
}

class PanedCycleHandleFocusEvent {
  final bool reversed;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  PanedCycleHandleFocusEvent(this.reversed);
}

class PanedMoveHandleEvent {
  final ScrollType scrollType;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  PanedMoveHandleEvent(this.scrollType);
}

class PanedToggleHandleFocusEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  PanedToggleHandleFocusEvent();
}

class PanedAccessible extends ContainerAccessible with Component, atk.Value {
  PanedAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PanedAccessible');

}

class PaperSize extends GObjectBase {
  PaperSize.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PaperSize');

  factory PaperSize(String name) => _staticInfo.callStatic('new', [name]);
  factory PaperSize.custom(String name, String displayName, num width, num height, Unit unit) => _staticInfo.callStatic('new_custom', [name, displayName, width, height, unit]);
  factory PaperSize.fromIpp(String ippName, num width, num height) => _staticInfo.callStatic('new_from_ipp', [ippName, width, height]);
  factory PaperSize.fromKeyFile(KeyFile keyFile, String groupName) => _staticInfo.callStatic('new_from_key_file', [keyFile, groupName]);
  factory PaperSize.fromPpd(String ppdName, String ppdDisplayName, num width, num height) => _staticInfo.callStatic('new_from_ppd', [ppdName, ppdDisplayName, width, height]);
  PaperSize copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void free() => _staticInfo.callMethodOnReceiver('free', this, []);
  num getDefaultBottomMargin(Unit unit) => _staticInfo.callMethodOnReceiver('get_default_bottom_margin', this, [unit]);
  num getDefaultLeftMargin(Unit unit) => _staticInfo.callMethodOnReceiver('get_default_left_margin', this, [unit]);
  num getDefaultRightMargin(Unit unit) => _staticInfo.callMethodOnReceiver('get_default_right_margin', this, [unit]);
  num getDefaultTopMargin(Unit unit) => _staticInfo.callMethodOnReceiver('get_default_top_margin', this, [unit]);
  String getDisplayName() => _staticInfo.callMethodOnReceiver('get_display_name', this, []);
  num getHeight(Unit unit) => _staticInfo.callMethodOnReceiver('get_height', this, [unit]);
  String getName() => _staticInfo.callMethodOnReceiver('get_name', this, []);
  String getPpdName() => _staticInfo.callMethodOnReceiver('get_ppd_name', this, []);
  num getWidth(Unit unit) => _staticInfo.callMethodOnReceiver('get_width', this, [unit]);
  bool isCustom() => _staticInfo.callMethodOnReceiver('is_custom', this, []);
  bool isEqual(PaperSize size2) => _staticInfo.callMethodOnReceiver('is_equal', this, [size2]);
  bool isIpp() => _staticInfo.callMethodOnReceiver('is_ipp', this, []);
  void setSize(num width, num height, Unit unit) => _staticInfo.callMethodOnReceiver('set_size', this, [width, height, unit]);
  void toKeyFile(KeyFile keyFile, String groupName) => _staticInfo.callMethodOnReceiver('to_key_file', this, [keyFile, groupName]);
  static String getDefault() => _staticInfo.callStatic('get_default', []);
  static GLibList /* this will fail */ getPaperSizes(bool includeCustom) => _staticInfo.callStatic('get_paper_sizes', [includeCustom]);
}

class PathPriorityType extends GEnumBase {
  const PathPriorityType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PathPriorityType');

  static const PathPriorityType LOWEST = const PathPriorityType(0);
  static const PathPriorityType GTK = const PathPriorityType(4);
  static const PathPriorityType APPLICATION = const PathPriorityType(8);
  static const PathPriorityType THEME = const PathPriorityType(10);
  static const PathPriorityType RC = const PathPriorityType(12);
  static const PathPriorityType HIGHEST = const PathPriorityType(15);
  String toString() {
    switch(index) {
      case 0: return 'PathPriorityType.LOWEST';
      case 4: return 'PathPriorityType.GTK';
      case 8: return 'PathPriorityType.APPLICATION';
      case 10: return 'PathPriorityType.THEME';
      case 12: return 'PathPriorityType.RC';
      case 15: return 'PathPriorityType.HIGHEST';
      default: return 'new PathPriorityType($index)';
    }
  }
}

class PathType extends GEnumBase {
  const PathType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PathType');

  static const PathType WIDGET = const PathType(0);
  static const PathType WIDGET_CLASS = const PathType(1);
  static const PathType CLASS = const PathType(2);
  String toString() {
    switch(index) {
      case 0: return 'PathType.WIDGET';
      case 1: return 'PathType.WIDGET_CLASS';
      case 2: return 'PathType.CLASS';
      default: return 'new PathType($index)';
    }
  }
}

class PlacesOpenFlags extends GEnumBase {
  const PlacesOpenFlags(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PlacesOpenFlags');

  static const PlacesOpenFlags NULL = const PlacesOpenFlags(0);
  static const PlacesOpenFlags NORMAL = const PlacesOpenFlags(1);
  bool get normal => (index & 1) == 1;
  static const PlacesOpenFlags NEW_TAB = const PlacesOpenFlags(2);
  bool get newTab => (index & 2) == 2;
  static const PlacesOpenFlags NEW_WINDOW = const PlacesOpenFlags(4);
  bool get newWindow => (index & 4) == 4;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'PlacesOpenFlags.NORMAL';
      case 2: return 'PlacesOpenFlags.NEW_TAB';
      case 4: return 'PlacesOpenFlags.NEW_WINDOW';
      default: return 'new PlacesOpenFlags($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'PlacesOpenFlags.NULL';
    }
    List codes = [];
    for (var i=1; i <= 4; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  PlacesOpenFlags operator|(PlacesOpenFlags other) =>
    new PlacesOpenFlags(index | other.index);
  PlacesOpenFlags operator&(PlacesOpenFlags other) =>
    new PlacesOpenFlags(index & other.index);
}

class PlacesSidebar extends ScrolledWindow with ImplementorIface, Buildable {
  PlacesSidebar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PlacesSidebar');

  static const String LOCAL_ONLY_PROPERTY = 'local-only';
  static const String LOCATION_PROPERTY = 'location';
  static const String OPEN_FLAGS_PROPERTY = 'open-flags';
  bool get populateAll => _staticInfo.getGPropertyOnReceiver('populate-all', this);
  void set populateAll(bool value) => _staticInfo.setGPropertyOnReceiver('populate-all', this, value);
  static const String POPULATE_ALL_PROPERTY = 'populate-all';
  static const String SHOW_CONNECT_TO_SERVER_PROPERTY = 'show-connect-to-server';
  static const String SHOW_DESKTOP_PROPERTY = 'show-desktop';
  static const String SHOW_ENTER_LOCATION_PROPERTY = 'show-enter-location';
  static const String SHOW_OTHER_LOCATIONS_PROPERTY = 'show-other-locations';
  static const String SHOW_RECENT_PROPERTY = 'show-recent';
  static const String SHOW_TRASH_PROPERTY = 'show-trash';
  factory PlacesSidebar() => _staticInfo.callStatic('new', []);
  void addShortcut(File location) => _staticInfo.callMethodOnReceiver('add_shortcut', this, [location]);
  bool get localOnly => _staticInfo.callMethodOnReceiver('get_local_only', this, []);
  File get location => _staticInfo.callMethodOnReceiver('get_location', this, []);
  File getNthBookmark(int n) => _staticInfo.callMethodOnReceiver('get_nth_bookmark', this, [n]);
  PlacesOpenFlags get openFlags => _staticInfo.callMethodOnReceiver('get_open_flags', this, []);
  bool get showConnectToServer => _staticInfo.callMethodOnReceiver('get_show_connect_to_server', this, []);
  bool get showDesktop => _staticInfo.callMethodOnReceiver('get_show_desktop', this, []);
  bool get showEnterLocation => _staticInfo.callMethodOnReceiver('get_show_enter_location', this, []);
  bool get showOtherLocations => _staticInfo.callMethodOnReceiver('get_show_other_locations', this, []);
  bool get showRecent => _staticInfo.callMethodOnReceiver('get_show_recent', this, []);
  bool get showTrash => _staticInfo.callMethodOnReceiver('get_show_trash', this, []);
  SList /* this will fail */ listShortcuts() => _staticInfo.callMethodOnReceiver('list_shortcuts', this, []);
  void removeShortcut(File location) => _staticInfo.callMethodOnReceiver('remove_shortcut', this, [location]);
  void setDropTargetsVisible(bool visible, DragContext context) => _staticInfo.callMethodOnReceiver('set_drop_targets_visible', this, [visible, context]);
  void set localOnly(bool localOnly) => _staticInfo.callMethodOnReceiver('set_local_only', this, [localOnly]);
  void set location(File location) => _staticInfo.callMethodOnReceiver('set_location', this, [location]);
  void set openFlags(PlacesOpenFlags flags) => _staticInfo.callMethodOnReceiver('set_open_flags', this, [flags]);
  void set showConnectToServer(bool showConnectToServer) => _staticInfo.callMethodOnReceiver('set_show_connect_to_server', this, [showConnectToServer]);
  void set showDesktop(bool showDesktop) => _staticInfo.callMethodOnReceiver('set_show_desktop', this, [showDesktop]);
  void set showEnterLocation(bool showEnterLocation) => _staticInfo.callMethodOnReceiver('set_show_enter_location', this, [showEnterLocation]);
  void set showOtherLocations(bool showOtherLocations) => _staticInfo.callMethodOnReceiver('set_show_other_locations', this, [showOtherLocations]);
  void set showRecent(bool showRecent) => _staticInfo.callMethodOnReceiver('set_show_recent', this, [showRecent]);
  void set showTrash(bool showTrash) => _staticInfo.callMethodOnReceiver('set_show_trash', this, [showTrash]);
  int connectToDragActionAsk(bool after, int func(int actions)) => signalConnect('drag-action-ask', func, after);
  int connectToDragActionRequested(bool after, int func(DragContext context, File destFile, GLibList sourceFileList /* this will fail */)) => signalConnect('drag-action-requested', func, after);
  int _connectToDragPerformDrop(bool after, void func(File destFile, GLibList sourceFileList /* this will fail */, int action)) => signalConnect('drag-perform-drop', func, after);
  Stream<PlacesSidebarDragPerformDropEvent> get onDragPerformDrop {
    int signalId;
    StreamController<PlacesSidebarDragPerformDropEvent> controller;
    controller = new StreamController<PlacesSidebarDragPerformDropEvent>(
      onListen: () {
          signalId = _connectToDragPerformDrop(false, (File destFile, GLibList sourceFileList /* this will fail */, int action) {
              var result = new PlacesSidebarDragPerformDropEvent(destFile, sourceFileList, action);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PlacesSidebarDragPerformDropEvent> get afterDragPerformDrop {
    int signalId;
    StreamController<PlacesSidebarDragPerformDropEvent> controller;
    controller = new StreamController<PlacesSidebarDragPerformDropEvent>(
      onListen: () {
          signalId = _connectToDragPerformDrop(true, (File destFile, GLibList sourceFileList /* this will fail */, int action) {
              var result = new PlacesSidebarDragPerformDropEvent(destFile, sourceFileList, action);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToOpenLocation(bool after, void func(File location, PlacesOpenFlags openFlags)) => signalConnect('open-location', func, after);
  Stream<PlacesSidebarOpenLocationEvent> get onOpenLocation {
    int signalId;
    StreamController<PlacesSidebarOpenLocationEvent> controller;
    controller = new StreamController<PlacesSidebarOpenLocationEvent>(
      onListen: () {
          signalId = _connectToOpenLocation(false, (File location, PlacesOpenFlags openFlags) {
              var result = new PlacesSidebarOpenLocationEvent(location, openFlags);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PlacesSidebarOpenLocationEvent> get afterOpenLocation {
    int signalId;
    StreamController<PlacesSidebarOpenLocationEvent> controller;
    controller = new StreamController<PlacesSidebarOpenLocationEvent>(
      onListen: () {
          signalId = _connectToOpenLocation(true, (File location, PlacesOpenFlags openFlags) {
              var result = new PlacesSidebarOpenLocationEvent(location, openFlags);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPopulatePopup(bool after, void func(Widget container, File selectedItem, Volume selectedVolume)) => signalConnect('populate-popup', func, after);
  Stream<PlacesSidebarPopulatePopupEvent> get onPopulatePopup {
    int signalId;
    StreamController<PlacesSidebarPopulatePopupEvent> controller;
    controller = new StreamController<PlacesSidebarPopulatePopupEvent>(
      onListen: () {
          signalId = _connectToPopulatePopup(false, (Widget container, File selectedItem, Volume selectedVolume) {
              var result = new PlacesSidebarPopulatePopupEvent(container, selectedItem, selectedVolume);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PlacesSidebarPopulatePopupEvent> get afterPopulatePopup {
    int signalId;
    StreamController<PlacesSidebarPopulatePopupEvent> controller;
    controller = new StreamController<PlacesSidebarPopulatePopupEvent>(
      onListen: () {
          signalId = _connectToPopulatePopup(true, (Widget container, File selectedItem, Volume selectedVolume) {
              var result = new PlacesSidebarPopulatePopupEvent(container, selectedItem, selectedVolume);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToShowConnectToServer(bool after, void func()) => signalConnect('show-connect-to-server', func, after);
  Stream get onShowConnectToServer {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToShowConnectToServer(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterShowConnectToServer {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToShowConnectToServer(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToShowEnterLocation(bool after, void func()) => signalConnect('show-enter-location', func, after);
  Stream get onShowEnterLocation {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToShowEnterLocation(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterShowEnterLocation {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToShowEnterLocation(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToShowErrorMessage(bool after, void func(String primary, String secondary)) => signalConnect('show-error-message', func, after);
  Stream<PlacesSidebarShowErrorMessageEvent> get onShowErrorMessage {
    int signalId;
    StreamController<PlacesSidebarShowErrorMessageEvent> controller;
    controller = new StreamController<PlacesSidebarShowErrorMessageEvent>(
      onListen: () {
          signalId = _connectToShowErrorMessage(false, (String primary, String secondary) {
              var result = new PlacesSidebarShowErrorMessageEvent(primary, secondary);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PlacesSidebarShowErrorMessageEvent> get afterShowErrorMessage {
    int signalId;
    StreamController<PlacesSidebarShowErrorMessageEvent> controller;
    controller = new StreamController<PlacesSidebarShowErrorMessageEvent>(
      onListen: () {
          signalId = _connectToShowErrorMessage(true, (String primary, String secondary) {
              var result = new PlacesSidebarShowErrorMessageEvent(primary, secondary);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToShowOtherLocations(bool after, void func()) => signalConnect('show-other-locations', func, after);
  Stream get onShowOtherLocations {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToShowOtherLocations(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterShowOtherLocations {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToShowOtherLocations(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class PlacesSidebarDragPerformDropEvent {
  final File destFile;
  final GLibList sourceFileList /* this will fail */;
  final int action;

  PlacesSidebarDragPerformDropEvent(this.destFile, this.sourceFileList, this.action);
}

class PlacesSidebarOpenLocationEvent {
  final File location;
  final PlacesOpenFlags openFlags;

  PlacesSidebarOpenLocationEvent(this.location, this.openFlags);
}

class PlacesSidebarPopulatePopupEvent {
  final Widget container;
  final File selectedItem;
  final Volume selectedVolume;

  PlacesSidebarPopulatePopupEvent(this.container, this.selectedItem, this.selectedVolume);
}

class PlacesSidebarShowErrorMessageEvent {
  final String primary;
  final String secondary;

  PlacesSidebarShowErrorMessageEvent(this.primary, this.secondary);
}

class Plug extends Window with ImplementorIface, Buildable {
  Plug.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Plug');

  static const String EMBEDDED_PROPERTY = 'embedded';
  static const String SOCKET_WINDOW_PROPERTY = 'socket-window';
  factory Plug(int socketId) => _staticInfo.callStatic('new', [socketId]);
  factory Plug.forDisplay(Display display, int socketId) => _staticInfo.callStatic('new_for_display', [display, socketId]);
  void construct(int socketId) => _staticInfo.callMethodOnReceiver('construct', this, [socketId]);
  void constructForDisplay(Display display, int socketId) => _staticInfo.callMethodOnReceiver('construct_for_display', this, [display, socketId]);
  bool get embedded => _staticInfo.callMethodOnReceiver('get_embedded', this, []);
  int getId() => _staticInfo.callMethodOnReceiver('get_id', this, []);
  gdk.Window get socketWindow => _staticInfo.callMethodOnReceiver('get_socket_window', this, []);
  int _connectToEmbedded(bool after, void func()) => signalConnect('embedded', func, after);
  Stream get onEmbedded {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToEmbedded(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterEmbedded {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToEmbedded(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class PolicyType extends GEnumBase {
  const PolicyType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PolicyType');

  static const PolicyType ALWAYS = const PolicyType(0);
  static const PolicyType AUTOMATIC = const PolicyType(1);
  static const PolicyType NEVER = const PolicyType(2);
  static const PolicyType EXTERNAL = const PolicyType(3);
  String toString() {
    switch(index) {
      case 0: return 'PolicyType.ALWAYS';
      case 1: return 'PolicyType.AUTOMATIC';
      case 2: return 'PolicyType.NEVER';
      case 3: return 'PolicyType.EXTERNAL';
      default: return 'new PolicyType($index)';
    }
  }
}

class Popover extends Bin with ImplementorIface, Buildable {
  Popover.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Popover');

  static const String MODAL_PROPERTY = 'modal';
  static const String POINTING_TO_PROPERTY = 'pointing-to';
  static const String POSITION_PROPERTY = 'position';
  static const String RELATIVE_TO_PROPERTY = 'relative-to';
  static const String TRANSITIONS_ENABLED_PROPERTY = 'transitions-enabled';
  factory Popover(Widget relativeTo) => _staticInfo.callStatic('new', [relativeTo]);
  factory Popover.fromModel(Widget relativeTo, MenuModel model) => _staticInfo.callStatic('new_from_model', [relativeTo, model]);
  void bindModel(MenuModel model, String actionNamespace) => _staticInfo.callMethodOnReceiver('bind_model', this, [model, actionNamespace]);
  Widget getDefaultWidget() => _staticInfo.callMethodOnReceiver('get_default_widget', this, []);
  bool get modal => _staticInfo.callMethodOnReceiver('get_modal', this, []);
  List getPointingTo() => _staticInfo.callMethodOnReceiver('get_pointing_to', this, []);
  PositionType get position => _staticInfo.callMethodOnReceiver('get_position', this, []);
  Widget get relativeTo => _staticInfo.callMethodOnReceiver('get_relative_to', this, []);
  bool get transitionsEnabled => _staticInfo.callMethodOnReceiver('get_transitions_enabled', this, []);
  void setDefaultWidget(Widget widget) => _staticInfo.callMethodOnReceiver('set_default_widget', this, [widget]);
  void set modal(bool modal) => _staticInfo.callMethodOnReceiver('set_modal', this, [modal]);
  void setPointingTo(RectangleInt rect) => _staticInfo.callMethodOnReceiver('set_pointing_to', this, [rect]);
  void set position(PositionType position) => _staticInfo.callMethodOnReceiver('set_position', this, [position]);
  void set relativeTo(Widget relativeTo) => _staticInfo.callMethodOnReceiver('set_relative_to', this, [relativeTo]);
  void set transitionsEnabled(bool transitionsEnabled) => _staticInfo.callMethodOnReceiver('set_transitions_enabled', this, [transitionsEnabled]);
  int _connectToClosed(bool after, void func()) => signalConnect('closed', func, after);
  Stream get onClosed {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClosed(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterClosed {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClosed(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class PopoverAccessible extends ContainerAccessible with Component {
  PopoverAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PopoverAccessible');

}

class PopoverMenu extends Popover with ImplementorIface, Buildable {
  PopoverMenu.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PopoverMenu');

  String get visibleSubmenu => _staticInfo.getGPropertyOnReceiver('visible-submenu', this);
  void set visibleSubmenu(String value) => _staticInfo.setGPropertyOnReceiver('visible-submenu', this, value);
  static const String VISIBLE_SUBMENU_PROPERTY = 'visible-submenu';
  factory PopoverMenu() => _staticInfo.callStatic('new', []);
  void openSubmenu(String name) => _staticInfo.callMethodOnReceiver('open_submenu', this, [name]);
}

class PositionType extends GEnumBase {
  const PositionType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PositionType');

  static const PositionType LEFT = const PositionType(0);
  static const PositionType RIGHT = const PositionType(1);
  static const PositionType TOP = const PositionType(2);
  static const PositionType BOTTOM = const PositionType(3);
  String toString() {
    switch(index) {
      case 0: return 'PositionType.LEFT';
      case 1: return 'PositionType.RIGHT';
      case 2: return 'PositionType.TOP';
      case 3: return 'PositionType.BOTTOM';
      default: return 'new PositionType($index)';
    }
  }
}

class PrintContext extends GObjectObject {
  PrintContext.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PrintContext');

  pango.Context createPangoContext() => _staticInfo.callMethodOnReceiver('create_pango_context', this, []);
  pango.Layout createPangoLayout() => _staticInfo.callMethodOnReceiver('create_pango_layout', this, []);
  Context getCairoContext() => _staticInfo.callMethodOnReceiver('get_cairo_context', this, []);
  num getDpiX() => _staticInfo.callMethodOnReceiver('get_dpi_x', this, []);
  num getDpiY() => _staticInfo.callMethodOnReceiver('get_dpi_y', this, []);
  bool getHardMargins() => _staticInfo.callMethodOnReceiver('get_hard_margins', this, []);
  num getHeight() => _staticInfo.callMethodOnReceiver('get_height', this, []);
  PageSetup getPageSetup() => _staticInfo.callMethodOnReceiver('get_page_setup', this, []);
  FontMap getPangoFontmap() => _staticInfo.callMethodOnReceiver('get_pango_fontmap', this, []);
  num getWidth() => _staticInfo.callMethodOnReceiver('get_width', this, []);
  void setCairoContext(Context cr, num dpiX, num dpiY) => _staticInfo.callMethodOnReceiver('set_cairo_context', this, [cr, dpiX, dpiY]);
}

class PrintDuplex extends GEnumBase {
  const PrintDuplex(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PrintDuplex');

  static const PrintDuplex SIMPLEX = const PrintDuplex(0);
  static const PrintDuplex HORIZONTAL = const PrintDuplex(1);
  static const PrintDuplex VERTICAL = const PrintDuplex(2);
  String toString() {
    switch(index) {
      case 0: return 'PrintDuplex.SIMPLEX';
      case 1: return 'PrintDuplex.HORIZONTAL';
      case 2: return 'PrintDuplex.VERTICAL';
      default: return 'new PrintDuplex($index)';
    }
  }
}

class PrintErrorCode extends GEnumBase {
  const PrintErrorCode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PrintError');

  static const PrintErrorCode GENERAL = const PrintErrorCode(0);
  static const PrintErrorCode INTERNAL_ERROR = const PrintErrorCode(1);
  static const PrintErrorCode NOMEM = const PrintErrorCode(2);
  static const PrintErrorCode INVALID_FILE = const PrintErrorCode(3);
  String toString() {
    switch(index) {
      case 0: return 'PrintErrorCode.GENERAL';
      case 1: return 'PrintErrorCode.INTERNAL_ERROR';
      case 2: return 'PrintErrorCode.NOMEM';
      case 3: return 'PrintErrorCode.INVALID_FILE';
      default: return 'new PrintErrorCode($index)';
    }
  }
  static int quark() => _staticInfo.callStatic('quark', []);
}

class PrintError extends GErrorBase {
  static final int _quark = lookupErrorQuarkFromString('gtk-print-error-quark');
  PrintError(PrintErrorCode code, String message)
      : super.fromFields(_quark, code, message);
}

class PrintOperation extends GObjectObject with PrintOperationPreview {
  PrintOperation.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PrintOperation');

  bool get allowAsync => _staticInfo.getGPropertyOnReceiver('allow-async', this);
  static const String ALLOW_ASYNC_PROPERTY = 'allow-async';
  int get currentPage => _staticInfo.getGPropertyOnReceiver('current-page', this);
  static const String CURRENT_PAGE_PROPERTY = 'current-page';
  String get customTabLabel => _staticInfo.getGPropertyOnReceiver('custom-tab-label', this);
  static const String CUSTOM_TAB_LABEL_PROPERTY = 'custom-tab-label';
  static const String DEFAULT_PAGE_SETUP_PROPERTY = 'default-page-setup';
  static const String EMBED_PAGE_SETUP_PROPERTY = 'embed-page-setup';
  String get exportFilename => _staticInfo.getGPropertyOnReceiver('export-filename', this);
  static const String EXPORT_FILENAME_PROPERTY = 'export-filename';
  static const String HAS_SELECTION_PROPERTY = 'has-selection';
  String get jobName => _staticInfo.getGPropertyOnReceiver('job-name', this);
  static const String JOB_NAME_PROPERTY = 'job-name';
  int get nPages => _staticInfo.getGPropertyOnReceiver('n-pages', this);
  static const String N_PAGES_PROPERTY = 'n-pages';
  static const String N_PAGES_TO_PRINT_PROPERTY = 'n-pages-to-print';
  static const String PRINT_SETTINGS_PROPERTY = 'print-settings';
  bool get showProgress => _staticInfo.getGPropertyOnReceiver('show-progress', this);
  static const String SHOW_PROGRESS_PROPERTY = 'show-progress';
  static const String STATUS_PROPERTY = 'status';
  static const String STATUS_STRING_PROPERTY = 'status-string';
  static const String SUPPORT_SELECTION_PROPERTY = 'support-selection';
  bool get trackPrintStatus => _staticInfo.getGPropertyOnReceiver('track-print-status', this);
  static const String TRACK_PRINT_STATUS_PROPERTY = 'track-print-status';
  Unit get unit => _staticInfo.getGPropertyOnReceiver('unit', this);
  static const String UNIT_PROPERTY = 'unit';
  bool get useFullPage => _staticInfo.getGPropertyOnReceiver('use-full-page', this);
  static const String USE_FULL_PAGE_PROPERTY = 'use-full-page';
  factory PrintOperation() => _staticInfo.callStatic('new', []);
  void cancel() => _staticInfo.callMethodOnReceiver('cancel', this, []);
  void drawPageFinish() => _staticInfo.callMethodOnReceiver('draw_page_finish', this, []);
  PageSetup get defaultPageSetup => _staticInfo.callMethodOnReceiver('get_default_page_setup', this, []);
  bool get embedPageSetup => _staticInfo.callMethodOnReceiver('get_embed_page_setup', this, []);
  void getError() => _staticInfo.callMethodOnReceiver('get_error', this, []);
  bool get hasSelection => _staticInfo.callMethodOnReceiver('get_has_selection', this, []);
  int get nPagesToPrint => _staticInfo.callMethodOnReceiver('get_n_pages_to_print', this, []);
  PrintSettings get printSettings => _staticInfo.callMethodOnReceiver('get_print_settings', this, []);
  PrintStatus get status => _staticInfo.callMethodOnReceiver('get_status', this, []);
  String get statusString => _staticInfo.callMethodOnReceiver('get_status_string', this, []);
  bool get supportSelection => _staticInfo.callMethodOnReceiver('get_support_selection', this, []);
  bool isFinished() => _staticInfo.callMethodOnReceiver('is_finished', this, []);
  PrintOperationResult run(PrintOperationAction action, Window parent) => _staticInfo.callMethodOnReceiver('run', this, [action, parent]);
  void set allowAsync_(bool allowAsync) => _staticInfo.callMethodOnReceiver('set_allow_async', this, [allowAsync]);
  void set currentPage_(int currentPage) => _staticInfo.callMethodOnReceiver('set_current_page', this, [currentPage]);
  void set customTabLabel_(String label) => _staticInfo.callMethodOnReceiver('set_custom_tab_label', this, [label]);
  void set defaultPageSetup(PageSetup defaultPageSetup) => _staticInfo.callMethodOnReceiver('set_default_page_setup', this, [defaultPageSetup]);
  void setDeferDrawing() => _staticInfo.callMethodOnReceiver('set_defer_drawing', this, []);
  void set embedPageSetup(bool embed) => _staticInfo.callMethodOnReceiver('set_embed_page_setup', this, [embed]);
  void set exportFilename_(String filename) => _staticInfo.callMethodOnReceiver('set_export_filename', this, [filename]);
  void set hasSelection(bool hasSelection) => _staticInfo.callMethodOnReceiver('set_has_selection', this, [hasSelection]);
  void set jobName_(String jobName) => _staticInfo.callMethodOnReceiver('set_job_name', this, [jobName]);
  void set nPages_(int nPages) => _staticInfo.callMethodOnReceiver('set_n_pages', this, [nPages]);
  void set printSettings(PrintSettings printSettings) => _staticInfo.callMethodOnReceiver('set_print_settings', this, [printSettings]);
  void set showProgress_(bool showProgress) => _staticInfo.callMethodOnReceiver('set_show_progress', this, [showProgress]);
  void set supportSelection(bool supportSelection) => _staticInfo.callMethodOnReceiver('set_support_selection', this, [supportSelection]);
  void set trackPrintStatus_(bool trackStatus) => _staticInfo.callMethodOnReceiver('set_track_print_status', this, [trackStatus]);
  void set unit_(Unit unit) => _staticInfo.callMethodOnReceiver('set_unit', this, [unit]);
  void set useFullPage_(bool fullPage) => _staticInfo.callMethodOnReceiver('set_use_full_page', this, [fullPage]);
  int _connectToBeginPrint(bool after, void func(PrintContext context)) => signalConnect('begin-print', func, after);
  Stream<PrintContext> get onBeginPrint {
    int signalId;
    StreamController<PrintContext> controller;
    controller = new StreamController<PrintContext>(
      onListen: () {
          signalId = _connectToBeginPrint(false, (PrintContext context) {
              controller.add(context);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PrintContext> get afterBeginPrint {
    int signalId;
    StreamController<PrintContext> controller;
    controller = new StreamController<PrintContext>(
      onListen: () {
          signalId = _connectToBeginPrint(true, (PrintContext context) {
              controller.add(context);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int connectToCreateCustomWidget(bool after, GObjectObject func()) => signalConnect('create-custom-widget', func, after);
  int _connectToCustomWidgetApply(bool after, void func(Widget widget)) => signalConnect('custom-widget-apply', func, after);
  Stream<Widget> get onCustomWidgetApply {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToCustomWidgetApply(false, (Widget widget) {
              controller.add(widget);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Widget> get afterCustomWidgetApply {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToCustomWidgetApply(true, (Widget widget) {
              controller.add(widget);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDone(bool after, void func(PrintOperationResult result_)) => signalConnect('done', func, after);
  Stream<PrintOperationResult> get onDone {
    int signalId;
    StreamController<PrintOperationResult> controller;
    controller = new StreamController<PrintOperationResult>(
      onListen: () {
          signalId = _connectToDone(false, (PrintOperationResult result_) {
              controller.add(result_);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PrintOperationResult> get afterDone {
    int signalId;
    StreamController<PrintOperationResult> controller;
    controller = new StreamController<PrintOperationResult>(
      onListen: () {
          signalId = _connectToDone(true, (PrintOperationResult result_) {
              controller.add(result_);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDrawPage(bool after, void func(PrintContext context, int pageNr)) => signalConnect('draw-page', func, after);
  Stream<PrintOperationDrawPageEvent> get onDrawPage {
    int signalId;
    StreamController<PrintOperationDrawPageEvent> controller;
    controller = new StreamController<PrintOperationDrawPageEvent>(
      onListen: () {
          signalId = _connectToDrawPage(false, (PrintContext context, int pageNr) {
              var result = new PrintOperationDrawPageEvent(context, pageNr);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PrintOperationDrawPageEvent> get afterDrawPage {
    int signalId;
    StreamController<PrintOperationDrawPageEvent> controller;
    controller = new StreamController<PrintOperationDrawPageEvent>(
      onListen: () {
          signalId = _connectToDrawPage(true, (PrintContext context, int pageNr) {
              var result = new PrintOperationDrawPageEvent(context, pageNr);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToEndPrint(bool after, void func(PrintContext context)) => signalConnect('end-print', func, after);
  Stream<PrintContext> get onEndPrint {
    int signalId;
    StreamController<PrintContext> controller;
    controller = new StreamController<PrintContext>(
      onListen: () {
          signalId = _connectToEndPrint(false, (PrintContext context) {
              controller.add(context);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PrintContext> get afterEndPrint {
    int signalId;
    StreamController<PrintContext> controller;
    controller = new StreamController<PrintContext>(
      onListen: () {
          signalId = _connectToEndPrint(true, (PrintContext context) {
              controller.add(context);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPaginate(bool after, bool func(PrintContext context)) => signalConnect('paginate', func, after);
  Stream<PrintOperationPaginateEvent> get onPaginate {
    int signalId;
    StreamController<PrintOperationPaginateEvent> controller;
    controller = new StreamController<PrintOperationPaginateEvent>(
      onListen: () {
          signalId = _connectToPaginate(false, (PrintContext context) {
              var result = new PrintOperationPaginateEvent(context);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PrintOperationPaginateEvent> get afterPaginate {
    int signalId;
    StreamController<PrintOperationPaginateEvent> controller;
    controller = new StreamController<PrintOperationPaginateEvent>(
      onListen: () {
          signalId = _connectToPaginate(true, (PrintContext context) {
              var result = new PrintOperationPaginateEvent(context);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPreview(bool after, bool func(PrintOperationPreview preview, PrintContext context, Window parent)) => signalConnect('preview', func, after);
  Stream<PrintOperationPreviewEvent> get onPreview {
    int signalId;
    StreamController<PrintOperationPreviewEvent> controller;
    controller = new StreamController<PrintOperationPreviewEvent>(
      onListen: () {
          signalId = _connectToPreview(false, (PrintOperationPreview preview, PrintContext context, Window parent) {
              var result = new PrintOperationPreviewEvent(preview, context, parent);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PrintOperationPreviewEvent> get afterPreview {
    int signalId;
    StreamController<PrintOperationPreviewEvent> controller;
    controller = new StreamController<PrintOperationPreviewEvent>(
      onListen: () {
          signalId = _connectToPreview(true, (PrintOperationPreview preview, PrintContext context, Window parent) {
              var result = new PrintOperationPreviewEvent(preview, context, parent);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRequestPageSetup(bool after, void func(PrintContext context, int pageNr, PageSetup setup)) => signalConnect('request-page-setup', func, after);
  Stream<PrintOperationRequestPageSetupEvent> get onRequestPageSetup {
    int signalId;
    StreamController<PrintOperationRequestPageSetupEvent> controller;
    controller = new StreamController<PrintOperationRequestPageSetupEvent>(
      onListen: () {
          signalId = _connectToRequestPageSetup(false, (PrintContext context, int pageNr, PageSetup setup) {
              var result = new PrintOperationRequestPageSetupEvent(context, pageNr, setup);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PrintOperationRequestPageSetupEvent> get afterRequestPageSetup {
    int signalId;
    StreamController<PrintOperationRequestPageSetupEvent> controller;
    controller = new StreamController<PrintOperationRequestPageSetupEvent>(
      onListen: () {
          signalId = _connectToRequestPageSetup(true, (PrintContext context, int pageNr, PageSetup setup) {
              var result = new PrintOperationRequestPageSetupEvent(context, pageNr, setup);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToStatusChanged(bool after, void func()) => signalConnect('status-changed', func, after);
  Stream get onStatusChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToStatusChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterStatusChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToStatusChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToUpdateCustomWidget(bool after, void func(Widget widget, PageSetup setup, PrintSettings settings)) => signalConnect('update-custom-widget', func, after);
  Stream<PrintOperationUpdateCustomWidgetEvent> get onUpdateCustomWidget {
    int signalId;
    StreamController<PrintOperationUpdateCustomWidgetEvent> controller;
    controller = new StreamController<PrintOperationUpdateCustomWidgetEvent>(
      onListen: () {
          signalId = _connectToUpdateCustomWidget(false, (Widget widget, PageSetup setup, PrintSettings settings) {
              var result = new PrintOperationUpdateCustomWidgetEvent(widget, setup, settings);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PrintOperationUpdateCustomWidgetEvent> get afterUpdateCustomWidget {
    int signalId;
    StreamController<PrintOperationUpdateCustomWidgetEvent> controller;
    controller = new StreamController<PrintOperationUpdateCustomWidgetEvent>(
      onListen: () {
          signalId = _connectToUpdateCustomWidget(true, (Widget widget, PageSetup setup, PrintSettings settings) {
              var result = new PrintOperationUpdateCustomWidgetEvent(widget, setup, settings);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class PrintOperationDrawPageEvent {
  final PrintContext context;
  final int pageNr;

  PrintOperationDrawPageEvent(this.context, this.pageNr);
}

class PrintOperationPaginateEvent {
  final PrintContext context;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  PrintOperationPaginateEvent(this.context);
}

class PrintOperationPreviewEvent {
  final PrintOperationPreview preview;
  final PrintContext context;
  final Window parent;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  PrintOperationPreviewEvent(this.preview, this.context, this.parent);
}

class PrintOperationRequestPageSetupEvent {
  final PrintContext context;
  final int pageNr;
  final PageSetup setup;

  PrintOperationRequestPageSetupEvent(this.context, this.pageNr, this.setup);
}

class PrintOperationUpdateCustomWidgetEvent {
  final Widget widget;
  final PageSetup setup;
  final PrintSettings settings;

  PrintOperationUpdateCustomWidgetEvent(this.widget, this.setup, this.settings);
}

class PrintOperationAction extends GEnumBase {
  const PrintOperationAction(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PrintOperationAction');

  static const PrintOperationAction PRINT_DIALOG = const PrintOperationAction(0);
  static const PrintOperationAction PRINT = const PrintOperationAction(1);
  static const PrintOperationAction PREVIEW = const PrintOperationAction(2);
  static const PrintOperationAction EXPORT = const PrintOperationAction(3);
  String toString() {
    switch(index) {
      case 0: return 'PrintOperationAction.PRINT_DIALOG';
      case 1: return 'PrintOperationAction.PRINT';
      case 2: return 'PrintOperationAction.PREVIEW';
      case 3: return 'PrintOperationAction.EXPORT';
      default: return 'new PrintOperationAction($index)';
    }
  }
}

abstract class PrintOperationPreview extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PrintOperationPreview');



  void endPreview() => _staticInfo.callMethodOnReceiver('end_preview', this, []);
  bool isSelected(int pageNr) => _staticInfo.callMethodOnReceiver('is_selected', this, [pageNr]);
  void renderPage(int pageNr) => _staticInfo.callMethodOnReceiver('render_page', this, [pageNr]);
  int _connectToGotPageSize(bool after, void func(PrintContext context, PageSetup pageSetup)) => signalConnect('got-page-size', func, after);
  Stream<PrintOperationPreviewGotPageSizeEvent> get onGotPageSize {
    int signalId;
    StreamController<PrintOperationPreviewGotPageSizeEvent> controller;
    controller = new StreamController<PrintOperationPreviewGotPageSizeEvent>(
      onListen: () {
          signalId = _connectToGotPageSize(false, (PrintContext context, PageSetup pageSetup) {
              var result = new PrintOperationPreviewGotPageSizeEvent(context, pageSetup);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PrintOperationPreviewGotPageSizeEvent> get afterGotPageSize {
    int signalId;
    StreamController<PrintOperationPreviewGotPageSizeEvent> controller;
    controller = new StreamController<PrintOperationPreviewGotPageSizeEvent>(
      onListen: () {
          signalId = _connectToGotPageSize(true, (PrintContext context, PageSetup pageSetup) {
              var result = new PrintOperationPreviewGotPageSizeEvent(context, pageSetup);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToReady(bool after, void func(PrintContext context)) => signalConnect('ready', func, after);
  Stream<PrintContext> get onReady {
    int signalId;
    StreamController<PrintContext> controller;
    controller = new StreamController<PrintContext>(
      onListen: () {
          signalId = _connectToReady(false, (PrintContext context) {
              controller.add(context);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PrintContext> get afterReady {
    int signalId;
    StreamController<PrintContext> controller;
    controller = new StreamController<PrintContext>(
      onListen: () {
          signalId = _connectToReady(true, (PrintContext context) {
              controller.add(context);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class PrintOperationPreviewGotPageSizeEvent {
  final PrintContext context;
  final PageSetup pageSetup;

  PrintOperationPreviewGotPageSizeEvent(this.context, this.pageSetup);
}

class PrintOperationResult extends GEnumBase {
  const PrintOperationResult(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PrintOperationResult');

  static const PrintOperationResult ERROR = const PrintOperationResult(0);
  static const PrintOperationResult APPLY = const PrintOperationResult(1);
  static const PrintOperationResult CANCEL = const PrintOperationResult(2);
  static const PrintOperationResult IN_PROGRESS = const PrintOperationResult(3);
  String toString() {
    switch(index) {
      case 0: return 'PrintOperationResult.ERROR';
      case 1: return 'PrintOperationResult.APPLY';
      case 2: return 'PrintOperationResult.CANCEL';
      case 3: return 'PrintOperationResult.IN_PROGRESS';
      default: return 'new PrintOperationResult($index)';
    }
  }
}

class PrintPages extends GEnumBase {
  const PrintPages(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PrintPages');

  static const PrintPages ALL = const PrintPages(0);
  static const PrintPages CURRENT = const PrintPages(1);
  static const PrintPages RANGES = const PrintPages(2);
  static const PrintPages SELECTION = const PrintPages(3);
  String toString() {
    switch(index) {
      case 0: return 'PrintPages.ALL';
      case 1: return 'PrintPages.CURRENT';
      case 2: return 'PrintPages.RANGES';
      case 3: return 'PrintPages.SELECTION';
      default: return 'new PrintPages($index)';
    }
  }
}

class PrintQuality extends GEnumBase {
  const PrintQuality(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PrintQuality');

  static const PrintQuality LOW = const PrintQuality(0);
  static const PrintQuality NORMAL = const PrintQuality(1);
  static const PrintQuality HIGH = const PrintQuality(2);
  static const PrintQuality DRAFT = const PrintQuality(3);
  String toString() {
    switch(index) {
      case 0: return 'PrintQuality.LOW';
      case 1: return 'PrintQuality.NORMAL';
      case 2: return 'PrintQuality.HIGH';
      case 3: return 'PrintQuality.DRAFT';
      default: return 'new PrintQuality($index)';
    }
  }
}

class PrintSettings extends GObjectObject {
  PrintSettings.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PrintSettings');

  factory PrintSettings() => _staticInfo.callStatic('new', []);
  factory PrintSettings.fromFile(String fileName) => _staticInfo.callStatic('new_from_file', [fileName]);
  factory PrintSettings.fromKeyFile(KeyFile keyFile, String groupName) => _staticInfo.callStatic('new_from_key_file', [keyFile, groupName]);
  PrintSettings copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void foreach(PrintSettingsFunc func) => _staticInfo.callMethodOnReceiver('foreach', this, [func]);
  String get_(String key) => _staticInfo.callMethodOnReceiver('get', this, [key]);
  bool getBool(String key) => _staticInfo.callMethodOnReceiver('get_bool', this, [key]);
  bool getCollate() => _staticInfo.callMethodOnReceiver('get_collate', this, []);
  String getDefaultSource() => _staticInfo.callMethodOnReceiver('get_default_source', this, []);
  String getDither() => _staticInfo.callMethodOnReceiver('get_dither', this, []);
  num getDouble(String key) => _staticInfo.callMethodOnReceiver('get_double', this, [key]);
  num getDoubleWithDefault(String key, num def) => _staticInfo.callMethodOnReceiver('get_double_with_default', this, [key, def]);
  PrintDuplex getDuplex() => _staticInfo.callMethodOnReceiver('get_duplex', this, []);
  String getFinishings() => _staticInfo.callMethodOnReceiver('get_finishings', this, []);
  int getInt(String key) => _staticInfo.callMethodOnReceiver('get_int', this, [key]);
  int getIntWithDefault(String key, int def) => _staticInfo.callMethodOnReceiver('get_int_with_default', this, [key, def]);
  num getLength(String key, Unit unit) => _staticInfo.callMethodOnReceiver('get_length', this, [key, unit]);
  String getMediaType() => _staticInfo.callMethodOnReceiver('get_media_type', this, []);
  int getNCopies() => _staticInfo.callMethodOnReceiver('get_n_copies', this, []);
  int getNumberUp() => _staticInfo.callMethodOnReceiver('get_number_up', this, []);
  NumberUpLayout getNumberUpLayout() => _staticInfo.callMethodOnReceiver('get_number_up_layout', this, []);
  PageOrientation getOrientation() => _staticInfo.callMethodOnReceiver('get_orientation', this, []);
  String getOutputBin() => _staticInfo.callMethodOnReceiver('get_output_bin', this, []);
  List<PageRange> getPageRanges() => _staticInfo.callMethodOnReceiver('get_page_ranges', this, []);
  PageSet getPageSet() => _staticInfo.callMethodOnReceiver('get_page_set', this, []);
  num getPaperHeight(Unit unit) => _staticInfo.callMethodOnReceiver('get_paper_height', this, [unit]);
  PaperSize getPaperSize() => _staticInfo.callMethodOnReceiver('get_paper_size', this, []);
  num getPaperWidth(Unit unit) => _staticInfo.callMethodOnReceiver('get_paper_width', this, [unit]);
  PrintPages getPrintPages() => _staticInfo.callMethodOnReceiver('get_print_pages', this, []);
  String getPrinter() => _staticInfo.callMethodOnReceiver('get_printer', this, []);
  num getPrinterLpi() => _staticInfo.callMethodOnReceiver('get_printer_lpi', this, []);
  PrintQuality getQuality() => _staticInfo.callMethodOnReceiver('get_quality', this, []);
  int getResolution() => _staticInfo.callMethodOnReceiver('get_resolution', this, []);
  int getResolutionX() => _staticInfo.callMethodOnReceiver('get_resolution_x', this, []);
  int getResolutionY() => _staticInfo.callMethodOnReceiver('get_resolution_y', this, []);
  bool getReverse() => _staticInfo.callMethodOnReceiver('get_reverse', this, []);
  num getScale() => _staticInfo.callMethodOnReceiver('get_scale', this, []);
  bool getUseColor() => _staticInfo.callMethodOnReceiver('get_use_color', this, []);
  bool hasKey(String key) => _staticInfo.callMethodOnReceiver('has_key', this, [key]);
  bool loadFile(String fileName) => _staticInfo.callMethodOnReceiver('load_file', this, [fileName]);
  bool loadKeyFile(KeyFile keyFile, String groupName) => _staticInfo.callMethodOnReceiver('load_key_file', this, [keyFile, groupName]);
  void set_(String key, String value) => _staticInfo.callMethodOnReceiver('set', this, [key, value]);
  void setBool(String key, bool value) => _staticInfo.callMethodOnReceiver('set_bool', this, [key, value]);
  void setCollate(bool collate) => _staticInfo.callMethodOnReceiver('set_collate', this, [collate]);
  void setDefaultSource(String defaultSource) => _staticInfo.callMethodOnReceiver('set_default_source', this, [defaultSource]);
  void setDither(String dither) => _staticInfo.callMethodOnReceiver('set_dither', this, [dither]);
  void setDouble(String key, num value) => _staticInfo.callMethodOnReceiver('set_double', this, [key, value]);
  void setDuplex(PrintDuplex duplex) => _staticInfo.callMethodOnReceiver('set_duplex', this, [duplex]);
  void setFinishings(String finishings) => _staticInfo.callMethodOnReceiver('set_finishings', this, [finishings]);
  void setInt(String key, int value) => _staticInfo.callMethodOnReceiver('set_int', this, [key, value]);
  void setLength(String key, num value, Unit unit) => _staticInfo.callMethodOnReceiver('set_length', this, [key, value, unit]);
  void setMediaType(String mediaType) => _staticInfo.callMethodOnReceiver('set_media_type', this, [mediaType]);
  void setNCopies(int numCopies) => _staticInfo.callMethodOnReceiver('set_n_copies', this, [numCopies]);
  void setNumberUp(int numberUp) => _staticInfo.callMethodOnReceiver('set_number_up', this, [numberUp]);
  void setNumberUpLayout(NumberUpLayout numberUpLayout) => _staticInfo.callMethodOnReceiver('set_number_up_layout', this, [numberUpLayout]);
  void setOrientation(PageOrientation orientation) => _staticInfo.callMethodOnReceiver('set_orientation', this, [orientation]);
  void setOutputBin(String outputBin) => _staticInfo.callMethodOnReceiver('set_output_bin', this, [outputBin]);
  void setPageRanges(List<PageRange> pageRanges) => _staticInfo.callMethodOnReceiver('set_page_ranges', this, [pageRanges]);
  void setPageSet(PageSet pageSet) => _staticInfo.callMethodOnReceiver('set_page_set', this, [pageSet]);
  void setPaperHeight(num height, Unit unit) => _staticInfo.callMethodOnReceiver('set_paper_height', this, [height, unit]);
  void setPaperSize(PaperSize paperSize) => _staticInfo.callMethodOnReceiver('set_paper_size', this, [paperSize]);
  void setPaperWidth(num width, Unit unit) => _staticInfo.callMethodOnReceiver('set_paper_width', this, [width, unit]);
  void setPrintPages(PrintPages pages) => _staticInfo.callMethodOnReceiver('set_print_pages', this, [pages]);
  void setPrinter(String printer) => _staticInfo.callMethodOnReceiver('set_printer', this, [printer]);
  void setPrinterLpi(num lpi) => _staticInfo.callMethodOnReceiver('set_printer_lpi', this, [lpi]);
  void setQuality(PrintQuality quality) => _staticInfo.callMethodOnReceiver('set_quality', this, [quality]);
  void setResolution(int resolution) => _staticInfo.callMethodOnReceiver('set_resolution', this, [resolution]);
  void setResolutionXy(int resolutionX, int resolutionY) => _staticInfo.callMethodOnReceiver('set_resolution_xy', this, [resolutionX, resolutionY]);
  void setReverse(bool reverse) => _staticInfo.callMethodOnReceiver('set_reverse', this, [reverse]);
  void setScale(num scale) => _staticInfo.callMethodOnReceiver('set_scale', this, [scale]);
  void setUseColor(bool useColor) => _staticInfo.callMethodOnReceiver('set_use_color', this, [useColor]);
  bool toFile(String fileName) => _staticInfo.callMethodOnReceiver('to_file', this, [fileName]);
  void toKeyFile(KeyFile keyFile, String groupName) => _staticInfo.callMethodOnReceiver('to_key_file', this, [keyFile, groupName]);
  void unset(String key) => _staticInfo.callMethodOnReceiver('unset', this, [key]);
}

typedef void PrintSettingsFunc(String key, String value);
class PrintStatus extends GEnumBase {
  const PrintStatus(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PrintStatus');

  static const PrintStatus INITIAL = const PrintStatus(0);
  static const PrintStatus PREPARING = const PrintStatus(1);
  static const PrintStatus GENERATING_DATA = const PrintStatus(2);
  static const PrintStatus SENDING_DATA = const PrintStatus(3);
  static const PrintStatus PENDING = const PrintStatus(4);
  static const PrintStatus PENDING_ISSUE = const PrintStatus(5);
  static const PrintStatus PRINTING = const PrintStatus(6);
  static const PrintStatus FINISHED = const PrintStatus(7);
  static const PrintStatus FINISHED_ABORTED = const PrintStatus(8);
  String toString() {
    switch(index) {
      case 0: return 'PrintStatus.INITIAL';
      case 1: return 'PrintStatus.PREPARING';
      case 2: return 'PrintStatus.GENERATING_DATA';
      case 3: return 'PrintStatus.SENDING_DATA';
      case 4: return 'PrintStatus.PENDING';
      case 5: return 'PrintStatus.PENDING_ISSUE';
      case 6: return 'PrintStatus.PRINTING';
      case 7: return 'PrintStatus.FINISHED';
      case 8: return 'PrintStatus.FINISHED_ABORTED';
      default: return 'new PrintStatus($index)';
    }
  }
}

class ProgressBar extends Widget with ImplementorIface, Buildable, Orientable {
  ProgressBar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ProgressBar');

  static const String ELLIPSIZE_PROPERTY = 'ellipsize';
  static const String FRACTION_PROPERTY = 'fraction';
  static const String INVERTED_PROPERTY = 'inverted';
  static const String PULSE_STEP_PROPERTY = 'pulse-step';
  static const String SHOW_TEXT_PROPERTY = 'show-text';
  static const String TEXT_PROPERTY = 'text';
  factory ProgressBar() => _staticInfo.callStatic('new', []);
  EllipsizeMode get ellipsize => _staticInfo.callMethodOnReceiver('get_ellipsize', this, []);
  num get fraction => _staticInfo.callMethodOnReceiver('get_fraction', this, []);
  bool get inverted => _staticInfo.callMethodOnReceiver('get_inverted', this, []);
  num get pulseStep => _staticInfo.callMethodOnReceiver('get_pulse_step', this, []);
  bool get showText => _staticInfo.callMethodOnReceiver('get_show_text', this, []);
  String get text => _staticInfo.callMethodOnReceiver('get_text', this, []);
  void pulse() => _staticInfo.callMethodOnReceiver('pulse', this, []);
  void set ellipsize(EllipsizeMode mode) => _staticInfo.callMethodOnReceiver('set_ellipsize', this, [mode]);
  void set fraction(num fraction) => _staticInfo.callMethodOnReceiver('set_fraction', this, [fraction]);
  void set inverted(bool inverted) => _staticInfo.callMethodOnReceiver('set_inverted', this, [inverted]);
  void set pulseStep(num fraction) => _staticInfo.callMethodOnReceiver('set_pulse_step', this, [fraction]);
  void set showText(bool showText) => _staticInfo.callMethodOnReceiver('set_show_text', this, [showText]);
  void set text(String text) => _staticInfo.callMethodOnReceiver('set_text', this, [text]);
}

class ProgressBarAccessible extends WidgetAccessible with Component, atk.Value {
  ProgressBarAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ProgressBarAccessible');

}

class PropagationPhase extends GEnumBase {
  const PropagationPhase(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'PropagationPhase');

  static const PropagationPhase NONE = const PropagationPhase(0);
  static const PropagationPhase CAPTURE = const PropagationPhase(1);
  static const PropagationPhase BUBBLE = const PropagationPhase(2);
  static const PropagationPhase TARGET = const PropagationPhase(3);
  String toString() {
    switch(index) {
      case 0: return 'PropagationPhase.NONE';
      case 1: return 'PropagationPhase.CAPTURE';
      case 2: return 'PropagationPhase.BUBBLE';
      case 3: return 'PropagationPhase.TARGET';
      default: return 'new PropagationPhase($index)';
    }
  }
}

class RadioAction extends ToggleAction with Buildable {
  RadioAction.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RadioAction');

  static const String CURRENT_VALUE_PROPERTY = 'current-value';
  static const String GROUP_PROPERTY = 'group';
  int get value => _staticInfo.getGPropertyOnReceiver('value', this);
  void set value(int value) => _staticInfo.setGPropertyOnReceiver('value', this, value);
  static const String VALUE_PROPERTY = 'value';
  factory RadioAction(String name, String label, String tooltip, String stockId, int value) => _staticInfo.callStatic('new', [name, label, tooltip, stockId, value]);
  int get currentValue => _staticInfo.callMethodOnReceiver('get_current_value', this, []);
  SList /* this will fail */ getGroup() => _staticInfo.callMethodOnReceiver('get_group', this, []);
  void joinGroup(RadioAction groupSource) => _staticInfo.callMethodOnReceiver('join_group', this, [groupSource]);
  void set currentValue(int currentValue) => _staticInfo.callMethodOnReceiver('set_current_value', this, [currentValue]);
  void set group(SList group /* this will fail */) => _staticInfo.callMethodOnReceiver('set_group', this, [group]);
  int _connectToChanged(bool after, void func(RadioAction current)) => signalConnect('changed', func, after);
  Stream<RadioAction> get onChanged {
    int signalId;
    StreamController<RadioAction> controller;
    controller = new StreamController<RadioAction>(
      onListen: () {
          signalId = _connectToChanged(false, (RadioAction current) {
              controller.add(current);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<RadioAction> get afterChanged {
    int signalId;
    StreamController<RadioAction> controller;
    controller = new StreamController<RadioAction>(
      onListen: () {
          signalId = _connectToChanged(true, (RadioAction current) {
              controller.add(current);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class RadioActionEntry extends GObjectBase {
  RadioActionEntry.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RadioActionEntry');

  String get name => getFieldOfObject('name', 0);
  void set name(String value) => setFieldOfObject('name', 0, value);
  String get stockId => getFieldOfObject('stock_id', 1);
  void set stockId(String value) => setFieldOfObject('stock_id', 1, value);
  String get label => getFieldOfObject('label', 2);
  void set label(String value) => setFieldOfObject('label', 2, value);
  String get accelerator => getFieldOfObject('accelerator', 3);
  void set accelerator(String value) => setFieldOfObject('accelerator', 3, value);
  String get tooltip => getFieldOfObject('tooltip', 4);
  void set tooltip(String value) => setFieldOfObject('tooltip', 4, value);
  int get value => getFieldOfObject('value', 5);
  void set value(int value) => setFieldOfObject('value', 5, value);
}

class RadioButton extends CheckButton with ImplementorIface, Actionable, Activatable, Buildable {
  RadioButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RadioButton');

  static const String GROUP_PROPERTY = 'group';
  factory RadioButton(SList group /* this will fail */) => _staticInfo.callStatic('new', [group]);
  factory RadioButton.fromWidget(RadioButton radioGroupMember) => _staticInfo.callStatic('new_from_widget', [radioGroupMember]);
  factory RadioButton.withLabel(SList group /* this will fail */, String label) => _staticInfo.callStatic('new_with_label', [group, label]);
  factory RadioButton.withLabelFromWidget(RadioButton radioGroupMember, String label) => _staticInfo.callStatic('new_with_label_from_widget', [radioGroupMember, label]);
  factory RadioButton.withMnemonic(SList group /* this will fail */, String label) => _staticInfo.callStatic('new_with_mnemonic', [group, label]);
  factory RadioButton.withMnemonicFromWidget(RadioButton radioGroupMember, String label) => _staticInfo.callStatic('new_with_mnemonic_from_widget', [radioGroupMember, label]);
  SList /* this will fail */ getGroup() => _staticInfo.callMethodOnReceiver('get_group', this, []);
  void joinGroup(RadioButton groupSource) => _staticInfo.callMethodOnReceiver('join_group', this, [groupSource]);
  void set group(SList group /* this will fail */) => _staticInfo.callMethodOnReceiver('set_group', this, [group]);
  int _connectToGroupChanged(bool after, void func()) => signalConnect('group-changed', func, after);
  Stream get onGroupChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToGroupChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterGroupChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToGroupChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class RadioButtonAccessible extends ToggleButtonAccessible with atk.Action, Component, atk.Image {
  RadioButtonAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RadioButtonAccessible');

}

class RadioMenuItem extends CheckMenuItem with ImplementorIface, Actionable, Activatable, Buildable {
  RadioMenuItem.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RadioMenuItem');

  static const String GROUP_PROPERTY = 'group';
  factory RadioMenuItem(SList group /* this will fail */) => _staticInfo.callStatic('new', [group]);
  factory RadioMenuItem.fromWidget(RadioMenuItem group) => _staticInfo.callStatic('new_from_widget', [group]);
  factory RadioMenuItem.withLabel(SList group /* this will fail */, String label) => _staticInfo.callStatic('new_with_label', [group, label]);
  factory RadioMenuItem.withLabelFromWidget(RadioMenuItem group, String label) => _staticInfo.callStatic('new_with_label_from_widget', [group, label]);
  factory RadioMenuItem.withMnemonic(SList group /* this will fail */, String label) => _staticInfo.callStatic('new_with_mnemonic', [group, label]);
  factory RadioMenuItem.withMnemonicFromWidget(RadioMenuItem group, String label) => _staticInfo.callStatic('new_with_mnemonic_from_widget', [group, label]);
  SList /* this will fail */ getGroup() => _staticInfo.callMethodOnReceiver('get_group', this, []);
  void joinGroup(RadioMenuItem groupSource) => _staticInfo.callMethodOnReceiver('join_group', this, [groupSource]);
  void set group(SList group /* this will fail */) => _staticInfo.callMethodOnReceiver('set_group', this, [group]);
  int _connectToGroupChanged(bool after, void func()) => signalConnect('group-changed', func, after);
  Stream get onGroupChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToGroupChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterGroupChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToGroupChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class RadioMenuItemAccessible extends CheckMenuItemAccessible with atk.Action, Component, Selection {
  RadioMenuItemAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RadioMenuItemAccessible');

}

class RadioToolButton extends ToggleToolButton with ImplementorIface, Actionable, Activatable, Buildable {
  RadioToolButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RadioToolButton');

  static const String GROUP_PROPERTY = 'group';
  factory RadioToolButton(SList group /* this will fail */) => _staticInfo.callStatic('new', [group]);
  factory RadioToolButton.fromStock(SList group /* this will fail */, String stockId) => _staticInfo.callStatic('new_from_stock', [group, stockId]);
  factory RadioToolButton.fromWidget(RadioToolButton group) => _staticInfo.callStatic('new_from_widget', [group]);
  factory RadioToolButton.withStockFromWidget(RadioToolButton group, String stockId) => _staticInfo.callStatic('new_with_stock_from_widget', [group, stockId]);
  SList /* this will fail */ getGroup() => _staticInfo.callMethodOnReceiver('get_group', this, []);
  void set group(SList group /* this will fail */) => _staticInfo.callMethodOnReceiver('set_group', this, [group]);
}

class Range extends Widget with ImplementorIface, Buildable, Orientable {
  Range.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Range');

  static const String ADJUSTMENT_PROPERTY = 'adjustment';
  static const String FILL_LEVEL_PROPERTY = 'fill-level';
  static const String INVERTED_PROPERTY = 'inverted';
  static const String LOWER_STEPPER_SENSITIVITY_PROPERTY = 'lower-stepper-sensitivity';
  static const String RESTRICT_TO_FILL_LEVEL_PROPERTY = 'restrict-to-fill-level';
  static const String ROUND_DIGITS_PROPERTY = 'round-digits';
  static const String SHOW_FILL_LEVEL_PROPERTY = 'show-fill-level';
  static const String UPPER_STEPPER_SENSITIVITY_PROPERTY = 'upper-stepper-sensitivity';
  Adjustment get adjustment => _staticInfo.callMethodOnReceiver('get_adjustment', this, []);
  num get fillLevel => _staticInfo.callMethodOnReceiver('get_fill_level', this, []);
  bool getFlippable() => _staticInfo.callMethodOnReceiver('get_flippable', this, []);
  bool get inverted => _staticInfo.callMethodOnReceiver('get_inverted', this, []);
  SensitivityType get lowerStepperSensitivity => _staticInfo.callMethodOnReceiver('get_lower_stepper_sensitivity', this, []);
  int getMinSliderSize() => _staticInfo.callMethodOnReceiver('get_min_slider_size', this, []);
  void getRangeRect() => _staticInfo.callMethodOnReceiver('get_range_rect', this, []);
  bool get restrictToFillLevel => _staticInfo.callMethodOnReceiver('get_restrict_to_fill_level', this, []);
  int get roundDigits => _staticInfo.callMethodOnReceiver('get_round_digits', this, []);
  bool get showFillLevel => _staticInfo.callMethodOnReceiver('get_show_fill_level', this, []);
  void getSliderRange() => _staticInfo.callMethodOnReceiver('get_slider_range', this, []);
  bool getSliderSizeFixed() => _staticInfo.callMethodOnReceiver('get_slider_size_fixed', this, []);
  SensitivityType get upperStepperSensitivity => _staticInfo.callMethodOnReceiver('get_upper_stepper_sensitivity', this, []);
  num getValue() => _staticInfo.callMethodOnReceiver('get_value', this, []);
  void set adjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_adjustment', this, [adjustment]);
  void set fillLevel(num fillLevel) => _staticInfo.callMethodOnReceiver('set_fill_level', this, [fillLevel]);
  void setFlippable(bool flippable) => _staticInfo.callMethodOnReceiver('set_flippable', this, [flippable]);
  void setIncrements(num step, num page) => _staticInfo.callMethodOnReceiver('set_increments', this, [step, page]);
  void set inverted(bool setting) => _staticInfo.callMethodOnReceiver('set_inverted', this, [setting]);
  void set lowerStepperSensitivity(SensitivityType sensitivity) => _staticInfo.callMethodOnReceiver('set_lower_stepper_sensitivity', this, [sensitivity]);
  void setMinSliderSize(int minSize) => _staticInfo.callMethodOnReceiver('set_min_slider_size', this, [minSize]);
  void setRange(num min, num max) => _staticInfo.callMethodOnReceiver('set_range', this, [min, max]);
  void set restrictToFillLevel(bool restrictToFillLevel) => _staticInfo.callMethodOnReceiver('set_restrict_to_fill_level', this, [restrictToFillLevel]);
  void set roundDigits(int roundDigits) => _staticInfo.callMethodOnReceiver('set_round_digits', this, [roundDigits]);
  void set showFillLevel(bool showFillLevel) => _staticInfo.callMethodOnReceiver('set_show_fill_level', this, [showFillLevel]);
  void setSliderSizeFixed(bool sizeFixed) => _staticInfo.callMethodOnReceiver('set_slider_size_fixed', this, [sizeFixed]);
  void set upperStepperSensitivity(SensitivityType sensitivity) => _staticInfo.callMethodOnReceiver('set_upper_stepper_sensitivity', this, [sensitivity]);
  void setValue(num value) => _staticInfo.callMethodOnReceiver('set_value', this, [value]);
  int _connectToAdjustBounds(bool after, void func(num value)) => signalConnect('adjust-bounds', func, after);
  Stream<num> get onAdjustBounds {
    int signalId;
    StreamController<num> controller;
    controller = new StreamController<num>(
      onListen: () {
          signalId = _connectToAdjustBounds(false, (num value) {
              controller.add(value);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<num> get afterAdjustBounds {
    int signalId;
    StreamController<num> controller;
    controller = new StreamController<num>(
      onListen: () {
          signalId = _connectToAdjustBounds(true, (num value) {
              controller.add(value);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToChangeValue(bool after, bool func(ScrollType scroll, num value)) => signalConnect('change-value', func, after);
  Stream<RangeChangeValueEvent> get onChangeValue {
    int signalId;
    StreamController<RangeChangeValueEvent> controller;
    controller = new StreamController<RangeChangeValueEvent>(
      onListen: () {
          signalId = _connectToChangeValue(false, (ScrollType scroll, num value) {
              var result = new RangeChangeValueEvent(scroll, value);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<RangeChangeValueEvent> get afterChangeValue {
    int signalId;
    StreamController<RangeChangeValueEvent> controller;
    controller = new StreamController<RangeChangeValueEvent>(
      onListen: () {
          signalId = _connectToChangeValue(true, (ScrollType scroll, num value) {
              var result = new RangeChangeValueEvent(scroll, value);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveSlider(bool after, void func(ScrollType step)) => signalConnect('move-slider', func, after);
  Stream<ScrollType> get onMoveSlider {
    int signalId;
    StreamController<ScrollType> controller;
    controller = new StreamController<ScrollType>(
      onListen: () {
          signalId = _connectToMoveSlider(false, (ScrollType step) {
              controller.add(step);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ScrollType> get afterMoveSlider {
    int signalId;
    StreamController<ScrollType> controller;
    controller = new StreamController<ScrollType>(
      onListen: () {
          signalId = _connectToMoveSlider(true, (ScrollType step) {
              controller.add(step);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToValueChanged(bool after, void func()) => signalConnect('value-changed', func, after);
  Stream get onValueChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToValueChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterValueChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToValueChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class RangeChangeValueEvent {
  final ScrollType scroll;
  final num value;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  RangeChangeValueEvent(this.scroll, this.value);
}

class RangeAccessible extends WidgetAccessible with Component, atk.Value {
  RangeAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RangeAccessible');

}

class RcContext extends GObjectBase {
  RcContext.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RcContext');

}

class RcFlags extends GEnumBase {
  const RcFlags(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RcFlags');

  static const RcFlags NULL = const RcFlags(0);
  static const RcFlags FG = const RcFlags(1);
  bool get fg => (index & 1) == 1;
  static const RcFlags BG = const RcFlags(2);
  bool get bg => (index & 2) == 2;
  static const RcFlags TEXT = const RcFlags(4);
  bool get text => (index & 4) == 4;
  static const RcFlags BASE = const RcFlags(8);
  bool get base => (index & 8) == 8;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'RcFlags.FG';
      case 2: return 'RcFlags.BG';
      case 4: return 'RcFlags.TEXT';
      case 8: return 'RcFlags.BASE';
      default: return 'new RcFlags($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'RcFlags.NULL';
    }
    List codes = [];
    for (var i=1; i <= 8; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  RcFlags operator|(RcFlags other) =>
    new RcFlags(index | other.index);
  RcFlags operator&(RcFlags other) =>
    new RcFlags(index & other.index);
}

class RcProperty extends GObjectBase {
  RcProperty.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RcProperty');

  int get typeName => getFieldOfObject('type_name', 0);
  void set typeName(int value) => setFieldOfObject('type_name', 0, value);
  int get propertyName => getFieldOfObject('property_name', 1);
  void set propertyName(int value) => setFieldOfObject('property_name', 1, value);
  String get origin => getFieldOfObject('origin', 2);
  void set origin(String value) => setFieldOfObject('origin', 2, value);
  Value get value => getFieldOfObject('value', 3);
  void set value(Value value) => setFieldOfObject('value', 3, value);
  static bool parseBorder(ParamSpec pspec, GLibString gstring, Value propertyValue) => _staticInfo.callStatic('parse_border', [pspec, gstring, propertyValue]);
  static bool parseColor(ParamSpec pspec, GLibString gstring, Value propertyValue) => _staticInfo.callStatic('parse_color', [pspec, gstring, propertyValue]);
  static bool parseEnum(ParamSpec pspec, GLibString gstring, Value propertyValue) => _staticInfo.callStatic('parse_enum', [pspec, gstring, propertyValue]);
  static bool parseFlags(ParamSpec pspec, GLibString gstring, Value propertyValue) => _staticInfo.callStatic('parse_flags', [pspec, gstring, propertyValue]);
  static bool parseRequisition(ParamSpec pspec, GLibString gstring, Value propertyValue) => _staticInfo.callStatic('parse_requisition', [pspec, gstring, propertyValue]);
}

typedef bool RcPropertyParser(ParamSpec pspec, GLibString rcString, Value propertyValue);
class RcStyle extends GObjectObject {
  RcStyle.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RcStyle');

  factory RcStyle() => _staticInfo.callStatic('new', []);
  RcStyle copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  String get name => getFieldOfObject('name', 1);
  List<String> get bgPixmapName => getFieldOfObject('bg_pixmap_name', 2);
  FontDescription get fontDesc => getFieldOfObject('font_desc', 3);
  List<RcFlags> get colorFlags => getFieldOfObject('color_flags', 4);
  List<Color> get fg => getFieldOfObject('fg', 5);
  List<Color> get bg => getFieldOfObject('bg', 6);
  List<Color> get text => getFieldOfObject('text', 7);
  List<Color> get base => getFieldOfObject('base', 8);
  int get xthickness => getFieldOfObject('xthickness', 9);
  int get ythickness => getFieldOfObject('ythickness', 10);
  List<dynamic /* this will fail */> get rcProperties => getFieldOfObject('rc_properties', 11);
  SList /* this will fail */ get rcStyleLists => getFieldOfObject('rc_style_lists', 12);
  SList /* this will fail */ get iconFactories => getFieldOfObject('icon_factories', 13);
  int get engineSpecified => getFieldOfObject('engine_specified', 14);
}

class RcTokenType extends GEnumBase {
  const RcTokenType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RcTokenType');

  static const RcTokenType INVALID = const RcTokenType(270);
  static const RcTokenType INCLUDE = const RcTokenType(271);
  static const RcTokenType NORMAL = const RcTokenType(272);
  static const RcTokenType ACTIVE = const RcTokenType(273);
  static const RcTokenType PRELIGHT = const RcTokenType(274);
  static const RcTokenType SELECTED = const RcTokenType(275);
  static const RcTokenType INSENSITIVE = const RcTokenType(276);
  static const RcTokenType FG = const RcTokenType(277);
  static const RcTokenType BG = const RcTokenType(278);
  static const RcTokenType TEXT = const RcTokenType(279);
  static const RcTokenType BASE = const RcTokenType(280);
  static const RcTokenType XTHICKNESS = const RcTokenType(281);
  static const RcTokenType YTHICKNESS = const RcTokenType(282);
  static const RcTokenType FONT = const RcTokenType(283);
  static const RcTokenType FONTSET = const RcTokenType(284);
  static const RcTokenType FONT_NAME = const RcTokenType(285);
  static const RcTokenType BG_PIXMAP = const RcTokenType(286);
  static const RcTokenType PIXMAP_PATH = const RcTokenType(287);
  static const RcTokenType STYLE = const RcTokenType(288);
  static const RcTokenType BINDING = const RcTokenType(289);
  static const RcTokenType BIND = const RcTokenType(290);
  static const RcTokenType WIDGET = const RcTokenType(291);
  static const RcTokenType WIDGET_CLASS = const RcTokenType(292);
  static const RcTokenType CLASS = const RcTokenType(293);
  static const RcTokenType LOWEST = const RcTokenType(294);
  static const RcTokenType GTK = const RcTokenType(295);
  static const RcTokenType APPLICATION = const RcTokenType(296);
  static const RcTokenType THEME = const RcTokenType(297);
  static const RcTokenType RC = const RcTokenType(298);
  static const RcTokenType HIGHEST = const RcTokenType(299);
  static const RcTokenType ENGINE = const RcTokenType(300);
  static const RcTokenType MODULE_PATH = const RcTokenType(301);
  static const RcTokenType IM_MODULE_PATH = const RcTokenType(302);
  static const RcTokenType IM_MODULE_FILE = const RcTokenType(303);
  static const RcTokenType STOCK = const RcTokenType(304);
  static const RcTokenType LTR = const RcTokenType(305);
  static const RcTokenType RTL = const RcTokenType(306);
  static const RcTokenType COLOR = const RcTokenType(307);
  static const RcTokenType UNBIND = const RcTokenType(308);
  static const RcTokenType LAST = const RcTokenType(309);
  String toString() {
    switch(index) {
      case 270: return 'RcTokenType.INVALID';
      case 271: return 'RcTokenType.INCLUDE';
      case 272: return 'RcTokenType.NORMAL';
      case 273: return 'RcTokenType.ACTIVE';
      case 274: return 'RcTokenType.PRELIGHT';
      case 275: return 'RcTokenType.SELECTED';
      case 276: return 'RcTokenType.INSENSITIVE';
      case 277: return 'RcTokenType.FG';
      case 278: return 'RcTokenType.BG';
      case 279: return 'RcTokenType.TEXT';
      case 280: return 'RcTokenType.BASE';
      case 281: return 'RcTokenType.XTHICKNESS';
      case 282: return 'RcTokenType.YTHICKNESS';
      case 283: return 'RcTokenType.FONT';
      case 284: return 'RcTokenType.FONTSET';
      case 285: return 'RcTokenType.FONT_NAME';
      case 286: return 'RcTokenType.BG_PIXMAP';
      case 287: return 'RcTokenType.PIXMAP_PATH';
      case 288: return 'RcTokenType.STYLE';
      case 289: return 'RcTokenType.BINDING';
      case 290: return 'RcTokenType.BIND';
      case 291: return 'RcTokenType.WIDGET';
      case 292: return 'RcTokenType.WIDGET_CLASS';
      case 293: return 'RcTokenType.CLASS';
      case 294: return 'RcTokenType.LOWEST';
      case 295: return 'RcTokenType.GTK';
      case 296: return 'RcTokenType.APPLICATION';
      case 297: return 'RcTokenType.THEME';
      case 298: return 'RcTokenType.RC';
      case 299: return 'RcTokenType.HIGHEST';
      case 300: return 'RcTokenType.ENGINE';
      case 301: return 'RcTokenType.MODULE_PATH';
      case 302: return 'RcTokenType.IM_MODULE_PATH';
      case 303: return 'RcTokenType.IM_MODULE_FILE';
      case 304: return 'RcTokenType.STOCK';
      case 305: return 'RcTokenType.LTR';
      case 306: return 'RcTokenType.RTL';
      case 307: return 'RcTokenType.COLOR';
      case 308: return 'RcTokenType.UNBIND';
      case 309: return 'RcTokenType.LAST';
      default: return 'new RcTokenType($index)';
    }
  }
}

class RecentAction extends Action with Buildable, RecentChooser {
  RecentAction.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentAction');

  static const String SHOW_NUMBERS_PROPERTY = 'show-numbers';
  factory RecentAction(String name, String label, String tooltip, String stockId) => _staticInfo.callStatic('new', [name, label, tooltip, stockId]);
  factory RecentAction.forManager(String name, String label, String tooltip, String stockId, RecentManager manager) => _staticInfo.callStatic('new_for_manager', [name, label, tooltip, stockId, manager]);
  bool get showNumbers => _staticInfo.callMethodOnReceiver('get_show_numbers', this, []);
  void set showNumbers(bool showNumbers) => _staticInfo.callMethodOnReceiver('set_show_numbers', this, [showNumbers]);
}

abstract class RecentChooser extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentChooser');

  static const String FILTER_PROPERTY = 'filter';
  static const String LIMIT_PROPERTY = 'limit';
  static const String LOCAL_ONLY_PROPERTY = 'local-only';
  void set recentManager(RecentManager value) => _staticInfo.setGPropertyOnReceiver('recent-manager', this, value);
  static const String RECENT_MANAGER_PROPERTY = 'recent-manager';
  static const String SELECT_MULTIPLE_PROPERTY = 'select-multiple';
  static const String SHOW_ICONS_PROPERTY = 'show-icons';
  static const String SHOW_NOT_FOUND_PROPERTY = 'show-not-found';
  static const String SHOW_PRIVATE_PROPERTY = 'show-private';
  static const String SHOW_TIPS_PROPERTY = 'show-tips';
  static const String SORT_TYPE_PROPERTY = 'sort-type';
  void addFilter(RecentFilter filter) => _staticInfo.callMethodOnReceiver('add_filter', this, [filter]);
  RecentInfo getCurrentItem() => _staticInfo.callMethodOnReceiver('get_current_item', this, []);
  String getCurrentUri() => _staticInfo.callMethodOnReceiver('get_current_uri', this, []);
  RecentFilter get filter => _staticInfo.callMethodOnReceiver('get_filter', this, []);
  GLibList /* this will fail */ getItems() => _staticInfo.callMethodOnReceiver('get_items', this, []);
  int get limit => _staticInfo.callMethodOnReceiver('get_limit', this, []);
  bool get localOnly => _staticInfo.callMethodOnReceiver('get_local_only', this, []);
  bool get selectMultiple => _staticInfo.callMethodOnReceiver('get_select_multiple', this, []);
  bool get showIcons => _staticInfo.callMethodOnReceiver('get_show_icons', this, []);
  bool get showNotFound => _staticInfo.callMethodOnReceiver('get_show_not_found', this, []);
  bool get showPrivate => _staticInfo.callMethodOnReceiver('get_show_private', this, []);
  bool get showTips => _staticInfo.callMethodOnReceiver('get_show_tips', this, []);
  RecentSortType get sortType => _staticInfo.callMethodOnReceiver('get_sort_type', this, []);
  List<String> getUris() => _staticInfo.callMethodOnReceiver('get_uris', this, []);
  SList /* this will fail */ listFilters() => _staticInfo.callMethodOnReceiver('list_filters', this, []);
  void removeFilter(RecentFilter filter) => _staticInfo.callMethodOnReceiver('remove_filter', this, [filter]);
  void selectAll() => _staticInfo.callMethodOnReceiver('select_all', this, []);
  bool selectUri(String uri) => _staticInfo.callMethodOnReceiver('select_uri', this, [uri]);
  bool setCurrentUri(String uri) => _staticInfo.callMethodOnReceiver('set_current_uri', this, [uri]);
  void set filter(RecentFilter filter) => _staticInfo.callMethodOnReceiver('set_filter', this, [filter]);
  void set limit(int limit) => _staticInfo.callMethodOnReceiver('set_limit', this, [limit]);
  void set localOnly(bool localOnly) => _staticInfo.callMethodOnReceiver('set_local_only', this, [localOnly]);
  void set selectMultiple(bool selectMultiple) => _staticInfo.callMethodOnReceiver('set_select_multiple', this, [selectMultiple]);
  void set showIcons(bool showIcons) => _staticInfo.callMethodOnReceiver('set_show_icons', this, [showIcons]);
  void set showNotFound(bool showNotFound) => _staticInfo.callMethodOnReceiver('set_show_not_found', this, [showNotFound]);
  void set showPrivate(bool showPrivate) => _staticInfo.callMethodOnReceiver('set_show_private', this, [showPrivate]);
  void set showTips(bool showTips) => _staticInfo.callMethodOnReceiver('set_show_tips', this, [showTips]);
  void setSortFunc(RecentSortFunc sortFunc) => _staticInfo.callMethodOnReceiver('set_sort_func', this, [sortFunc]);
  void set sortType(RecentSortType sortType) => _staticInfo.callMethodOnReceiver('set_sort_type', this, [sortType]);
  void unselectAll() => _staticInfo.callMethodOnReceiver('unselect_all', this, []);
  void unselectUri(String uri) => _staticInfo.callMethodOnReceiver('unselect_uri', this, [uri]);
  int _connectToItemActivated(bool after, void func()) => signalConnect('item-activated', func, after);
  Stream get onItemActivated {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToItemActivated(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterItemActivated {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToItemActivated(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectionChanged(bool after, void func()) => signalConnect('selection-changed', func, after);
  Stream get onSelectionChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectionChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSelectionChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSelectionChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class RecentChooserDialog extends Dialog with ImplementorIface, Buildable, RecentChooser {
  RecentChooserDialog.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentChooserDialog');

}

class RecentChooserErrorCode extends GEnumBase {
  const RecentChooserErrorCode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentChooserError');

  static const RecentChooserErrorCode NOT_FOUND = const RecentChooserErrorCode(0);
  static const RecentChooserErrorCode INVALID_URI = const RecentChooserErrorCode(1);
  String toString() {
    switch(index) {
      case 0: return 'RecentChooserErrorCode.NOT_FOUND';
      case 1: return 'RecentChooserErrorCode.INVALID_URI';
      default: return 'new RecentChooserErrorCode($index)';
    }
  }
  static int quark() => _staticInfo.callStatic('quark', []);
}

class RecentChooserError extends GErrorBase {
  static final int _quark = lookupErrorQuarkFromString('gtk-recent-chooser-error-quark');
  RecentChooserError(RecentChooserErrorCode code, String message)
      : super.fromFields(_quark, code, message);
}

class RecentChooserMenu extends Menu with ImplementorIface, Activatable, Buildable, RecentChooser {
  RecentChooserMenu.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentChooserMenu');

  static const String SHOW_NUMBERS_PROPERTY = 'show-numbers';
  factory RecentChooserMenu() => _staticInfo.callStatic('new', []);
  factory RecentChooserMenu.forManager(RecentManager manager) => _staticInfo.callStatic('new_for_manager', [manager]);
  bool get showNumbers => _staticInfo.callMethodOnReceiver('get_show_numbers', this, []);
  void set showNumbers(bool showNumbers) => _staticInfo.callMethodOnReceiver('set_show_numbers', this, [showNumbers]);
}

class RecentChooserWidget extends Box with ImplementorIface, Buildable, Orientable, RecentChooser {
  RecentChooserWidget.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentChooserWidget');

  factory RecentChooserWidget() => _staticInfo.callStatic('new', []);
  factory RecentChooserWidget.forManager(RecentManager manager) => _staticInfo.callStatic('new_for_manager', [manager]);
}

class RecentData extends GObjectBase {
  RecentData.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentData');

  String get displayName => getFieldOfObject('display_name', 0);
  void set displayName(String value) => setFieldOfObject('display_name', 0, value);
  String get description => getFieldOfObject('description', 1);
  void set description(String value) => setFieldOfObject('description', 1, value);
  String get mimeType => getFieldOfObject('mime_type', 2);
  void set mimeType(String value) => setFieldOfObject('mime_type', 2, value);
  String get appName => getFieldOfObject('app_name', 3);
  void set appName(String value) => setFieldOfObject('app_name', 3, value);
  String get appExec => getFieldOfObject('app_exec', 4);
  void set appExec(String value) => setFieldOfObject('app_exec', 4, value);
  List<String> get groups => getFieldOfObject('groups', 5);
  void set groups(List<String> value) => setFieldOfObject('groups', 5, value);
  bool get isPrivate => getFieldOfObject('is_private', 6);
  void set isPrivate(bool value) => setFieldOfObject('is_private', 6, value);
}

class RecentFilter extends InitiallyUnowned with Buildable {
  RecentFilter.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentFilter');

  factory RecentFilter() => _staticInfo.callStatic('new', []);
  void addAge(int days) => _staticInfo.callMethodOnReceiver('add_age', this, [days]);
  void addApplication(String application) => _staticInfo.callMethodOnReceiver('add_application', this, [application]);
  void addCustom(RecentFilterFlags needed, RecentFilterFunc func) => _staticInfo.callMethodOnReceiver('add_custom', this, [needed, func]);
  void addGroup(String group) => _staticInfo.callMethodOnReceiver('add_group', this, [group]);
  void addMimeType(String mimeType) => _staticInfo.callMethodOnReceiver('add_mime_type', this, [mimeType]);
  void addCairoPattern(String pattern) => _staticInfo.callMethodOnReceiver('add_pattern', this, [pattern]);
  void addPixbufFormats() => _staticInfo.callMethodOnReceiver('add_pixbuf_formats', this, []);
  bool filter(RecentFilterInfo filterInfo) => _staticInfo.callMethodOnReceiver('filter', this, [filterInfo]);
  String getName() => _staticInfo.callMethodOnReceiver('get_name', this, []);
  RecentFilterFlags getNeeded() => _staticInfo.callMethodOnReceiver('get_needed', this, []);
  void setName(String name) => _staticInfo.callMethodOnReceiver('set_name', this, [name]);
}

class RecentFilterFlags extends GEnumBase {
  const RecentFilterFlags(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentFilterFlags');

  static const RecentFilterFlags NULL = const RecentFilterFlags(0);
  static const RecentFilterFlags URI = const RecentFilterFlags(1);
  bool get uri => (index & 1) == 1;
  static const RecentFilterFlags DISPLAY_NAME = const RecentFilterFlags(2);
  bool get displayName => (index & 2) == 2;
  static const RecentFilterFlags MIME_TYPE = const RecentFilterFlags(4);
  bool get mimeType => (index & 4) == 4;
  static const RecentFilterFlags APPLICATION = const RecentFilterFlags(8);
  bool get application => (index & 8) == 8;
  static const RecentFilterFlags GROUP = const RecentFilterFlags(16);
  bool get group => (index & 16) == 16;
  static const RecentFilterFlags AGE = const RecentFilterFlags(32);
  bool get age => (index & 32) == 32;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'RecentFilterFlags.URI';
      case 2: return 'RecentFilterFlags.DISPLAY_NAME';
      case 4: return 'RecentFilterFlags.MIME_TYPE';
      case 8: return 'RecentFilterFlags.APPLICATION';
      case 16: return 'RecentFilterFlags.GROUP';
      case 32: return 'RecentFilterFlags.AGE';
      default: return 'new RecentFilterFlags($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'RecentFilterFlags.NULL';
    }
    List codes = [];
    for (var i=1; i <= 32; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  RecentFilterFlags operator|(RecentFilterFlags other) =>
    new RecentFilterFlags(index | other.index);
  RecentFilterFlags operator&(RecentFilterFlags other) =>
    new RecentFilterFlags(index & other.index);
}

typedef bool RecentFilterFunc(RecentFilterInfo filterInfo);
class RecentFilterInfo extends GObjectBase {
  RecentFilterInfo.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentFilterInfo');

  RecentFilterFlags get contains => getFieldOfObject('contains', 0);
  void set contains(RecentFilterFlags value) => setFieldOfObject('contains', 0, value);
  String get uri => getFieldOfObject('uri', 1);
  void set uri(String value) => setFieldOfObject('uri', 1, value);
  String get displayName => getFieldOfObject('display_name', 2);
  void set displayName(String value) => setFieldOfObject('display_name', 2, value);
  String get mimeType => getFieldOfObject('mime_type', 3);
  void set mimeType(String value) => setFieldOfObject('mime_type', 3, value);
  List<String> get applications => getFieldOfObject('applications', 4);
  void set applications(List<String> value) => setFieldOfObject('applications', 4, value);
  List<String> get groups => getFieldOfObject('groups', 5);
  void set groups(List<String> value) => setFieldOfObject('groups', 5, value);
  int get age => getFieldOfObject('age', 6);
  void set age(int value) => setFieldOfObject('age', 6, value);
}

class RecentInfo extends GObjectBase {
  RecentInfo.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentInfo');

  AppInfo createAppInfo(String appName) => _staticInfo.callMethodOnReceiver('create_app_info', this, [appName]);
  bool exists() => _staticInfo.callMethodOnReceiver('exists', this, []);
  int getAdded() => _staticInfo.callMethodOnReceiver('get_added', this, []);
  int getAge() => _staticInfo.callMethodOnReceiver('get_age', this, []);
  bool getApplicationInfo(String appName) => _staticInfo.callMethodOnReceiver('get_application_info', this, [appName]);
  List<String> getApplications() => _staticInfo.callMethodOnReceiver('get_applications', this, []);
  String getDescription() => _staticInfo.callMethodOnReceiver('get_description', this, []);
  String getDisplayName() => _staticInfo.callMethodOnReceiver('get_display_name', this, []);
  Icon getGicon() => _staticInfo.callMethodOnReceiver('get_gicon', this, []);
  List<String> getGroups() => _staticInfo.callMethodOnReceiver('get_groups', this, []);
  Pixbuf getIcon(int size) => _staticInfo.callMethodOnReceiver('get_icon', this, [size]);
  String getMimeType() => _staticInfo.callMethodOnReceiver('get_mime_type', this, []);
  int getModified() => _staticInfo.callMethodOnReceiver('get_modified', this, []);
  bool getPrivateHint() => _staticInfo.callMethodOnReceiver('get_private_hint', this, []);
  String getShortName() => _staticInfo.callMethodOnReceiver('get_short_name', this, []);
  String getUri() => _staticInfo.callMethodOnReceiver('get_uri', this, []);
  String getUriDisplay() => _staticInfo.callMethodOnReceiver('get_uri_display', this, []);
  int getVisited() => _staticInfo.callMethodOnReceiver('get_visited', this, []);
  bool hasApplication(String appName) => _staticInfo.callMethodOnReceiver('has_application', this, [appName]);
  bool hasGroup(String groupName) => _staticInfo.callMethodOnReceiver('has_group', this, [groupName]);
  bool isLocal() => _staticInfo.callMethodOnReceiver('is_local', this, []);
  String lastApplication() => _staticInfo.callMethodOnReceiver('last_application', this, []);
  bool match(RecentInfo infoB) => _staticInfo.callMethodOnReceiver('match', this, [infoB]);
  RecentInfo ref() => _staticInfo.callMethodOnReceiver('ref', this, []);
  void unref() => _staticInfo.callMethodOnReceiver('unref', this, []);
}

class RecentManager extends GObjectObject {
  RecentManager.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentManager');

  String get filename => _staticInfo.getGPropertyOnReceiver('filename', this);
  void set filename(String value) => _staticInfo.setGPropertyOnReceiver('filename', this, value);
  static const String FILENAME_PROPERTY = 'filename';
  int get size => _staticInfo.getGPropertyOnReceiver('size', this);
  static const String SIZE_PROPERTY = 'size';
  factory RecentManager() => _staticInfo.callStatic('new', []);
  static RecentManager getDefault() => _staticInfo.callStatic('get_default', []);
  bool addFull(String uri, RecentData recentData) => _staticInfo.callMethodOnReceiver('add_full', this, [uri, recentData]);
  bool addItem(String uri) => _staticInfo.callMethodOnReceiver('add_item', this, [uri]);
  GLibList /* this will fail */ getItems() => _staticInfo.callMethodOnReceiver('get_items', this, []);
  bool hasItem(String uri) => _staticInfo.callMethodOnReceiver('has_item', this, [uri]);
  RecentInfo lookupItem(String uri) => _staticInfo.callMethodOnReceiver('lookup_item', this, [uri]);
  bool moveItem(String uri, String newUri) => _staticInfo.callMethodOnReceiver('move_item', this, [uri, newUri]);
  int purgeItems() => _staticInfo.callMethodOnReceiver('purge_items', this, []);
  bool removeItem(String uri) => _staticInfo.callMethodOnReceiver('remove_item', this, [uri]);
  int _connectToChanged(bool after, void func()) => signalConnect('changed', func, after);
  Stream get onChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class RecentManagerErrorCode extends GEnumBase {
  const RecentManagerErrorCode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentManagerError');

  static const RecentManagerErrorCode NOT_FOUND = const RecentManagerErrorCode(0);
  static const RecentManagerErrorCode INVALID_URI = const RecentManagerErrorCode(1);
  static const RecentManagerErrorCode INVALID_ENCODING = const RecentManagerErrorCode(2);
  static const RecentManagerErrorCode NOT_REGISTERED = const RecentManagerErrorCode(3);
  static const RecentManagerErrorCode READ = const RecentManagerErrorCode(4);
  static const RecentManagerErrorCode WRITE = const RecentManagerErrorCode(5);
  static const RecentManagerErrorCode UNKNOWN = const RecentManagerErrorCode(6);
  String toString() {
    switch(index) {
      case 0: return 'RecentManagerErrorCode.NOT_FOUND';
      case 1: return 'RecentManagerErrorCode.INVALID_URI';
      case 2: return 'RecentManagerErrorCode.INVALID_ENCODING';
      case 3: return 'RecentManagerErrorCode.NOT_REGISTERED';
      case 4: return 'RecentManagerErrorCode.READ';
      case 5: return 'RecentManagerErrorCode.WRITE';
      case 6: return 'RecentManagerErrorCode.UNKNOWN';
      default: return 'new RecentManagerErrorCode($index)';
    }
  }
  static int quark() => _staticInfo.callStatic('quark', []);
}

class RecentManagerError extends GErrorBase {
  static final int _quark = lookupErrorQuarkFromString('gtk-recent-manager-error-quark');
  RecentManagerError(RecentManagerErrorCode code, String message)
      : super.fromFields(_quark, code, message);
}

typedef int RecentSortFunc(RecentInfo a, RecentInfo b);
class RecentSortType extends GEnumBase {
  const RecentSortType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RecentSortType');

  static const RecentSortType NONE = const RecentSortType(0);
  static const RecentSortType MRU = const RecentSortType(1);
  static const RecentSortType LRU = const RecentSortType(2);
  static const RecentSortType CUSTOM = const RecentSortType(3);
  String toString() {
    switch(index) {
      case 0: return 'RecentSortType.NONE';
      case 1: return 'RecentSortType.MRU';
      case 2: return 'RecentSortType.LRU';
      case 3: return 'RecentSortType.CUSTOM';
      default: return 'new RecentSortType($index)';
    }
  }
}

class RegionFlags extends GEnumBase {
  const RegionFlags(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RegionFlags');

  static const RegionFlags NULL = const RegionFlags(0);
  static const RegionFlags EVEN = const RegionFlags(1);
  bool get even => (index & 1) == 1;
  static const RegionFlags ODD = const RegionFlags(2);
  bool get odd => (index & 2) == 2;
  static const RegionFlags FIRST = const RegionFlags(4);
  bool get first => (index & 4) == 4;
  static const RegionFlags LAST = const RegionFlags(8);
  bool get last => (index & 8) == 8;
  static const RegionFlags ONLY = const RegionFlags(16);
  bool get only => (index & 16) == 16;
  static const RegionFlags SORTED = const RegionFlags(32);
  bool get sorted => (index & 32) == 32;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'RegionFlags.EVEN';
      case 2: return 'RegionFlags.ODD';
      case 4: return 'RegionFlags.FIRST';
      case 8: return 'RegionFlags.LAST';
      case 16: return 'RegionFlags.ONLY';
      case 32: return 'RegionFlags.SORTED';
      default: return 'new RegionFlags($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'RegionFlags.NULL';
    }
    List codes = [];
    for (var i=1; i <= 32; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  RegionFlags operator|(RegionFlags other) =>
    new RegionFlags(index | other.index);
  RegionFlags operator&(RegionFlags other) =>
    new RegionFlags(index & other.index);
}

class ReliefStyle extends GEnumBase {
  const ReliefStyle(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ReliefStyle');

  static const ReliefStyle NORMAL = const ReliefStyle(0);
  static const ReliefStyle HALF = const ReliefStyle(1);
  static const ReliefStyle NONE = const ReliefStyle(2);
  String toString() {
    switch(index) {
      case 0: return 'ReliefStyle.NORMAL';
      case 1: return 'ReliefStyle.HALF';
      case 2: return 'ReliefStyle.NONE';
      default: return 'new ReliefStyle($index)';
    }
  }
}

class RendererCellAccessible extends CellAccessible with atk.Action, Component {
  RendererCellAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RendererCellAccessible');

  CellRenderer get renderer => _staticInfo.getGPropertyOnReceiver('renderer', this);
  void set renderer(CellRenderer value) => _staticInfo.setGPropertyOnReceiver('renderer', this, value);
  static const String RENDERER_PROPERTY = 'renderer';
  factory RendererCellAccessible(CellRenderer renderer) => _staticInfo.callStatic('new', [renderer]);
}

class RequestedSize extends GObjectBase {
  RequestedSize.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RequestedSize');

  dynamic /* this will fail */ get data => getFieldOfObject('data', 0);
  void set data(dynamic value /* this will fail */) => setFieldOfObject('data', 0, value);
  int get minimumSize => getFieldOfObject('minimum_size', 1);
  void set minimumSize(int value) => setFieldOfObject('minimum_size', 1, value);
  int get naturalSize => getFieldOfObject('natural_size', 2);
  void set naturalSize(int value) => setFieldOfObject('natural_size', 2, value);
}

class Requisition extends GObjectBase {
  Requisition.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Requisition');

  int get width => getFieldOfObject('width', 0);
  void set width(int value) => setFieldOfObject('width', 0, value);
  int get height => getFieldOfObject('height', 1);
  void set height(int value) => setFieldOfObject('height', 1, value);
  factory Requisition() => _staticInfo.callStatic('new', []);
  Requisition copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void free() => _staticInfo.callMethodOnReceiver('free', this, []);
}

class ResizeMode extends GEnumBase {
  const ResizeMode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ResizeMode');

  static const ResizeMode PARENT = const ResizeMode(0);
  static const ResizeMode QUEUE = const ResizeMode(1);
  static const ResizeMode IMMEDIATE = const ResizeMode(2);
  String toString() {
    switch(index) {
      case 0: return 'ResizeMode.PARENT';
      case 1: return 'ResizeMode.QUEUE';
      case 2: return 'ResizeMode.IMMEDIATE';
      default: return 'new ResizeMode($index)';
    }
  }
}

class ResponseType extends GEnumBase {
  const ResponseType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ResponseType');

  static const ResponseType NONE = const ResponseType(-1);
  static const ResponseType REJECT = const ResponseType(-2);
  static const ResponseType ACCEPT = const ResponseType(-3);
  static const ResponseType DELETE_EVENT = const ResponseType(-4);
  static const ResponseType OK = const ResponseType(-5);
  static const ResponseType CANCEL = const ResponseType(-6);
  static const ResponseType CLOSE = const ResponseType(-7);
  static const ResponseType YES = const ResponseType(-8);
  static const ResponseType NO = const ResponseType(-9);
  static const ResponseType APPLY = const ResponseType(-10);
  static const ResponseType HELP = const ResponseType(-11);
  String toString() {
    switch(index) {
      case -1: return 'ResponseType.NONE';
      case -2: return 'ResponseType.REJECT';
      case -3: return 'ResponseType.ACCEPT';
      case -4: return 'ResponseType.DELETE_EVENT';
      case -5: return 'ResponseType.OK';
      case -6: return 'ResponseType.CANCEL';
      case -7: return 'ResponseType.CLOSE';
      case -8: return 'ResponseType.YES';
      case -9: return 'ResponseType.NO';
      case -10: return 'ResponseType.APPLY';
      case -11: return 'ResponseType.HELP';
      default: return 'new ResponseType($index)';
    }
  }
}

class Revealer extends Bin with ImplementorIface, Buildable {
  Revealer.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Revealer');

  static const String CHILD_REVEALED_PROPERTY = 'child-revealed';
  static const String REVEAL_CHILD_PROPERTY = 'reveal-child';
  static const String TRANSITION_DURATION_PROPERTY = 'transition-duration';
  static const String TRANSITION_TYPE_PROPERTY = 'transition-type';
  factory Revealer() => _staticInfo.callStatic('new', []);
  bool get childRevealed => _staticInfo.callMethodOnReceiver('get_child_revealed', this, []);
  bool get revealChild => _staticInfo.callMethodOnReceiver('get_reveal_child', this, []);
  int get transitionDuration => _staticInfo.callMethodOnReceiver('get_transition_duration', this, []);
  RevealerTransitionType get transitionType => _staticInfo.callMethodOnReceiver('get_transition_type', this, []);
  void set revealChild(bool revealChild) => _staticInfo.callMethodOnReceiver('set_reveal_child', this, [revealChild]);
  void set transitionDuration(int duration) => _staticInfo.callMethodOnReceiver('set_transition_duration', this, [duration]);
  void set transitionType(RevealerTransitionType transition) => _staticInfo.callMethodOnReceiver('set_transition_type', this, [transition]);
}

class RevealerTransitionType extends GEnumBase {
  const RevealerTransitionType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'RevealerTransitionType');

  static const RevealerTransitionType NONE = const RevealerTransitionType(0);
  static const RevealerTransitionType CROSSFADE = const RevealerTransitionType(1);
  static const RevealerTransitionType SLIDE_RIGHT = const RevealerTransitionType(2);
  static const RevealerTransitionType SLIDE_LEFT = const RevealerTransitionType(3);
  static const RevealerTransitionType SLIDE_UP = const RevealerTransitionType(4);
  static const RevealerTransitionType SLIDE_DOWN = const RevealerTransitionType(5);
  String toString() {
    switch(index) {
      case 0: return 'RevealerTransitionType.NONE';
      case 1: return 'RevealerTransitionType.CROSSFADE';
      case 2: return 'RevealerTransitionType.SLIDE_RIGHT';
      case 3: return 'RevealerTransitionType.SLIDE_LEFT';
      case 4: return 'RevealerTransitionType.SLIDE_UP';
      case 5: return 'RevealerTransitionType.SLIDE_DOWN';
      default: return 'new RevealerTransitionType($index)';
    }
  }
}

class Scale extends Range with ImplementorIface, Buildable, Orientable {
  Scale.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Scale');

  static const String DIGITS_PROPERTY = 'digits';
  static const String DRAW_VALUE_PROPERTY = 'draw-value';
  static const String HAS_ORIGIN_PROPERTY = 'has-origin';
  static const String VALUE_POS_PROPERTY = 'value-pos';
  factory Scale(Orientation orientation, Adjustment adjustment) => _staticInfo.callStatic('new', [orientation, adjustment]);
  factory Scale.withRange(Orientation orientation, num min, num max, num step) => _staticInfo.callStatic('new_with_range', [orientation, min, max, step]);
  void addMark(num value, PositionType position, String markup) => _staticInfo.callMethodOnReceiver('add_mark', this, [value, position, markup]);
  void clearMarks() => _staticInfo.callMethodOnReceiver('clear_marks', this, []);
  int get digits => _staticInfo.callMethodOnReceiver('get_digits', this, []);
  bool get drawValue => _staticInfo.callMethodOnReceiver('get_draw_value', this, []);
  bool get hasOrigin => _staticInfo.callMethodOnReceiver('get_has_origin', this, []);
  pango.Layout getLayout() => _staticInfo.callMethodOnReceiver('get_layout', this, []);
  void getLayoutOffsets() => _staticInfo.callMethodOnReceiver('get_layout_offsets', this, []);
  PositionType get valuePos => _staticInfo.callMethodOnReceiver('get_value_pos', this, []);
  void set digits(int digits) => _staticInfo.callMethodOnReceiver('set_digits', this, [digits]);
  void set drawValue(bool drawValue) => _staticInfo.callMethodOnReceiver('set_draw_value', this, [drawValue]);
  void set hasOrigin(bool hasOrigin) => _staticInfo.callMethodOnReceiver('set_has_origin', this, [hasOrigin]);
  void set valuePos(PositionType pos) => _staticInfo.callMethodOnReceiver('set_value_pos', this, [pos]);
  int connectToFormatValue(bool after, String func(num value)) => signalConnect('format-value', func, after);
}

class ScaleAccessible extends RangeAccessible with Component, atk.Value {
  ScaleAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ScaleAccessible');

}

class ScaleButton extends Button with ImplementorIface, Actionable, Activatable, Buildable, Orientable {
  ScaleButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ScaleButton');

  static const String ADJUSTMENT_PROPERTY = 'adjustment';
  List<String> get icons => _staticInfo.getGPropertyOnReceiver('icons', this);
  static const String ICONS_PROPERTY = 'icons';
  IconSize get size => _staticInfo.getGPropertyOnReceiver('size', this);
  void set size(IconSize value) => _staticInfo.setGPropertyOnReceiver('size', this, value);
  static const String SIZE_PROPERTY = 'size';
  static const String VALUE_PROPERTY = 'value';
  factory ScaleButton(int size, num min, num max, num step, List<String> icons) => _staticInfo.callStatic('new', [size, min, max, step, icons]);
  Adjustment get adjustment => _staticInfo.callMethodOnReceiver('get_adjustment', this, []);
  Button getMinusButton() => _staticInfo.callMethodOnReceiver('get_minus_button', this, []);
  Button getPlusButton() => _staticInfo.callMethodOnReceiver('get_plus_button', this, []);
  Widget getPopup() => _staticInfo.callMethodOnReceiver('get_popup', this, []);
  num get value => _staticInfo.callMethodOnReceiver('get_value', this, []);
  void set adjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_adjustment', this, [adjustment]);
  void set icons_(List<String> icons) => _staticInfo.callMethodOnReceiver('set_icons', this, [icons]);
  void set value(num value) => _staticInfo.callMethodOnReceiver('set_value', this, [value]);
  int _connectToPopdown(bool after, void func()) => signalConnect('popdown', func, after);
  Stream get onPopdown {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPopdown(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPopdown {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPopdown(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPopup(bool after, void func()) => signalConnect('popup', func, after);
  Stream get onPopup {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPopup(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPopup {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPopup(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToValueChanged(bool after, void func(num value)) => signalConnect('value-changed', func, after);
  Stream<num> get onValueChanged {
    int signalId;
    StreamController<num> controller;
    controller = new StreamController<num>(
      onListen: () {
          signalId = _connectToValueChanged(false, (num value) {
              controller.add(value);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<num> get afterValueChanged {
    int signalId;
    StreamController<num> controller;
    controller = new StreamController<num>(
      onListen: () {
          signalId = _connectToValueChanged(true, (num value) {
              controller.add(value);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ScaleButtonAccessible extends ButtonAccessible with atk.Action, Component, atk.Image, atk.Value {
  ScaleButtonAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ScaleButtonAccessible');

}

class ScrollStep extends GEnumBase {
  const ScrollStep(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ScrollStep');

  static const ScrollStep STEPS = const ScrollStep(0);
  static const ScrollStep PAGES = const ScrollStep(1);
  static const ScrollStep ENDS = const ScrollStep(2);
  static const ScrollStep HORIZONTAL_STEPS = const ScrollStep(3);
  static const ScrollStep HORIZONTAL_PAGES = const ScrollStep(4);
  static const ScrollStep HORIZONTAL_ENDS = const ScrollStep(5);
  String toString() {
    switch(index) {
      case 0: return 'ScrollStep.STEPS';
      case 1: return 'ScrollStep.PAGES';
      case 2: return 'ScrollStep.ENDS';
      case 3: return 'ScrollStep.HORIZONTAL_STEPS';
      case 4: return 'ScrollStep.HORIZONTAL_PAGES';
      case 5: return 'ScrollStep.HORIZONTAL_ENDS';
      default: return 'new ScrollStep($index)';
    }
  }
}

class ScrollType extends GEnumBase {
  const ScrollType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ScrollType');

  static const ScrollType NONE = const ScrollType(0);
  static const ScrollType JUMP = const ScrollType(1);
  static const ScrollType STEP_BACKWARD = const ScrollType(2);
  static const ScrollType STEP_FORWARD = const ScrollType(3);
  static const ScrollType PAGE_BACKWARD = const ScrollType(4);
  static const ScrollType PAGE_FORWARD = const ScrollType(5);
  static const ScrollType STEP_UP = const ScrollType(6);
  static const ScrollType STEP_DOWN = const ScrollType(7);
  static const ScrollType PAGE_UP = const ScrollType(8);
  static const ScrollType PAGE_DOWN = const ScrollType(9);
  static const ScrollType STEP_LEFT = const ScrollType(10);
  static const ScrollType STEP_RIGHT = const ScrollType(11);
  static const ScrollType PAGE_LEFT = const ScrollType(12);
  static const ScrollType PAGE_RIGHT = const ScrollType(13);
  static const ScrollType START = const ScrollType(14);
  static const ScrollType END = const ScrollType(15);
  String toString() {
    switch(index) {
      case 0: return 'ScrollType.NONE';
      case 1: return 'ScrollType.JUMP';
      case 2: return 'ScrollType.STEP_BACKWARD';
      case 3: return 'ScrollType.STEP_FORWARD';
      case 4: return 'ScrollType.PAGE_BACKWARD';
      case 5: return 'ScrollType.PAGE_FORWARD';
      case 6: return 'ScrollType.STEP_UP';
      case 7: return 'ScrollType.STEP_DOWN';
      case 8: return 'ScrollType.PAGE_UP';
      case 9: return 'ScrollType.PAGE_DOWN';
      case 10: return 'ScrollType.STEP_LEFT';
      case 11: return 'ScrollType.STEP_RIGHT';
      case 12: return 'ScrollType.PAGE_LEFT';
      case 13: return 'ScrollType.PAGE_RIGHT';
      case 14: return 'ScrollType.START';
      case 15: return 'ScrollType.END';
      default: return 'new ScrollType($index)';
    }
  }
}

abstract class Scrollable extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Scrollable');



  static const String HADJUSTMENT_PROPERTY = 'hadjustment';
  static const String HSCROLL_POLICY_PROPERTY = 'hscroll-policy';
  static const String VADJUSTMENT_PROPERTY = 'vadjustment';
  static const String VSCROLL_POLICY_PROPERTY = 'vscroll-policy';
  bool getBorder(Border border) => _staticInfo.callMethodOnReceiver('get_border', this, [border]);
  Adjustment get hadjustment => _staticInfo.callMethodOnReceiver('get_hadjustment', this, []);
  ScrollablePolicy get hscrollPolicy => _staticInfo.callMethodOnReceiver('get_hscroll_policy', this, []);
  Adjustment get vadjustment => _staticInfo.callMethodOnReceiver('get_vadjustment', this, []);
  ScrollablePolicy get vscrollPolicy => _staticInfo.callMethodOnReceiver('get_vscroll_policy', this, []);
  void set hadjustment(Adjustment hadjustment) => _staticInfo.callMethodOnReceiver('set_hadjustment', this, [hadjustment]);
  void set hscrollPolicy(ScrollablePolicy policy) => _staticInfo.callMethodOnReceiver('set_hscroll_policy', this, [policy]);
  void set vadjustment(Adjustment vadjustment) => _staticInfo.callMethodOnReceiver('set_vadjustment', this, [vadjustment]);
  void set vscrollPolicy(ScrollablePolicy policy) => _staticInfo.callMethodOnReceiver('set_vscroll_policy', this, [policy]);
}

class ScrollablePolicy extends GEnumBase {
  const ScrollablePolicy(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ScrollablePolicy');

  static const ScrollablePolicy MINIMUM = const ScrollablePolicy(0);
  static const ScrollablePolicy NATURAL = const ScrollablePolicy(1);
  String toString() {
    switch(index) {
      case 0: return 'ScrollablePolicy.MINIMUM';
      case 1: return 'ScrollablePolicy.NATURAL';
      default: return 'new ScrollablePolicy($index)';
    }
  }
}

class Scrollbar extends Range with ImplementorIface, Buildable, Orientable {
  Scrollbar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Scrollbar');

  factory Scrollbar(Orientation orientation, Adjustment adjustment) => _staticInfo.callStatic('new', [orientation, adjustment]);
}

class ScrolledWindow extends Bin with ImplementorIface, Buildable {
  ScrolledWindow.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ScrolledWindow');

  static const String HADJUSTMENT_PROPERTY = 'hadjustment';
  PolicyType get hscrollbarPolicy => _staticInfo.getGPropertyOnReceiver('hscrollbar-policy', this);
  void set hscrollbarPolicy(PolicyType value) => _staticInfo.setGPropertyOnReceiver('hscrollbar-policy', this, value);
  static const String HSCROLLBAR_POLICY_PROPERTY = 'hscrollbar-policy';
  static const String KINETIC_SCROLLING_PROPERTY = 'kinetic-scrolling';
  static const String MIN_CONTENT_HEIGHT_PROPERTY = 'min-content-height';
  static const String MIN_CONTENT_WIDTH_PROPERTY = 'min-content-width';
  static const String OVERLAY_SCROLLING_PROPERTY = 'overlay-scrolling';
  static const String SHADOW_TYPE_PROPERTY = 'shadow-type';
  static const String VADJUSTMENT_PROPERTY = 'vadjustment';
  PolicyType get vscrollbarPolicy => _staticInfo.getGPropertyOnReceiver('vscrollbar-policy', this);
  void set vscrollbarPolicy(PolicyType value) => _staticInfo.setGPropertyOnReceiver('vscrollbar-policy', this, value);
  static const String VSCROLLBAR_POLICY_PROPERTY = 'vscrollbar-policy';
  CornerType get windowPlacement => _staticInfo.getGPropertyOnReceiver('window-placement', this);
  void set windowPlacement(CornerType value) => _staticInfo.setGPropertyOnReceiver('window-placement', this, value);
  static const String WINDOW_PLACEMENT_PROPERTY = 'window-placement';
  bool get windowPlacementSet => _staticInfo.getGPropertyOnReceiver('window-placement-set', this);
  void set windowPlacementSet(bool value) => _staticInfo.setGPropertyOnReceiver('window-placement-set', this, value);
  static const String WINDOW_PLACEMENT_SET_PROPERTY = 'window-placement-set';
  factory ScrolledWindow(Adjustment hadjustment, Adjustment vadjustment) => _staticInfo.callStatic('new', [hadjustment, vadjustment]);
  void addWithViewport(Widget child) => _staticInfo.callMethodOnReceiver('add_with_viewport', this, [child]);
  bool getCaptureButtonPress() => _staticInfo.callMethodOnReceiver('get_capture_button_press', this, []);
  Adjustment get hadjustment => _staticInfo.callMethodOnReceiver('get_hadjustment', this, []);
  Widget getHscrollbar() => _staticInfo.callMethodOnReceiver('get_hscrollbar', this, []);
  bool get kineticScrolling => _staticInfo.callMethodOnReceiver('get_kinetic_scrolling', this, []);
  int get minContentHeight => _staticInfo.callMethodOnReceiver('get_min_content_height', this, []);
  int get minContentWidth => _staticInfo.callMethodOnReceiver('get_min_content_width', this, []);
  bool get overlayScrolling => _staticInfo.callMethodOnReceiver('get_overlay_scrolling', this, []);
  CornerType getPlacement() => _staticInfo.callMethodOnReceiver('get_placement', this, []);
  void getPolicy() => _staticInfo.callMethodOnReceiver('get_policy', this, []);
  ShadowType get shadowType => _staticInfo.callMethodOnReceiver('get_shadow_type', this, []);
  Adjustment get vadjustment => _staticInfo.callMethodOnReceiver('get_vadjustment', this, []);
  Widget getVscrollbar() => _staticInfo.callMethodOnReceiver('get_vscrollbar', this, []);
  void setCaptureButtonPress(bool captureButtonPress) => _staticInfo.callMethodOnReceiver('set_capture_button_press', this, [captureButtonPress]);
  void set hadjustment(Adjustment hadjustment) => _staticInfo.callMethodOnReceiver('set_hadjustment', this, [hadjustment]);
  void set kineticScrolling(bool kineticScrolling) => _staticInfo.callMethodOnReceiver('set_kinetic_scrolling', this, [kineticScrolling]);
  void set minContentHeight(int height) => _staticInfo.callMethodOnReceiver('set_min_content_height', this, [height]);
  void set minContentWidth(int width) => _staticInfo.callMethodOnReceiver('set_min_content_width', this, [width]);
  void set overlayScrolling(bool overlayScrolling) => _staticInfo.callMethodOnReceiver('set_overlay_scrolling', this, [overlayScrolling]);
  void setPlacement(CornerType windowPlacement) => _staticInfo.callMethodOnReceiver('set_placement', this, [windowPlacement]);
  void setPolicy(PolicyType hscrollbarPolicy, PolicyType vscrollbarPolicy) => _staticInfo.callMethodOnReceiver('set_policy', this, [hscrollbarPolicy, vscrollbarPolicy]);
  void set shadowType(ShadowType type) => _staticInfo.callMethodOnReceiver('set_shadow_type', this, [type]);
  void set vadjustment(Adjustment vadjustment) => _staticInfo.callMethodOnReceiver('set_vadjustment', this, [vadjustment]);
  void unsetPlacement() => _staticInfo.callMethodOnReceiver('unset_placement', this, []);
  int _connectToEdgeOvershot(bool after, void func(PositionType pos)) => signalConnect('edge-overshot', func, after);
  Stream<PositionType> get onEdgeOvershot {
    int signalId;
    StreamController<PositionType> controller;
    controller = new StreamController<PositionType>(
      onListen: () {
          signalId = _connectToEdgeOvershot(false, (PositionType pos) {
              controller.add(pos);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PositionType> get afterEdgeOvershot {
    int signalId;
    StreamController<PositionType> controller;
    controller = new StreamController<PositionType>(
      onListen: () {
          signalId = _connectToEdgeOvershot(true, (PositionType pos) {
              controller.add(pos);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToEdgeReached(bool after, void func(PositionType pos)) => signalConnect('edge-reached', func, after);
  Stream<PositionType> get onEdgeReached {
    int signalId;
    StreamController<PositionType> controller;
    controller = new StreamController<PositionType>(
      onListen: () {
          signalId = _connectToEdgeReached(false, (PositionType pos) {
              controller.add(pos);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<PositionType> get afterEdgeReached {
    int signalId;
    StreamController<PositionType> controller;
    controller = new StreamController<PositionType>(
      onListen: () {
          signalId = _connectToEdgeReached(true, (PositionType pos) {
              controller.add(pos);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveFocusOut(bool after, void func(DirectionType directionType)) => signalConnect('move-focus-out', func, after);
  Stream<DirectionType> get onMoveFocusOut {
    int signalId;
    StreamController<DirectionType> controller;
    controller = new StreamController<DirectionType>(
      onListen: () {
          signalId = _connectToMoveFocusOut(false, (DirectionType directionType) {
              controller.add(directionType);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<DirectionType> get afterMoveFocusOut {
    int signalId;
    StreamController<DirectionType> controller;
    controller = new StreamController<DirectionType>(
      onListen: () {
          signalId = _connectToMoveFocusOut(true, (DirectionType directionType) {
              controller.add(directionType);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToScrollChild(bool after, bool func(ScrollType scroll, bool horizontal)) => signalConnect('scroll-child', func, after);
  Stream<ScrolledWindowScrollChildEvent> get onScrollChild {
    int signalId;
    StreamController<ScrolledWindowScrollChildEvent> controller;
    controller = new StreamController<ScrolledWindowScrollChildEvent>(
      onListen: () {
          signalId = _connectToScrollChild(false, (ScrollType scroll, bool horizontal) {
              var result = new ScrolledWindowScrollChildEvent(scroll, horizontal);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ScrolledWindowScrollChildEvent> get afterScrollChild {
    int signalId;
    StreamController<ScrolledWindowScrollChildEvent> controller;
    controller = new StreamController<ScrolledWindowScrollChildEvent>(
      onListen: () {
          signalId = _connectToScrollChild(true, (ScrollType scroll, bool horizontal) {
              var result = new ScrolledWindowScrollChildEvent(scroll, horizontal);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ScrolledWindowScrollChildEvent {
  final ScrollType scroll;
  final bool horizontal;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  ScrolledWindowScrollChildEvent(this.scroll, this.horizontal);
}

class ScrolledWindowAccessible extends ContainerAccessible with Component {
  ScrolledWindowAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ScrolledWindowAccessible');

}

class SearchBar extends Bin with ImplementorIface, Buildable {
  SearchBar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SearchBar');

  bool get searchModeEnabled => _staticInfo.getGPropertyOnReceiver('search-mode-enabled', this);
  void set searchModeEnabled(bool value) => _staticInfo.setGPropertyOnReceiver('search-mode-enabled', this, value);
  static const String SEARCH_MODE_ENABLED_PROPERTY = 'search-mode-enabled';
  static const String SHOW_CLOSE_BUTTON_PROPERTY = 'show-close-button';
  factory SearchBar() => _staticInfo.callStatic('new', []);
  void connectEntry(Entry entry) => _staticInfo.callMethodOnReceiver('connect_entry', this, [entry]);
  bool getSearchMode() => _staticInfo.callMethodOnReceiver('get_search_mode', this, []);
  bool get showCloseButton => _staticInfo.callMethodOnReceiver('get_show_close_button', this, []);
  bool handleEvent(Event event) => _staticInfo.callMethodOnReceiver('handle_event', this, [event]);
  void setSearchMode(bool searchMode) => _staticInfo.callMethodOnReceiver('set_search_mode', this, [searchMode]);
  void set showCloseButton(bool visible) => _staticInfo.callMethodOnReceiver('set_show_close_button', this, [visible]);
}

class SearchEntry extends Entry with ImplementorIface, Buildable, CellEditable, Editable {
  SearchEntry.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SearchEntry');

  factory SearchEntry() => _staticInfo.callStatic('new', []);
  bool handleEvent(Event event) => _staticInfo.callMethodOnReceiver('handle_event', this, [event]);
  int _connectToNextMatch(bool after, void func()) => signalConnect('next-match', func, after);
  Stream get onNextMatch {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToNextMatch(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterNextMatch {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToNextMatch(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPreviousMatch(bool after, void func()) => signalConnect('previous-match', func, after);
  Stream get onPreviousMatch {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPreviousMatch(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPreviousMatch {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPreviousMatch(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSearchChanged(bool after, void func()) => signalConnect('search-changed', func, after);
  Stream get onSearchChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSearchChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSearchChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSearchChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToStopSearch(bool after, void func()) => signalConnect('stop-search', func, after);
  Stream get onStopSearch {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToStopSearch(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterStopSearch {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToStopSearch(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class SelectionData extends GObjectBase {
  SelectionData.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SelectionData');

  SelectionData copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void free() => _staticInfo.callMethodOnReceiver('free', this, []);
  Atom getDataType() => _staticInfo.callMethodOnReceiver('get_data_type', this, []);
  List<int> getData() => _staticInfo.callMethodOnReceiver('get_data', this, []);
  Display getDisplay() => _staticInfo.callMethodOnReceiver('get_display', this, []);
  int getFormat() => _staticInfo.callMethodOnReceiver('get_format', this, []);
  int getLength() => _staticInfo.callMethodOnReceiver('get_length', this, []);
  Pixbuf getPixbuf() => _staticInfo.callMethodOnReceiver('get_pixbuf', this, []);
  Atom getSelection() => _staticInfo.callMethodOnReceiver('get_selection', this, []);
  Atom getTarget() => _staticInfo.callMethodOnReceiver('get_target', this, []);
  bool getTargets() => _staticInfo.callMethodOnReceiver('get_targets', this, []);
  String getText() => _staticInfo.callMethodOnReceiver('get_text', this, []);
  List<String> getUris() => _staticInfo.callMethodOnReceiver('get_uris', this, []);
  void set_(Atom type, int format, List<int> data) => _staticInfo.callMethodOnReceiver('set', this, [type, format, data]);
  bool setPixbuf(Pixbuf pixbuf) => _staticInfo.callMethodOnReceiver('set_pixbuf', this, [pixbuf]);
  bool setText(String str, int len) => _staticInfo.callMethodOnReceiver('set_text', this, [str, len]);
  bool setUris(List<String> uris) => _staticInfo.callMethodOnReceiver('set_uris', this, [uris]);
  bool targetsIncludeImage(bool writable) => _staticInfo.callMethodOnReceiver('targets_include_image', this, [writable]);
  bool targetsIncludeRichText(TextBuffer buffer) => _staticInfo.callMethodOnReceiver('targets_include_rich_text', this, [buffer]);
  bool targetsIncludeText() => _staticInfo.callMethodOnReceiver('targets_include_text', this, []);
  bool targetsIncludeUri() => _staticInfo.callMethodOnReceiver('targets_include_uri', this, []);
}

class SelectionMode extends GEnumBase {
  const SelectionMode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SelectionMode');

  static const SelectionMode NONE = const SelectionMode(0);
  static const SelectionMode SINGLE = const SelectionMode(1);
  static const SelectionMode BROWSE = const SelectionMode(2);
  static const SelectionMode MULTIPLE = const SelectionMode(3);
  String toString() {
    switch(index) {
      case 0: return 'SelectionMode.NONE';
      case 1: return 'SelectionMode.SINGLE';
      case 2: return 'SelectionMode.BROWSE';
      case 3: return 'SelectionMode.MULTIPLE';
      default: return 'new SelectionMode($index)';
    }
  }
}

class SensitivityType extends GEnumBase {
  const SensitivityType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SensitivityType');

  static const SensitivityType AUTO = const SensitivityType(0);
  static const SensitivityType ON = const SensitivityType(1);
  static const SensitivityType OFF = const SensitivityType(2);
  String toString() {
    switch(index) {
      case 0: return 'SensitivityType.AUTO';
      case 1: return 'SensitivityType.ON';
      case 2: return 'SensitivityType.OFF';
      default: return 'new SensitivityType($index)';
    }
  }
}

class Separator extends Widget with ImplementorIface, Buildable, Orientable {
  Separator.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Separator');

  factory Separator(Orientation orientation) => _staticInfo.callStatic('new', [orientation]);
}

class SeparatorMenuItem extends MenuItem with ImplementorIface, Actionable, Activatable, Buildable {
  SeparatorMenuItem.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SeparatorMenuItem');

  factory SeparatorMenuItem() => _staticInfo.callStatic('new', []);
}

class SeparatorToolItem extends ToolItem with ImplementorIface, Activatable, Buildable {
  SeparatorToolItem.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SeparatorToolItem');

  static const String DRAW_PROPERTY = 'draw';
  factory SeparatorToolItem() => _staticInfo.callStatic('new', []);
  bool get separatorToolItemDraw => _staticInfo.callMethodOnReceiver('get_draw', this, []);
  void set separatorToolItemDraw(bool draw) => _staticInfo.callMethodOnReceiver('set_draw', this, [draw]);
}

class Settings extends GObjectObject with StyleProvider {
  Settings.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Settings');

  HashTable get colorHash => _staticInfo.getGPropertyOnReceiver('color-hash', this);
  static const String COLOR_HASH_PROPERTY = 'color-hash';
  bool get gtkAlternativeButtonOrder => _staticInfo.getGPropertyOnReceiver('gtk-alternative-button-order', this);
  void set gtkAlternativeButtonOrder(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-alternative-button-order', this, value);
  static const String GTK_ALTERNATIVE_BUTTON_ORDER_PROPERTY = 'gtk-alternative-button-order';
  bool get gtkAlternativeSortArrows => _staticInfo.getGPropertyOnReceiver('gtk-alternative-sort-arrows', this);
  void set gtkAlternativeSortArrows(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-alternative-sort-arrows', this, value);
  static const String GTK_ALTERNATIVE_SORT_ARROWS_PROPERTY = 'gtk-alternative-sort-arrows';
  bool get gtkApplicationPreferDarkTheme => _staticInfo.getGPropertyOnReceiver('gtk-application-prefer-dark-theme', this);
  void set gtkApplicationPreferDarkTheme(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-application-prefer-dark-theme', this, value);
  static const String GTK_APPLICATION_PREFER_DARK_THEME_PROPERTY = 'gtk-application-prefer-dark-theme';
  bool get gtkAutoMnemonics => _staticInfo.getGPropertyOnReceiver('gtk-auto-mnemonics', this);
  void set gtkAutoMnemonics(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-auto-mnemonics', this, value);
  static const String GTK_AUTO_MNEMONICS_PROPERTY = 'gtk-auto-mnemonics';
  bool get gtkButtonImages => _staticInfo.getGPropertyOnReceiver('gtk-button-images', this);
  void set gtkButtonImages(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-button-images', this, value);
  static const String GTK_BUTTON_IMAGES_PROPERTY = 'gtk-button-images';
  bool get gtkCanChangeAccels => _staticInfo.getGPropertyOnReceiver('gtk-can-change-accels', this);
  void set gtkCanChangeAccels(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-can-change-accels', this, value);
  static const String GTK_CAN_CHANGE_ACCELS_PROPERTY = 'gtk-can-change-accels';
  String get gtkColorPalette => _staticInfo.getGPropertyOnReceiver('gtk-color-palette', this);
  void set gtkColorPalette(String value) => _staticInfo.setGPropertyOnReceiver('gtk-color-palette', this, value);
  static const String GTK_COLOR_PALETTE_PROPERTY = 'gtk-color-palette';
  String get gtkColorScheme => _staticInfo.getGPropertyOnReceiver('gtk-color-scheme', this);
  void set gtkColorScheme(String value) => _staticInfo.setGPropertyOnReceiver('gtk-color-scheme', this, value);
  static const String GTK_COLOR_SCHEME_PROPERTY = 'gtk-color-scheme';
  bool get gtkCursorBlink => _staticInfo.getGPropertyOnReceiver('gtk-cursor-blink', this);
  void set gtkCursorBlink(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-cursor-blink', this, value);
  static const String GTK_CURSOR_BLINK_PROPERTY = 'gtk-cursor-blink';
  int get gtkCursorBlinkTime => _staticInfo.getGPropertyOnReceiver('gtk-cursor-blink-time', this);
  void set gtkCursorBlinkTime(int value) => _staticInfo.setGPropertyOnReceiver('gtk-cursor-blink-time', this, value);
  static const String GTK_CURSOR_BLINK_TIME_PROPERTY = 'gtk-cursor-blink-time';
  int get gtkCursorBlinkTimeout => _staticInfo.getGPropertyOnReceiver('gtk-cursor-blink-timeout', this);
  void set gtkCursorBlinkTimeout(int value) => _staticInfo.setGPropertyOnReceiver('gtk-cursor-blink-timeout', this, value);
  static const String GTK_CURSOR_BLINK_TIMEOUT_PROPERTY = 'gtk-cursor-blink-timeout';
  String get gtkCursorThemeName => _staticInfo.getGPropertyOnReceiver('gtk-cursor-theme-name', this);
  void set gtkCursorThemeName(String value) => _staticInfo.setGPropertyOnReceiver('gtk-cursor-theme-name', this, value);
  static const String GTK_CURSOR_THEME_NAME_PROPERTY = 'gtk-cursor-theme-name';
  int get gtkCursorThemeSize => _staticInfo.getGPropertyOnReceiver('gtk-cursor-theme-size', this);
  void set gtkCursorThemeSize(int value) => _staticInfo.setGPropertyOnReceiver('gtk-cursor-theme-size', this, value);
  static const String GTK_CURSOR_THEME_SIZE_PROPERTY = 'gtk-cursor-theme-size';
  String get gtkDecorationLayout => _staticInfo.getGPropertyOnReceiver('gtk-decoration-layout', this);
  void set gtkDecorationLayout(String value) => _staticInfo.setGPropertyOnReceiver('gtk-decoration-layout', this, value);
  static const String GTK_DECORATION_LAYOUT_PROPERTY = 'gtk-decoration-layout';
  bool get gtkDialogsUseHeader => _staticInfo.getGPropertyOnReceiver('gtk-dialogs-use-header', this);
  void set gtkDialogsUseHeader(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-dialogs-use-header', this, value);
  static const String GTK_DIALOGS_USE_HEADER_PROPERTY = 'gtk-dialogs-use-header';
  int get gtkDndDragThreshold => _staticInfo.getGPropertyOnReceiver('gtk-dnd-drag-threshold', this);
  void set gtkDndDragThreshold(int value) => _staticInfo.setGPropertyOnReceiver('gtk-dnd-drag-threshold', this, value);
  static const String GTK_DND_DRAG_THRESHOLD_PROPERTY = 'gtk-dnd-drag-threshold';
  int get gtkDoubleClickDistance => _staticInfo.getGPropertyOnReceiver('gtk-double-click-distance', this);
  void set gtkDoubleClickDistance(int value) => _staticInfo.setGPropertyOnReceiver('gtk-double-click-distance', this, value);
  static const String GTK_DOUBLE_CLICK_DISTANCE_PROPERTY = 'gtk-double-click-distance';
  int get gtkDoubleClickTime => _staticInfo.getGPropertyOnReceiver('gtk-double-click-time', this);
  void set gtkDoubleClickTime(int value) => _staticInfo.setGPropertyOnReceiver('gtk-double-click-time', this, value);
  static const String GTK_DOUBLE_CLICK_TIME_PROPERTY = 'gtk-double-click-time';
  bool get gtkEnableAccels => _staticInfo.getGPropertyOnReceiver('gtk-enable-accels', this);
  void set gtkEnableAccels(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-enable-accels', this, value);
  static const String GTK_ENABLE_ACCELS_PROPERTY = 'gtk-enable-accels';
  bool get gtkEnableAnimations => _staticInfo.getGPropertyOnReceiver('gtk-enable-animations', this);
  void set gtkEnableAnimations(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-enable-animations', this, value);
  static const String GTK_ENABLE_ANIMATIONS_PROPERTY = 'gtk-enable-animations';
  bool get gtkEnableEventSounds => _staticInfo.getGPropertyOnReceiver('gtk-enable-event-sounds', this);
  void set gtkEnableEventSounds(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-enable-event-sounds', this, value);
  static const String GTK_ENABLE_EVENT_SOUNDS_PROPERTY = 'gtk-enable-event-sounds';
  bool get gtkEnableInputFeedbackSounds => _staticInfo.getGPropertyOnReceiver('gtk-enable-input-feedback-sounds', this);
  void set gtkEnableInputFeedbackSounds(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-enable-input-feedback-sounds', this, value);
  static const String GTK_ENABLE_INPUT_FEEDBACK_SOUNDS_PROPERTY = 'gtk-enable-input-feedback-sounds';
  bool get gtkEnableMnemonics => _staticInfo.getGPropertyOnReceiver('gtk-enable-mnemonics', this);
  void set gtkEnableMnemonics(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-enable-mnemonics', this, value);
  static const String GTK_ENABLE_MNEMONICS_PROPERTY = 'gtk-enable-mnemonics';
  bool get gtkEnablePrimaryPaste => _staticInfo.getGPropertyOnReceiver('gtk-enable-primary-paste', this);
  void set gtkEnablePrimaryPaste(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-enable-primary-paste', this, value);
  static const String GTK_ENABLE_PRIMARY_PASTE_PROPERTY = 'gtk-enable-primary-paste';
  bool get gtkEnableTooltips => _staticInfo.getGPropertyOnReceiver('gtk-enable-tooltips', this);
  void set gtkEnableTooltips(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-enable-tooltips', this, value);
  static const String GTK_ENABLE_TOOLTIPS_PROPERTY = 'gtk-enable-tooltips';
  int get gtkEntryPasswordHintTimeout => _staticInfo.getGPropertyOnReceiver('gtk-entry-password-hint-timeout', this);
  void set gtkEntryPasswordHintTimeout(int value) => _staticInfo.setGPropertyOnReceiver('gtk-entry-password-hint-timeout', this, value);
  static const String GTK_ENTRY_PASSWORD_HINT_TIMEOUT_PROPERTY = 'gtk-entry-password-hint-timeout';
  bool get gtkEntrySelectOnFocus => _staticInfo.getGPropertyOnReceiver('gtk-entry-select-on-focus', this);
  void set gtkEntrySelectOnFocus(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-entry-select-on-focus', this, value);
  static const String GTK_ENTRY_SELECT_ON_FOCUS_PROPERTY = 'gtk-entry-select-on-focus';
  bool get gtkErrorBell => _staticInfo.getGPropertyOnReceiver('gtk-error-bell', this);
  void set gtkErrorBell(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-error-bell', this, value);
  static const String GTK_ERROR_BELL_PROPERTY = 'gtk-error-bell';
  String get gtkFallbackIconTheme => _staticInfo.getGPropertyOnReceiver('gtk-fallback-icon-theme', this);
  void set gtkFallbackIconTheme(String value) => _staticInfo.setGPropertyOnReceiver('gtk-fallback-icon-theme', this, value);
  static const String GTK_FALLBACK_ICON_THEME_PROPERTY = 'gtk-fallback-icon-theme';
  String get gtkFileChooserBackend => _staticInfo.getGPropertyOnReceiver('gtk-file-chooser-backend', this);
  void set gtkFileChooserBackend(String value) => _staticInfo.setGPropertyOnReceiver('gtk-file-chooser-backend', this, value);
  static const String GTK_FILE_CHOOSER_BACKEND_PROPERTY = 'gtk-file-chooser-backend';
  String get gtkFontName => _staticInfo.getGPropertyOnReceiver('gtk-font-name', this);
  void set gtkFontName(String value) => _staticInfo.setGPropertyOnReceiver('gtk-font-name', this, value);
  static const String GTK_FONT_NAME_PROPERTY = 'gtk-font-name';
  int get gtkFontconfigTimestamp => _staticInfo.getGPropertyOnReceiver('gtk-fontconfig-timestamp', this);
  void set gtkFontconfigTimestamp(int value) => _staticInfo.setGPropertyOnReceiver('gtk-fontconfig-timestamp', this, value);
  static const String GTK_FONTCONFIG_TIMESTAMP_PROPERTY = 'gtk-fontconfig-timestamp';
  String get gtkIconSizes => _staticInfo.getGPropertyOnReceiver('gtk-icon-sizes', this);
  void set gtkIconSizes(String value) => _staticInfo.setGPropertyOnReceiver('gtk-icon-sizes', this, value);
  static const String GTK_ICON_SIZES_PROPERTY = 'gtk-icon-sizes';
  String get gtkIconThemeName => _staticInfo.getGPropertyOnReceiver('gtk-icon-theme-name', this);
  void set gtkIconThemeName(String value) => _staticInfo.setGPropertyOnReceiver('gtk-icon-theme-name', this, value);
  static const String GTK_ICON_THEME_NAME_PROPERTY = 'gtk-icon-theme-name';
  String get gtkImModule => _staticInfo.getGPropertyOnReceiver('gtk-im-module', this);
  void set gtkImModule(String value) => _staticInfo.setGPropertyOnReceiver('gtk-im-module', this, value);
  static const String GTK_IM_MODULE_PROPERTY = 'gtk-im-module';
  IMPreeditStyle get gtkImPreeditStyle => _staticInfo.getGPropertyOnReceiver('gtk-im-preedit-style', this);
  void set gtkImPreeditStyle(IMPreeditStyle value) => _staticInfo.setGPropertyOnReceiver('gtk-im-preedit-style', this, value);
  static const String GTK_IM_PREEDIT_STYLE_PROPERTY = 'gtk-im-preedit-style';
  IMStatusStyle get gtkImStatusStyle => _staticInfo.getGPropertyOnReceiver('gtk-im-status-style', this);
  void set gtkImStatusStyle(IMStatusStyle value) => _staticInfo.setGPropertyOnReceiver('gtk-im-status-style', this, value);
  static const String GTK_IM_STATUS_STYLE_PROPERTY = 'gtk-im-status-style';
  String get gtkKeyThemeName => _staticInfo.getGPropertyOnReceiver('gtk-key-theme-name', this);
  void set gtkKeyThemeName(String value) => _staticInfo.setGPropertyOnReceiver('gtk-key-theme-name', this, value);
  static const String GTK_KEY_THEME_NAME_PROPERTY = 'gtk-key-theme-name';
  bool get gtkKeynavCursorOnly => _staticInfo.getGPropertyOnReceiver('gtk-keynav-cursor-only', this);
  void set gtkKeynavCursorOnly(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-keynav-cursor-only', this, value);
  static const String GTK_KEYNAV_CURSOR_ONLY_PROPERTY = 'gtk-keynav-cursor-only';
  bool get gtkKeynavWrapAround => _staticInfo.getGPropertyOnReceiver('gtk-keynav-wrap-around', this);
  void set gtkKeynavWrapAround(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-keynav-wrap-around', this, value);
  static const String GTK_KEYNAV_WRAP_AROUND_PROPERTY = 'gtk-keynav-wrap-around';
  bool get gtkLabelSelectOnFocus => _staticInfo.getGPropertyOnReceiver('gtk-label-select-on-focus', this);
  void set gtkLabelSelectOnFocus(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-label-select-on-focus', this, value);
  static const String GTK_LABEL_SELECT_ON_FOCUS_PROPERTY = 'gtk-label-select-on-focus';
  int get gtkLongPressTime => _staticInfo.getGPropertyOnReceiver('gtk-long-press-time', this);
  void set gtkLongPressTime(int value) => _staticInfo.setGPropertyOnReceiver('gtk-long-press-time', this, value);
  static const String GTK_LONG_PRESS_TIME_PROPERTY = 'gtk-long-press-time';
  String get gtkMenuBarAccel => _staticInfo.getGPropertyOnReceiver('gtk-menu-bar-accel', this);
  void set gtkMenuBarAccel(String value) => _staticInfo.setGPropertyOnReceiver('gtk-menu-bar-accel', this, value);
  static const String GTK_MENU_BAR_ACCEL_PROPERTY = 'gtk-menu-bar-accel';
  int get gtkMenuBarPopupDelay => _staticInfo.getGPropertyOnReceiver('gtk-menu-bar-popup-delay', this);
  void set gtkMenuBarPopupDelay(int value) => _staticInfo.setGPropertyOnReceiver('gtk-menu-bar-popup-delay', this, value);
  static const String GTK_MENU_BAR_POPUP_DELAY_PROPERTY = 'gtk-menu-bar-popup-delay';
  bool get gtkMenuImages => _staticInfo.getGPropertyOnReceiver('gtk-menu-images', this);
  void set gtkMenuImages(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-menu-images', this, value);
  static const String GTK_MENU_IMAGES_PROPERTY = 'gtk-menu-images';
  int get gtkMenuPopdownDelay => _staticInfo.getGPropertyOnReceiver('gtk-menu-popdown-delay', this);
  void set gtkMenuPopdownDelay(int value) => _staticInfo.setGPropertyOnReceiver('gtk-menu-popdown-delay', this, value);
  static const String GTK_MENU_POPDOWN_DELAY_PROPERTY = 'gtk-menu-popdown-delay';
  int get gtkMenuPopupDelay => _staticInfo.getGPropertyOnReceiver('gtk-menu-popup-delay', this);
  void set gtkMenuPopupDelay(int value) => _staticInfo.setGPropertyOnReceiver('gtk-menu-popup-delay', this, value);
  static const String GTK_MENU_POPUP_DELAY_PROPERTY = 'gtk-menu-popup-delay';
  String get gtkModules => _staticInfo.getGPropertyOnReceiver('gtk-modules', this);
  void set gtkModules(String value) => _staticInfo.setGPropertyOnReceiver('gtk-modules', this, value);
  static const String GTK_MODULES_PROPERTY = 'gtk-modules';
  bool get gtkPrimaryButtonWarpsSlider => _staticInfo.getGPropertyOnReceiver('gtk-primary-button-warps-slider', this);
  void set gtkPrimaryButtonWarpsSlider(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-primary-button-warps-slider', this, value);
  static const String GTK_PRIMARY_BUTTON_WARPS_SLIDER_PROPERTY = 'gtk-primary-button-warps-slider';
  String get gtkPrintBackends => _staticInfo.getGPropertyOnReceiver('gtk-print-backends', this);
  void set gtkPrintBackends(String value) => _staticInfo.setGPropertyOnReceiver('gtk-print-backends', this, value);
  static const String GTK_PRINT_BACKENDS_PROPERTY = 'gtk-print-backends';
  String get gtkPrintPreviewCommand => _staticInfo.getGPropertyOnReceiver('gtk-print-preview-command', this);
  void set gtkPrintPreviewCommand(String value) => _staticInfo.setGPropertyOnReceiver('gtk-print-preview-command', this, value);
  static const String GTK_PRINT_PREVIEW_COMMAND_PROPERTY = 'gtk-print-preview-command';
  bool get gtkRecentFilesEnabled => _staticInfo.getGPropertyOnReceiver('gtk-recent-files-enabled', this);
  void set gtkRecentFilesEnabled(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-recent-files-enabled', this, value);
  static const String GTK_RECENT_FILES_ENABLED_PROPERTY = 'gtk-recent-files-enabled';
  int get gtkRecentFilesLimit => _staticInfo.getGPropertyOnReceiver('gtk-recent-files-limit', this);
  void set gtkRecentFilesLimit(int value) => _staticInfo.setGPropertyOnReceiver('gtk-recent-files-limit', this, value);
  static const String GTK_RECENT_FILES_LIMIT_PROPERTY = 'gtk-recent-files-limit';
  int get gtkRecentFilesMaxAge => _staticInfo.getGPropertyOnReceiver('gtk-recent-files-max-age', this);
  void set gtkRecentFilesMaxAge(int value) => _staticInfo.setGPropertyOnReceiver('gtk-recent-files-max-age', this, value);
  static const String GTK_RECENT_FILES_MAX_AGE_PROPERTY = 'gtk-recent-files-max-age';
  CornerType get gtkScrolledWindowPlacement => _staticInfo.getGPropertyOnReceiver('gtk-scrolled-window-placement', this);
  void set gtkScrolledWindowPlacement(CornerType value) => _staticInfo.setGPropertyOnReceiver('gtk-scrolled-window-placement', this, value);
  static const String GTK_SCROLLED_WINDOW_PLACEMENT_PROPERTY = 'gtk-scrolled-window-placement';
  bool get gtkShellShowsAppMenu => _staticInfo.getGPropertyOnReceiver('gtk-shell-shows-app-menu', this);
  void set gtkShellShowsAppMenu(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-shell-shows-app-menu', this, value);
  static const String GTK_SHELL_SHOWS_APP_MENU_PROPERTY = 'gtk-shell-shows-app-menu';
  bool get gtkShellShowsDesktop => _staticInfo.getGPropertyOnReceiver('gtk-shell-shows-desktop', this);
  void set gtkShellShowsDesktop(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-shell-shows-desktop', this, value);
  static const String GTK_SHELL_SHOWS_DESKTOP_PROPERTY = 'gtk-shell-shows-desktop';
  bool get gtkShellShowsMenubar => _staticInfo.getGPropertyOnReceiver('gtk-shell-shows-menubar', this);
  void set gtkShellShowsMenubar(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-shell-shows-menubar', this, value);
  static const String GTK_SHELL_SHOWS_MENUBAR_PROPERTY = 'gtk-shell-shows-menubar';
  bool get gtkShowInputMethodMenu => _staticInfo.getGPropertyOnReceiver('gtk-show-input-method-menu', this);
  void set gtkShowInputMethodMenu(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-show-input-method-menu', this, value);
  static const String GTK_SHOW_INPUT_METHOD_MENU_PROPERTY = 'gtk-show-input-method-menu';
  bool get gtkShowUnicodeMenu => _staticInfo.getGPropertyOnReceiver('gtk-show-unicode-menu', this);
  void set gtkShowUnicodeMenu(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-show-unicode-menu', this, value);
  static const String GTK_SHOW_UNICODE_MENU_PROPERTY = 'gtk-show-unicode-menu';
  String get gtkSoundThemeName => _staticInfo.getGPropertyOnReceiver('gtk-sound-theme-name', this);
  void set gtkSoundThemeName(String value) => _staticInfo.setGPropertyOnReceiver('gtk-sound-theme-name', this, value);
  static const String GTK_SOUND_THEME_NAME_PROPERTY = 'gtk-sound-theme-name';
  bool get gtkSplitCursor => _staticInfo.getGPropertyOnReceiver('gtk-split-cursor', this);
  void set gtkSplitCursor(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-split-cursor', this, value);
  static const String GTK_SPLIT_CURSOR_PROPERTY = 'gtk-split-cursor';
  String get gtkThemeName => _staticInfo.getGPropertyOnReceiver('gtk-theme-name', this);
  void set gtkThemeName(String value) => _staticInfo.setGPropertyOnReceiver('gtk-theme-name', this, value);
  static const String GTK_THEME_NAME_PROPERTY = 'gtk-theme-name';
  int get gtkTimeoutExpand => _staticInfo.getGPropertyOnReceiver('gtk-timeout-expand', this);
  void set gtkTimeoutExpand(int value) => _staticInfo.setGPropertyOnReceiver('gtk-timeout-expand', this, value);
  static const String GTK_TIMEOUT_EXPAND_PROPERTY = 'gtk-timeout-expand';
  int get gtkTimeoutInitial => _staticInfo.getGPropertyOnReceiver('gtk-timeout-initial', this);
  void set gtkTimeoutInitial(int value) => _staticInfo.setGPropertyOnReceiver('gtk-timeout-initial', this, value);
  static const String GTK_TIMEOUT_INITIAL_PROPERTY = 'gtk-timeout-initial';
  int get gtkTimeoutRepeat => _staticInfo.getGPropertyOnReceiver('gtk-timeout-repeat', this);
  void set gtkTimeoutRepeat(int value) => _staticInfo.setGPropertyOnReceiver('gtk-timeout-repeat', this, value);
  static const String GTK_TIMEOUT_REPEAT_PROPERTY = 'gtk-timeout-repeat';
  String get gtkTitlebarDoubleClick => _staticInfo.getGPropertyOnReceiver('gtk-titlebar-double-click', this);
  void set gtkTitlebarDoubleClick(String value) => _staticInfo.setGPropertyOnReceiver('gtk-titlebar-double-click', this, value);
  static const String GTK_TITLEBAR_DOUBLE_CLICK_PROPERTY = 'gtk-titlebar-double-click';
  String get gtkTitlebarMiddleClick => _staticInfo.getGPropertyOnReceiver('gtk-titlebar-middle-click', this);
  void set gtkTitlebarMiddleClick(String value) => _staticInfo.setGPropertyOnReceiver('gtk-titlebar-middle-click', this, value);
  static const String GTK_TITLEBAR_MIDDLE_CLICK_PROPERTY = 'gtk-titlebar-middle-click';
  String get gtkTitlebarRightClick => _staticInfo.getGPropertyOnReceiver('gtk-titlebar-right-click', this);
  void set gtkTitlebarRightClick(String value) => _staticInfo.setGPropertyOnReceiver('gtk-titlebar-right-click', this, value);
  static const String GTK_TITLEBAR_RIGHT_CLICK_PROPERTY = 'gtk-titlebar-right-click';
  IconSize get gtkToolbarIconSize => _staticInfo.getGPropertyOnReceiver('gtk-toolbar-icon-size', this);
  void set gtkToolbarIconSize(IconSize value) => _staticInfo.setGPropertyOnReceiver('gtk-toolbar-icon-size', this, value);
  static const String GTK_TOOLBAR_ICON_SIZE_PROPERTY = 'gtk-toolbar-icon-size';
  ToolbarStyle get gtkToolbarStyle => _staticInfo.getGPropertyOnReceiver('gtk-toolbar-style', this);
  void set gtkToolbarStyle(ToolbarStyle value) => _staticInfo.setGPropertyOnReceiver('gtk-toolbar-style', this, value);
  static const String GTK_TOOLBAR_STYLE_PROPERTY = 'gtk-toolbar-style';
  int get gtkTooltipBrowseModeTimeout => _staticInfo.getGPropertyOnReceiver('gtk-tooltip-browse-mode-timeout', this);
  void set gtkTooltipBrowseModeTimeout(int value) => _staticInfo.setGPropertyOnReceiver('gtk-tooltip-browse-mode-timeout', this, value);
  static const String GTK_TOOLTIP_BROWSE_MODE_TIMEOUT_PROPERTY = 'gtk-tooltip-browse-mode-timeout';
  int get gtkTooltipBrowseTimeout => _staticInfo.getGPropertyOnReceiver('gtk-tooltip-browse-timeout', this);
  void set gtkTooltipBrowseTimeout(int value) => _staticInfo.setGPropertyOnReceiver('gtk-tooltip-browse-timeout', this, value);
  static const String GTK_TOOLTIP_BROWSE_TIMEOUT_PROPERTY = 'gtk-tooltip-browse-timeout';
  int get gtkTooltipTimeout => _staticInfo.getGPropertyOnReceiver('gtk-tooltip-timeout', this);
  void set gtkTooltipTimeout(int value) => _staticInfo.setGPropertyOnReceiver('gtk-tooltip-timeout', this, value);
  static const String GTK_TOOLTIP_TIMEOUT_PROPERTY = 'gtk-tooltip-timeout';
  bool get gtkTouchscreenMode => _staticInfo.getGPropertyOnReceiver('gtk-touchscreen-mode', this);
  void set gtkTouchscreenMode(bool value) => _staticInfo.setGPropertyOnReceiver('gtk-touchscreen-mode', this, value);
  static const String GTK_TOUCHSCREEN_MODE_PROPERTY = 'gtk-touchscreen-mode';
  PolicyType get gtkVisibleFocus => _staticInfo.getGPropertyOnReceiver('gtk-visible-focus', this);
  void set gtkVisibleFocus(PolicyType value) => _staticInfo.setGPropertyOnReceiver('gtk-visible-focus', this, value);
  static const String GTK_VISIBLE_FOCUS_PROPERTY = 'gtk-visible-focus';
  int get gtkXftAntialias => _staticInfo.getGPropertyOnReceiver('gtk-xft-antialias', this);
  void set gtkXftAntialias(int value) => _staticInfo.setGPropertyOnReceiver('gtk-xft-antialias', this, value);
  static const String GTK_XFT_ANTIALIAS_PROPERTY = 'gtk-xft-antialias';
  int get gtkXftDpi => _staticInfo.getGPropertyOnReceiver('gtk-xft-dpi', this);
  void set gtkXftDpi(int value) => _staticInfo.setGPropertyOnReceiver('gtk-xft-dpi', this, value);
  static const String GTK_XFT_DPI_PROPERTY = 'gtk-xft-dpi';
  int get gtkXftHinting => _staticInfo.getGPropertyOnReceiver('gtk-xft-hinting', this);
  void set gtkXftHinting(int value) => _staticInfo.setGPropertyOnReceiver('gtk-xft-hinting', this, value);
  static const String GTK_XFT_HINTING_PROPERTY = 'gtk-xft-hinting';
  String get gtkXftHintstyle => _staticInfo.getGPropertyOnReceiver('gtk-xft-hintstyle', this);
  void set gtkXftHintstyle(String value) => _staticInfo.setGPropertyOnReceiver('gtk-xft-hintstyle', this, value);
  static const String GTK_XFT_HINTSTYLE_PROPERTY = 'gtk-xft-hintstyle';
  String get gtkXftRgba => _staticInfo.getGPropertyOnReceiver('gtk-xft-rgba', this);
  void set gtkXftRgba(String value) => _staticInfo.setGPropertyOnReceiver('gtk-xft-rgba', this, value);
  static const String GTK_XFT_RGBA_PROPERTY = 'gtk-xft-rgba';
  static Settings getDefault() => _staticInfo.callStatic('get_default', []);
  static Settings getForScreen(Screen screen) => _staticInfo.callStatic('get_for_screen', [screen]);
  static void installProperty(ParamSpec pspec) => _staticInfo.callStatic('install_property', [pspec]);
  static void installPropertyParser(ParamSpec pspec, RcPropertyParser parser) => _staticInfo.callStatic('install_property_parser', [pspec, parser]);
  void setDoubleProperty(String name, num vDouble, String origin) => _staticInfo.callMethodOnReceiver('set_double_property', this, [name, vDouble, origin]);
  void setLongProperty(String name, int vLong, String origin) => _staticInfo.callMethodOnReceiver('set_long_property', this, [name, vLong, origin]);
  void setPropertyValue(String name, SettingsValue svalue) => _staticInfo.callMethodOnReceiver('set_property_value', this, [name, svalue]);
  void setStringProperty(String name, String vString, String origin) => _staticInfo.callMethodOnReceiver('set_string_property', this, [name, vString, origin]);
}

class SettingsValue extends GObjectBase {
  SettingsValue.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SettingsValue');

  String get origin => getFieldOfObject('origin', 0);
  void set origin(String value) => setFieldOfObject('origin', 0, value);
  Value get value => getFieldOfObject('value', 1);
  void set value(Value value) => setFieldOfObject('value', 1, value);
}

class ShadowType extends GEnumBase {
  const ShadowType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ShadowType');

  static const ShadowType NONE = const ShadowType(0);
  static const ShadowType IN = const ShadowType(1);
  static const ShadowType OUT = const ShadowType(2);
  static const ShadowType ETCHED_IN = const ShadowType(3);
  static const ShadowType ETCHED_OUT = const ShadowType(4);
  String toString() {
    switch(index) {
      case 0: return 'ShadowType.NONE';
      case 1: return 'ShadowType.IN';
      case 2: return 'ShadowType.OUT';
      case 3: return 'ShadowType.ETCHED_IN';
      case 4: return 'ShadowType.ETCHED_OUT';
      default: return 'new ShadowType($index)';
    }
  }
}

class SizeGroup extends GObjectObject with Buildable {
  SizeGroup.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SizeGroup');

  static const String IGNORE_HIDDEN_PROPERTY = 'ignore-hidden';
  static const String MODE_PROPERTY = 'mode';
  factory SizeGroup(SizeGroupMode mode) => _staticInfo.callStatic('new', [mode]);
  void addWidget(Widget widget) => _staticInfo.callMethodOnReceiver('add_widget', this, [widget]);
  bool get ignoreHidden => _staticInfo.callMethodOnReceiver('get_ignore_hidden', this, []);
  SizeGroupMode get mode => _staticInfo.callMethodOnReceiver('get_mode', this, []);
  SList /* this will fail */ getWidgets() => _staticInfo.callMethodOnReceiver('get_widgets', this, []);
  void removeWidget(Widget widget) => _staticInfo.callMethodOnReceiver('remove_widget', this, [widget]);
  void set ignoreHidden(bool ignoreHidden) => _staticInfo.callMethodOnReceiver('set_ignore_hidden', this, [ignoreHidden]);
  void set mode(SizeGroupMode mode) => _staticInfo.callMethodOnReceiver('set_mode', this, [mode]);
}

class SizeGroupMode extends GEnumBase {
  const SizeGroupMode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SizeGroupMode');

  static const SizeGroupMode NONE = const SizeGroupMode(0);
  static const SizeGroupMode HORIZONTAL = const SizeGroupMode(1);
  static const SizeGroupMode VERTICAL = const SizeGroupMode(2);
  static const SizeGroupMode BOTH = const SizeGroupMode(3);
  String toString() {
    switch(index) {
      case 0: return 'SizeGroupMode.NONE';
      case 1: return 'SizeGroupMode.HORIZONTAL';
      case 2: return 'SizeGroupMode.VERTICAL';
      case 3: return 'SizeGroupMode.BOTH';
      default: return 'new SizeGroupMode($index)';
    }
  }
}

class SizeRequestMode extends GEnumBase {
  const SizeRequestMode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SizeRequestMode');

  static const SizeRequestMode HEIGHT_FOR_WIDTH = const SizeRequestMode(0);
  static const SizeRequestMode WIDTH_FOR_HEIGHT = const SizeRequestMode(1);
  static const SizeRequestMode CONSTANT_SIZE = const SizeRequestMode(2);
  String toString() {
    switch(index) {
      case 0: return 'SizeRequestMode.HEIGHT_FOR_WIDTH';
      case 1: return 'SizeRequestMode.WIDTH_FOR_HEIGHT';
      case 2: return 'SizeRequestMode.CONSTANT_SIZE';
      default: return 'new SizeRequestMode($index)';
    }
  }
}

class Socket extends Container with ImplementorIface, Buildable {
  Socket.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Socket');

  factory Socket() => _staticInfo.callStatic('new', []);
  void addId(int window) => _staticInfo.callMethodOnReceiver('add_id', this, [window]);
  int getId() => _staticInfo.callMethodOnReceiver('get_id', this, []);
  gdk.Window getPlugWindow() => _staticInfo.callMethodOnReceiver('get_plug_window', this, []);
  int _connectToPlugAdded(bool after, void func()) => signalConnect('plug-added', func, after);
  Stream get onPlugAdded {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPlugAdded(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPlugAdded {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPlugAdded(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPlugRemoved(bool after, bool func()) => signalConnect('plug-removed', func, after);
  Stream<SocketPlugRemovedEvent> get onPlugRemoved {
    int signalId;
    StreamController<SocketPlugRemovedEvent> controller;
    controller = new StreamController<SocketPlugRemovedEvent>(
      onListen: () {
          signalId = _connectToPlugRemoved(false, () {
              var result = new SocketPlugRemovedEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<SocketPlugRemovedEvent> get afterPlugRemoved {
    int signalId;
    StreamController<SocketPlugRemovedEvent> controller;
    controller = new StreamController<SocketPlugRemovedEvent>(
      onListen: () {
          signalId = _connectToPlugRemoved(true, () {
              var result = new SocketPlugRemovedEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class SocketPlugRemovedEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  SocketPlugRemovedEvent();
}

class SortType extends GEnumBase {
  const SortType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SortType');

  static const SortType ASCENDING = const SortType(0);
  static const SortType DESCENDING = const SortType(1);
  String toString() {
    switch(index) {
      case 0: return 'SortType.ASCENDING';
      case 1: return 'SortType.DESCENDING';
      default: return 'new SortType($index)';
    }
  }
}

class SpinButton extends Entry with ImplementorIface, Buildable, CellEditable, Editable, Orientable {
  SpinButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SpinButton');

  static const String ADJUSTMENT_PROPERTY = 'adjustment';
  num get climbRate => _staticInfo.getGPropertyOnReceiver('climb-rate', this);
  void set climbRate(num value) => _staticInfo.setGPropertyOnReceiver('climb-rate', this, value);
  static const String CLIMB_RATE_PROPERTY = 'climb-rate';
  static const String DIGITS_PROPERTY = 'digits';
  static const String NUMERIC_PROPERTY = 'numeric';
  static const String SNAP_TO_TICKS_PROPERTY = 'snap-to-ticks';
  static const String UPDATE_POLICY_PROPERTY = 'update-policy';
  static const String VALUE_PROPERTY = 'value';
  static const String WRAP_PROPERTY = 'wrap';
  factory SpinButton(Adjustment adjustment, num climbRate, int digits) => _staticInfo.callStatic('new', [adjustment, climbRate, digits]);
  factory SpinButton.withRange(num min, num max, num step) => _staticInfo.callStatic('new_with_range', [min, max, step]);
  void configure(Adjustment adjustment, num climbRate, int digits) => _staticInfo.callMethodOnReceiver('configure', this, [adjustment, climbRate, digits]);
  Adjustment get adjustment => _staticInfo.callMethodOnReceiver('get_adjustment', this, []);
  int get digits => _staticInfo.callMethodOnReceiver('get_digits', this, []);
  void getIncrements() => _staticInfo.callMethodOnReceiver('get_increments', this, []);
  bool get numeric => _staticInfo.callMethodOnReceiver('get_numeric', this, []);
  void getRange() => _staticInfo.callMethodOnReceiver('get_range', this, []);
  bool get snapToTicks => _staticInfo.callMethodOnReceiver('get_snap_to_ticks', this, []);
  SpinButtonUpdatePolicy get updatePolicy => _staticInfo.callMethodOnReceiver('get_update_policy', this, []);
  num get value => _staticInfo.callMethodOnReceiver('get_value', this, []);
  int getValueAsInt() => _staticInfo.callMethodOnReceiver('get_value_as_int', this, []);
  bool get wrap => _staticInfo.callMethodOnReceiver('get_wrap', this, []);
  void set adjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_adjustment', this, [adjustment]);
  void set digits(int digits) => _staticInfo.callMethodOnReceiver('set_digits', this, [digits]);
  void setIncrements(num step, num page) => _staticInfo.callMethodOnReceiver('set_increments', this, [step, page]);
  void set numeric(bool numeric) => _staticInfo.callMethodOnReceiver('set_numeric', this, [numeric]);
  void setRange(num min, num max) => _staticInfo.callMethodOnReceiver('set_range', this, [min, max]);
  void set snapToTicks(bool snapToTicks) => _staticInfo.callMethodOnReceiver('set_snap_to_ticks', this, [snapToTicks]);
  void set updatePolicy(SpinButtonUpdatePolicy policy) => _staticInfo.callMethodOnReceiver('set_update_policy', this, [policy]);
  void set value(num value) => _staticInfo.callMethodOnReceiver('set_value', this, [value]);
  void set wrap(bool wrap) => _staticInfo.callMethodOnReceiver('set_wrap', this, [wrap]);
  void spin(SpinType direction, num increment) => _staticInfo.callMethodOnReceiver('spin', this, [direction, increment]);
  void update() => _staticInfo.callMethodOnReceiver('update', this, []);
  int _connectToChangeValue(bool after, void func(ScrollType scroll)) => signalConnect('change-value', func, after);
  Stream<ScrollType> get onChangeValue {
    int signalId;
    StreamController<ScrollType> controller;
    controller = new StreamController<ScrollType>(
      onListen: () {
          signalId = _connectToChangeValue(false, (ScrollType scroll) {
              controller.add(scroll);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ScrollType> get afterChangeValue {
    int signalId;
    StreamController<ScrollType> controller;
    controller = new StreamController<ScrollType>(
      onListen: () {
          signalId = _connectToChangeValue(true, (ScrollType scroll) {
              controller.add(scroll);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int connectToInput(bool after, List func()) => signalConnect('input', func, after);
  int _connectToOutput(bool after, bool func()) => signalConnect('output', func, after);
  Stream<SpinButtonOutputEvent> get onOutput {
    int signalId;
    StreamController<SpinButtonOutputEvent> controller;
    controller = new StreamController<SpinButtonOutputEvent>(
      onListen: () {
          signalId = _connectToOutput(false, () {
              var result = new SpinButtonOutputEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<SpinButtonOutputEvent> get afterOutput {
    int signalId;
    StreamController<SpinButtonOutputEvent> controller;
    controller = new StreamController<SpinButtonOutputEvent>(
      onListen: () {
          signalId = _connectToOutput(true, () {
              var result = new SpinButtonOutputEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToValueChanged(bool after, void func()) => signalConnect('value-changed', func, after);
  Stream get onValueChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToValueChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterValueChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToValueChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToWrapped(bool after, void func()) => signalConnect('wrapped', func, after);
  Stream get onWrapped {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToWrapped(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterWrapped {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToWrapped(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class SpinButtonOutputEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  SpinButtonOutputEvent();
}

class SpinButtonAccessible extends EntryAccessible with atk.Action, Component, EditableText, Text, atk.Value {
  SpinButtonAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SpinButtonAccessible');

}

class SpinButtonUpdatePolicy extends GEnumBase {
  const SpinButtonUpdatePolicy(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SpinButtonUpdatePolicy');

  static const SpinButtonUpdatePolicy ALWAYS = const SpinButtonUpdatePolicy(0);
  static const SpinButtonUpdatePolicy IF_VALID = const SpinButtonUpdatePolicy(1);
  String toString() {
    switch(index) {
      case 0: return 'SpinButtonUpdatePolicy.ALWAYS';
      case 1: return 'SpinButtonUpdatePolicy.IF_VALID';
      default: return 'new SpinButtonUpdatePolicy($index)';
    }
  }
}

class SpinType extends GEnumBase {
  const SpinType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SpinType');

  static const SpinType STEP_FORWARD = const SpinType(0);
  static const SpinType STEP_BACKWARD = const SpinType(1);
  static const SpinType PAGE_FORWARD = const SpinType(2);
  static const SpinType PAGE_BACKWARD = const SpinType(3);
  static const SpinType HOME = const SpinType(4);
  static const SpinType END = const SpinType(5);
  static const SpinType USER_DEFINED = const SpinType(6);
  String toString() {
    switch(index) {
      case 0: return 'SpinType.STEP_FORWARD';
      case 1: return 'SpinType.STEP_BACKWARD';
      case 2: return 'SpinType.PAGE_FORWARD';
      case 3: return 'SpinType.PAGE_BACKWARD';
      case 4: return 'SpinType.HOME';
      case 5: return 'SpinType.END';
      case 6: return 'SpinType.USER_DEFINED';
      default: return 'new SpinType($index)';
    }
  }
}

class Spinner extends Widget with ImplementorIface, Buildable {
  Spinner.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Spinner');

  bool get active => _staticInfo.getGPropertyOnReceiver('active', this);
  void set active(bool value) => _staticInfo.setGPropertyOnReceiver('active', this, value);
  static const String ACTIVE_PROPERTY = 'active';
  factory Spinner() => _staticInfo.callStatic('new', []);
  void start() => _staticInfo.callMethodOnReceiver('start', this, []);
  void stop() => _staticInfo.callMethodOnReceiver('stop', this, []);
}

class SpinnerAccessible extends WidgetAccessible with Component, atk.Image {
  SpinnerAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SpinnerAccessible');

}

class Stack extends Container with ImplementorIface, Buildable {
  Stack.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Stack');

  static const String HHOMOGENEOUS_PROPERTY = 'hhomogeneous';
  static const String HOMOGENEOUS_PROPERTY = 'homogeneous';
  static const String INTERPOLATE_SIZE_PROPERTY = 'interpolate-size';
  static const String TRANSITION_DURATION_PROPERTY = 'transition-duration';
  static const String TRANSITION_RUNNING_PROPERTY = 'transition-running';
  static const String TRANSITION_TYPE_PROPERTY = 'transition-type';
  static const String VHOMOGENEOUS_PROPERTY = 'vhomogeneous';
  static const String VISIBLE_CHILD_PROPERTY = 'visible-child';
  static const String VISIBLE_CHILD_NAME_PROPERTY = 'visible-child-name';
  factory Stack() => _staticInfo.callStatic('new', []);
  void addNamed(Widget child, String name) => _staticInfo.callMethodOnReceiver('add_named', this, [child, name]);
  void addTitled(Widget child, String name, String title) => _staticInfo.callMethodOnReceiver('add_titled', this, [child, name, title]);
  Widget getChildByName(String name) => _staticInfo.callMethodOnReceiver('get_child_by_name', this, [name]);
  bool get hhomogeneous => _staticInfo.callMethodOnReceiver('get_hhomogeneous', this, []);
  bool get homogeneous => _staticInfo.callMethodOnReceiver('get_homogeneous', this, []);
  bool get interpolateSize => _staticInfo.callMethodOnReceiver('get_interpolate_size', this, []);
  int get transitionDuration => _staticInfo.callMethodOnReceiver('get_transition_duration', this, []);
  bool get transitionRunning => _staticInfo.callMethodOnReceiver('get_transition_running', this, []);
  StackTransitionType get transitionType => _staticInfo.callMethodOnReceiver('get_transition_type', this, []);
  bool get vhomogeneous => _staticInfo.callMethodOnReceiver('get_vhomogeneous', this, []);
  Widget get visibleChild => _staticInfo.callMethodOnReceiver('get_visible_child', this, []);
  String get visibleChildName => _staticInfo.callMethodOnReceiver('get_visible_child_name', this, []);
  void set hhomogeneous(bool hhomogeneous) => _staticInfo.callMethodOnReceiver('set_hhomogeneous', this, [hhomogeneous]);
  void set homogeneous(bool homogeneous) => _staticInfo.callMethodOnReceiver('set_homogeneous', this, [homogeneous]);
  void set interpolateSize(bool interpolateSize) => _staticInfo.callMethodOnReceiver('set_interpolate_size', this, [interpolateSize]);
  void set transitionDuration(int duration) => _staticInfo.callMethodOnReceiver('set_transition_duration', this, [duration]);
  void set transitionType(StackTransitionType transition) => _staticInfo.callMethodOnReceiver('set_transition_type', this, [transition]);
  void set vhomogeneous(bool vhomogeneous) => _staticInfo.callMethodOnReceiver('set_vhomogeneous', this, [vhomogeneous]);
  void set visibleChild(Widget child) => _staticInfo.callMethodOnReceiver('set_visible_child', this, [child]);
  void setVisibleChildFull(String name, StackTransitionType transition) => _staticInfo.callMethodOnReceiver('set_visible_child_full', this, [name, transition]);
  void set visibleChildName(String name) => _staticInfo.callMethodOnReceiver('set_visible_child_name', this, [name]);
}

class StackSidebar extends Bin with ImplementorIface, Buildable {
  StackSidebar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'StackSidebar');

  static const String STACK_PROPERTY = 'stack';
  factory StackSidebar() => _staticInfo.callStatic('new', []);
  Stack get stack => _staticInfo.callMethodOnReceiver('get_stack', this, []);
  void set stack(Stack stack) => _staticInfo.callMethodOnReceiver('set_stack', this, [stack]);
}

class StackSidebarPrivate extends GObjectBase {
  StackSidebarPrivate.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'StackSidebarPrivate');

}

class StackSwitcher extends Box with ImplementorIface, Buildable, Orientable {
  StackSwitcher.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'StackSwitcher');

  static const String STACK_PROPERTY = 'stack';
  factory StackSwitcher() => _staticInfo.callStatic('new', []);
  Stack get stack => _staticInfo.callMethodOnReceiver('get_stack', this, []);
  void set stack(Stack stack) => _staticInfo.callMethodOnReceiver('set_stack', this, [stack]);
}

class StackTransitionType extends GEnumBase {
  const StackTransitionType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'StackTransitionType');

  static const StackTransitionType NONE = const StackTransitionType(0);
  static const StackTransitionType CROSSFADE = const StackTransitionType(1);
  static const StackTransitionType SLIDE_RIGHT = const StackTransitionType(2);
  static const StackTransitionType SLIDE_LEFT = const StackTransitionType(3);
  static const StackTransitionType SLIDE_UP = const StackTransitionType(4);
  static const StackTransitionType SLIDE_DOWN = const StackTransitionType(5);
  static const StackTransitionType SLIDE_LEFT_RIGHT = const StackTransitionType(6);
  static const StackTransitionType SLIDE_UP_DOWN = const StackTransitionType(7);
  static const StackTransitionType OVER_UP = const StackTransitionType(8);
  static const StackTransitionType OVER_DOWN = const StackTransitionType(9);
  static const StackTransitionType OVER_LEFT = const StackTransitionType(10);
  static const StackTransitionType OVER_RIGHT = const StackTransitionType(11);
  static const StackTransitionType UNDER_UP = const StackTransitionType(12);
  static const StackTransitionType UNDER_DOWN = const StackTransitionType(13);
  static const StackTransitionType UNDER_LEFT = const StackTransitionType(14);
  static const StackTransitionType UNDER_RIGHT = const StackTransitionType(15);
  static const StackTransitionType OVER_UP_DOWN = const StackTransitionType(16);
  static const StackTransitionType OVER_DOWN_UP = const StackTransitionType(17);
  static const StackTransitionType OVER_LEFT_RIGHT = const StackTransitionType(18);
  static const StackTransitionType OVER_RIGHT_LEFT = const StackTransitionType(19);
  String toString() {
    switch(index) {
      case 0: return 'StackTransitionType.NONE';
      case 1: return 'StackTransitionType.CROSSFADE';
      case 2: return 'StackTransitionType.SLIDE_RIGHT';
      case 3: return 'StackTransitionType.SLIDE_LEFT';
      case 4: return 'StackTransitionType.SLIDE_UP';
      case 5: return 'StackTransitionType.SLIDE_DOWN';
      case 6: return 'StackTransitionType.SLIDE_LEFT_RIGHT';
      case 7: return 'StackTransitionType.SLIDE_UP_DOWN';
      case 8: return 'StackTransitionType.OVER_UP';
      case 9: return 'StackTransitionType.OVER_DOWN';
      case 10: return 'StackTransitionType.OVER_LEFT';
      case 11: return 'StackTransitionType.OVER_RIGHT';
      case 12: return 'StackTransitionType.UNDER_UP';
      case 13: return 'StackTransitionType.UNDER_DOWN';
      case 14: return 'StackTransitionType.UNDER_LEFT';
      case 15: return 'StackTransitionType.UNDER_RIGHT';
      case 16: return 'StackTransitionType.OVER_UP_DOWN';
      case 17: return 'StackTransitionType.OVER_DOWN_UP';
      case 18: return 'StackTransitionType.OVER_LEFT_RIGHT';
      case 19: return 'StackTransitionType.OVER_RIGHT_LEFT';
      default: return 'new StackTransitionType($index)';
    }
  }
}

class StateFlags extends GEnumBase {
  const StateFlags(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'StateFlags');

  static const StateFlags NORMAL = const StateFlags(0);
  bool get normal => (index & 0) == 0;
  static const StateFlags ACTIVE = const StateFlags(1);
  bool get active => (index & 1) == 1;
  static const StateFlags PRELIGHT = const StateFlags(2);
  bool get prelight => (index & 2) == 2;
  static const StateFlags SELECTED = const StateFlags(4);
  bool get selected => (index & 4) == 4;
  static const StateFlags INSENSITIVE = const StateFlags(8);
  bool get insensitive => (index & 8) == 8;
  static const StateFlags INCONSISTENT = const StateFlags(16);
  bool get inconsistent => (index & 16) == 16;
  static const StateFlags FOCUSED = const StateFlags(32);
  bool get focused => (index & 32) == 32;
  static const StateFlags BACKDROP = const StateFlags(64);
  bool get backdrop => (index & 64) == 64;
  static const StateFlags DIR_LTR = const StateFlags(128);
  bool get dirLtr => (index & 128) == 128;
  static const StateFlags DIR_RTL = const StateFlags(256);
  bool get dirRtl => (index & 256) == 256;
  static const StateFlags LINK = const StateFlags(512);
  bool get link => (index & 512) == 512;
  static const StateFlags VISITED = const StateFlags(1024);
  bool get visited => (index & 1024) == 1024;
  static const StateFlags CHECKED = const StateFlags(2048);
  bool get checked => (index & 2048) == 2048;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'StateFlags.ACTIVE';
      case 2: return 'StateFlags.PRELIGHT';
      case 4: return 'StateFlags.SELECTED';
      case 8: return 'StateFlags.INSENSITIVE';
      case 16: return 'StateFlags.INCONSISTENT';
      case 32: return 'StateFlags.FOCUSED';
      case 64: return 'StateFlags.BACKDROP';
      case 128: return 'StateFlags.DIR_LTR';
      default: return 'new StateFlags($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'StateFlags.NORMAL';
    }
    List codes = [];
    for (var i=1; i <= 2048; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  StateFlags operator|(StateFlags other) =>
    new StateFlags(index | other.index);
  StateFlags operator&(StateFlags other) =>
    new StateFlags(index & other.index);
}

class StateType extends GEnumBase {
  const StateType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'StateType');

  static const StateType NORMAL = const StateType(0);
  static const StateType ACTIVE = const StateType(1);
  static const StateType PRELIGHT = const StateType(2);
  static const StateType SELECTED = const StateType(3);
  static const StateType INSENSITIVE = const StateType(4);
  static const StateType INCONSISTENT = const StateType(5);
  static const StateType FOCUSED = const StateType(6);
  String toString() {
    switch(index) {
      case 0: return 'StateType.NORMAL';
      case 1: return 'StateType.ACTIVE';
      case 2: return 'StateType.PRELIGHT';
      case 3: return 'StateType.SELECTED';
      case 4: return 'StateType.INSENSITIVE';
      case 5: return 'StateType.INCONSISTENT';
      case 6: return 'StateType.FOCUSED';
      default: return 'new StateType($index)';
    }
  }
}

class StatusIcon extends GObjectObject {
  StatusIcon.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'StatusIcon');

  bool get embedded => _staticInfo.getGPropertyOnReceiver('embedded', this);
  static const String EMBEDDED_PROPERTY = 'embedded';
  void set file(String value) => _staticInfo.setGPropertyOnReceiver('file', this, value);
  static const String FILE_PROPERTY = 'file';
  void set gicon(Icon value) => _staticInfo.setGPropertyOnReceiver('gicon', this, value);
  static const String GICON_PROPERTY = 'gicon';
  static const String HAS_TOOLTIP_PROPERTY = 'has-tooltip';
  void set iconName(String value) => _staticInfo.setGPropertyOnReceiver('icon-name', this, value);
  static const String ICON_NAME_PROPERTY = 'icon-name';
  Orientation get orientation => _staticInfo.getGPropertyOnReceiver('orientation', this);
  static const String ORIENTATION_PROPERTY = 'orientation';
  void set pixbuf(Pixbuf value) => _staticInfo.setGPropertyOnReceiver('pixbuf', this, value);
  static const String PIXBUF_PROPERTY = 'pixbuf';
  static const String SCREEN_PROPERTY = 'screen';
  static const String SIZE_PROPERTY = 'size';
  void set stock(String value) => _staticInfo.setGPropertyOnReceiver('stock', this, value);
  static const String STOCK_PROPERTY = 'stock';
  static const String STORAGE_TYPE_PROPERTY = 'storage-type';
  static const String TITLE_PROPERTY = 'title';
  static const String TOOLTIP_MARKUP_PROPERTY = 'tooltip-markup';
  static const String TOOLTIP_TEXT_PROPERTY = 'tooltip-text';
  static const String VISIBLE_PROPERTY = 'visible';
  factory StatusIcon() => _staticInfo.callStatic('new', []);
  factory StatusIcon.fromFile(String filename) => _staticInfo.callStatic('new_from_file', [filename]);
  factory StatusIcon.fromGicon(Icon icon) => _staticInfo.callStatic('new_from_gicon', [icon]);
  factory StatusIcon.fromIconName(String iconName) => _staticInfo.callStatic('new_from_icon_name', [iconName]);
  factory StatusIcon.fromPixbuf(Pixbuf pixbuf) => _staticInfo.callStatic('new_from_pixbuf', [pixbuf]);
  factory StatusIcon.fromStock(String stockId) => _staticInfo.callStatic('new_from_stock', [stockId]);
  static void positionMenu(Menu menu, int x, int y, StatusIcon userData) => _staticInfo.callStatic('position_menu', [menu, x, y, userData]);
  bool getGeometry() => _staticInfo.callMethodOnReceiver('get_geometry', this, []);
  Icon get gicon_ => _staticInfo.callMethodOnReceiver('get_gicon', this, []);
  bool get hasTooltip => _staticInfo.callMethodOnReceiver('get_has_tooltip', this, []);
  String get iconName_ => _staticInfo.callMethodOnReceiver('get_icon_name', this, []);
  Pixbuf get pixbuf_ => _staticInfo.callMethodOnReceiver('get_pixbuf', this, []);
  Screen get screen => _staticInfo.callMethodOnReceiver('get_screen', this, []);
  int get size => _staticInfo.callMethodOnReceiver('get_size', this, []);
  String get stock_ => _staticInfo.callMethodOnReceiver('get_stock', this, []);
  ImageType get storageType => _staticInfo.callMethodOnReceiver('get_storage_type', this, []);
  String get title => _staticInfo.callMethodOnReceiver('get_title', this, []);
  String get tooltipMarkup => _staticInfo.callMethodOnReceiver('get_tooltip_markup', this, []);
  String get tooltipText => _staticInfo.callMethodOnReceiver('get_tooltip_text', this, []);
  bool get visible => _staticInfo.callMethodOnReceiver('get_visible', this, []);
  int getX11WindowId() => _staticInfo.callMethodOnReceiver('get_x11_window_id', this, []);
  bool isEmbedded() => _staticInfo.callMethodOnReceiver('is_embedded', this, []);
  void setFromFile(String filename) => _staticInfo.callMethodOnReceiver('set_from_file', this, [filename]);
  void setFromGicon(Icon icon) => _staticInfo.callMethodOnReceiver('set_from_gicon', this, [icon]);
  void setFromIconName(String iconName) => _staticInfo.callMethodOnReceiver('set_from_icon_name', this, [iconName]);
  void setFromPixbuf(Pixbuf pixbuf) => _staticInfo.callMethodOnReceiver('set_from_pixbuf', this, [pixbuf]);
  void setFromStock(String stockId) => _staticInfo.callMethodOnReceiver('set_from_stock', this, [stockId]);
  void set hasTooltip(bool hasTooltip) => _staticInfo.callMethodOnReceiver('set_has_tooltip', this, [hasTooltip]);
  void setName(String name) => _staticInfo.callMethodOnReceiver('set_name', this, [name]);
  void set screen(Screen screen) => _staticInfo.callMethodOnReceiver('set_screen', this, [screen]);
  void set title(String title) => _staticInfo.callMethodOnReceiver('set_title', this, [title]);
  void set tooltipMarkup(String markup) => _staticInfo.callMethodOnReceiver('set_tooltip_markup', this, [markup]);
  void set tooltipText(String text) => _staticInfo.callMethodOnReceiver('set_tooltip_text', this, [text]);
  void set visible(bool visible) => _staticInfo.callMethodOnReceiver('set_visible', this, [visible]);
  int _connectToActivate(bool after, void func()) => signalConnect('activate', func, after);
  Stream get onActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToButtonPressEvent(bool after, bool func(EventButton event)) => signalConnect('button-press-event', func, after);
  Stream<StatusIconButtonPressEventEvent> get onButtonPressEvent {
    int signalId;
    StreamController<StatusIconButtonPressEventEvent> controller;
    controller = new StreamController<StatusIconButtonPressEventEvent>(
      onListen: () {
          signalId = _connectToButtonPressEvent(false, (EventButton event) {
              var result = new StatusIconButtonPressEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<StatusIconButtonPressEventEvent> get afterButtonPressEvent {
    int signalId;
    StreamController<StatusIconButtonPressEventEvent> controller;
    controller = new StreamController<StatusIconButtonPressEventEvent>(
      onListen: () {
          signalId = _connectToButtonPressEvent(true, (EventButton event) {
              var result = new StatusIconButtonPressEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToButtonReleaseEvent(bool after, bool func(EventButton event)) => signalConnect('button-release-event', func, after);
  Stream<StatusIconButtonReleaseEventEvent> get onButtonReleaseEvent {
    int signalId;
    StreamController<StatusIconButtonReleaseEventEvent> controller;
    controller = new StreamController<StatusIconButtonReleaseEventEvent>(
      onListen: () {
          signalId = _connectToButtonReleaseEvent(false, (EventButton event) {
              var result = new StatusIconButtonReleaseEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<StatusIconButtonReleaseEventEvent> get afterButtonReleaseEvent {
    int signalId;
    StreamController<StatusIconButtonReleaseEventEvent> controller;
    controller = new StreamController<StatusIconButtonReleaseEventEvent>(
      onListen: () {
          signalId = _connectToButtonReleaseEvent(true, (EventButton event) {
              var result = new StatusIconButtonReleaseEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPopupMenu(bool after, void func(int button, int activateTime)) => signalConnect('popup-menu', func, after);
  Stream<StatusIconPopupMenuEvent> get onPopupMenu {
    int signalId;
    StreamController<StatusIconPopupMenuEvent> controller;
    controller = new StreamController<StatusIconPopupMenuEvent>(
      onListen: () {
          signalId = _connectToPopupMenu(false, (int button, int activateTime) {
              var result = new StatusIconPopupMenuEvent(button, activateTime);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<StatusIconPopupMenuEvent> get afterPopupMenu {
    int signalId;
    StreamController<StatusIconPopupMenuEvent> controller;
    controller = new StreamController<StatusIconPopupMenuEvent>(
      onListen: () {
          signalId = _connectToPopupMenu(true, (int button, int activateTime) {
              var result = new StatusIconPopupMenuEvent(button, activateTime);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToQueryTooltip(bool after, bool func(int x, int y, bool keyboardMode, Tooltip tooltip)) => signalConnect('query-tooltip', func, after);
  Stream<StatusIconQueryTooltipEvent> get onQueryTooltip {
    int signalId;
    StreamController<StatusIconQueryTooltipEvent> controller;
    controller = new StreamController<StatusIconQueryTooltipEvent>(
      onListen: () {
          signalId = _connectToQueryTooltip(false, (int x, int y, bool keyboardMode, Tooltip tooltip) {
              var result = new StatusIconQueryTooltipEvent(x, y, keyboardMode, tooltip);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<StatusIconQueryTooltipEvent> get afterQueryTooltip {
    int signalId;
    StreamController<StatusIconQueryTooltipEvent> controller;
    controller = new StreamController<StatusIconQueryTooltipEvent>(
      onListen: () {
          signalId = _connectToQueryTooltip(true, (int x, int y, bool keyboardMode, Tooltip tooltip) {
              var result = new StatusIconQueryTooltipEvent(x, y, keyboardMode, tooltip);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToScrollEvent(bool after, bool func(EventScroll event)) => signalConnect('scroll-event', func, after);
  Stream<StatusIconScrollEventEvent> get onScrollEvent {
    int signalId;
    StreamController<StatusIconScrollEventEvent> controller;
    controller = new StreamController<StatusIconScrollEventEvent>(
      onListen: () {
          signalId = _connectToScrollEvent(false, (EventScroll event) {
              var result = new StatusIconScrollEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<StatusIconScrollEventEvent> get afterScrollEvent {
    int signalId;
    StreamController<StatusIconScrollEventEvent> controller;
    controller = new StreamController<StatusIconScrollEventEvent>(
      onListen: () {
          signalId = _connectToScrollEvent(true, (EventScroll event) {
              var result = new StatusIconScrollEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSizeChanged(bool after, bool func(int size)) => signalConnect('size-changed', func, after);
  Stream<StatusIconSizeChangedEvent> get onSizeChanged {
    int signalId;
    StreamController<StatusIconSizeChangedEvent> controller;
    controller = new StreamController<StatusIconSizeChangedEvent>(
      onListen: () {
          signalId = _connectToSizeChanged(false, (int size) {
              var result = new StatusIconSizeChangedEvent(size);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<StatusIconSizeChangedEvent> get afterSizeChanged {
    int signalId;
    StreamController<StatusIconSizeChangedEvent> controller;
    controller = new StreamController<StatusIconSizeChangedEvent>(
      onListen: () {
          signalId = _connectToSizeChanged(true, (int size) {
              var result = new StatusIconSizeChangedEvent(size);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class StatusIconButtonPressEventEvent {
  final EventButton event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  StatusIconButtonPressEventEvent(this.event);
}

class StatusIconButtonReleaseEventEvent {
  final EventButton event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  StatusIconButtonReleaseEventEvent(this.event);
}

class StatusIconPopupMenuEvent {
  final int button;
  final int activateTime;

  StatusIconPopupMenuEvent(this.button, this.activateTime);
}

class StatusIconQueryTooltipEvent {
  final int x;
  final int y;
  final bool keyboardMode;
  final Tooltip tooltip;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  StatusIconQueryTooltipEvent(this.x, this.y, this.keyboardMode, this.tooltip);
}

class StatusIconScrollEventEvent {
  final EventScroll event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  StatusIconScrollEventEvent(this.event);
}

class StatusIconSizeChangedEvent {
  final int size;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  StatusIconSizeChangedEvent(this.size);
}

class Statusbar extends Box with ImplementorIface, Buildable, Orientable {
  Statusbar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Statusbar');

  factory Statusbar() => _staticInfo.callStatic('new', []);
  int getContextId(String contextDescription) => _staticInfo.callMethodOnReceiver('get_context_id', this, [contextDescription]);
  Box getMessageArea() => _staticInfo.callMethodOnReceiver('get_message_area', this, []);
  void pop(int contextId) => _staticInfo.callMethodOnReceiver('pop', this, [contextId]);
  int push(int contextId, String text) => _staticInfo.callMethodOnReceiver('push', this, [contextId, text]);
  void statusbarRemove(int contextId, int messageId) => _staticInfo.callMethodOnReceiver('remove', this, [contextId, messageId]);
  void removeAll(int contextId) => _staticInfo.callMethodOnReceiver('remove_all', this, [contextId]);
  int _connectToTextPopped(bool after, void func(int contextId, String text)) => signalConnect('text-popped', func, after);
  Stream<StatusbarTextPoppedEvent> get onTextPopped {
    int signalId;
    StreamController<StatusbarTextPoppedEvent> controller;
    controller = new StreamController<StatusbarTextPoppedEvent>(
      onListen: () {
          signalId = _connectToTextPopped(false, (int contextId, String text) {
              var result = new StatusbarTextPoppedEvent(contextId, text);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<StatusbarTextPoppedEvent> get afterTextPopped {
    int signalId;
    StreamController<StatusbarTextPoppedEvent> controller;
    controller = new StreamController<StatusbarTextPoppedEvent>(
      onListen: () {
          signalId = _connectToTextPopped(true, (int contextId, String text) {
              var result = new StatusbarTextPoppedEvent(contextId, text);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToTextPushed(bool after, void func(int contextId, String text)) => signalConnect('text-pushed', func, after);
  Stream<StatusbarTextPushedEvent> get onTextPushed {
    int signalId;
    StreamController<StatusbarTextPushedEvent> controller;
    controller = new StreamController<StatusbarTextPushedEvent>(
      onListen: () {
          signalId = _connectToTextPushed(false, (int contextId, String text) {
              var result = new StatusbarTextPushedEvent(contextId, text);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<StatusbarTextPushedEvent> get afterTextPushed {
    int signalId;
    StreamController<StatusbarTextPushedEvent> controller;
    controller = new StreamController<StatusbarTextPushedEvent>(
      onListen: () {
          signalId = _connectToTextPushed(true, (int contextId, String text) {
              var result = new StatusbarTextPushedEvent(contextId, text);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class StatusbarTextPoppedEvent {
  final int contextId;
  final String text;

  StatusbarTextPoppedEvent(this.contextId, this.text);
}

class StatusbarTextPushedEvent {
  final int contextId;
  final String text;

  StatusbarTextPushedEvent(this.contextId, this.text);
}

class StatusbarAccessible extends ContainerAccessible with Component {
  StatusbarAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'StatusbarAccessible');

}

class StockItem extends GObjectBase {
  StockItem.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'StockItem');

  String get stockId => getFieldOfObject('stock_id', 0);
  void set stockId(String value) => setFieldOfObject('stock_id', 0, value);
  String get label => getFieldOfObject('label', 1);
  void set label(String value) => setFieldOfObject('label', 1, value);
  ModifierType get modifier => getFieldOfObject('modifier', 2);
  void set modifier(ModifierType value) => setFieldOfObject('modifier', 2, value);
  int get keyval => getFieldOfObject('keyval', 3);
  void set keyval(int value) => setFieldOfObject('keyval', 3, value);
  String get translationDomain => getFieldOfObject('translation_domain', 4);
  void set translationDomain(String value) => setFieldOfObject('translation_domain', 4, value);
  void free() => _staticInfo.callMethodOnReceiver('free', this, []);
}

class Style extends GObjectObject {
  Style.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Style');

  StyleContext get context => _staticInfo.getGPropertyOnReceiver('context', this);
  void set context(StyleContext value) => _staticInfo.setGPropertyOnReceiver('context', this, value);
  static const String CONTEXT_PROPERTY = 'context';
  factory Style() => _staticInfo.callStatic('new', []);
  void applyDefaultBackground(Context cr, gdk.Window window, StateType stateType, int x, int y, int width, int height) => _staticInfo.callMethodOnReceiver('apply_default_background', this, [cr, window, stateType, x, y, width, height]);
  Style copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void detach() => _staticInfo.callMethodOnReceiver('detach', this, []);
  void getStyleProperty(int widgetType, String propertyName) => _staticInfo.callMethodOnReceiver('get_style_property', this, [widgetType, propertyName]);
  bool hasContext() => _staticInfo.callMethodOnReceiver('has_context', this, []);
  bool lookupColor(String colorName) => _staticInfo.callMethodOnReceiver('lookup_color', this, [colorName]);
  IconSet lookupIconSet(String stockId) => _staticInfo.callMethodOnReceiver('lookup_icon_set', this, [stockId]);
  Pixbuf renderIcon(IconSource source, TextDirection direction, StateType state, int size, Widget widget, String detail) => _staticInfo.callMethodOnReceiver('render_icon', this, [source, direction, state, size, widget, detail]);
  void setBackground(gdk.Window window, StateType stateType) => _staticInfo.callMethodOnReceiver('set_background', this, [window, stateType]);
  List<Color> get fg => getFieldOfObject('fg', 1);
  List<Color> get bg => getFieldOfObject('bg', 2);
  List<Color> get light => getFieldOfObject('light', 3);
  List<Color> get dark => getFieldOfObject('dark', 4);
  List<Color> get mid => getFieldOfObject('mid', 5);
  List<Color> get text => getFieldOfObject('text', 6);
  List<Color> get base => getFieldOfObject('base', 7);
  List<Color> get textAa => getFieldOfObject('text_aa', 8);
  Color get black => getFieldOfObject('black', 9);
  Color get white => getFieldOfObject('white', 10);
  FontDescription get fontDesc => getFieldOfObject('font_desc', 11);
  int get xthickness => getFieldOfObject('xthickness', 12);
  int get ythickness => getFieldOfObject('ythickness', 13);
  List<CairoPattern> get background => getFieldOfObject('background', 14);
  int get attachCount => getFieldOfObject('attach_count', 15);
  Visual get visual => getFieldOfObject('visual', 16);
  FontDescription get privateFontDesc => getFieldOfObject('private_font_desc', 17);
  RcStyle get rcStyle => getFieldOfObject('rc_style', 18);
  SList /* this will fail */ get styles => getFieldOfObject('styles', 19);
  List<dynamic /* this will fail */> get propertyCache => getFieldOfObject('property_cache', 20);
  SList /* this will fail */ get iconFactories => getFieldOfObject('icon_factories', 21);
  int _connectToRealize(bool after, void func()) => signalConnect('realize', func, after);
  Stream get onRealize {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToRealize(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterRealize {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToRealize(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToUnrealize(bool after, void func()) => signalConnect('unrealize', func, after);
  Stream get onUnrealize {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUnrealize(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterUnrealize {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUnrealize(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class StyleContext extends GObjectObject {
  StyleContext.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'StyleContext');

  static const String DIRECTION_PROPERTY = 'direction';
  FrameClock get paintClock => _staticInfo.getGPropertyOnReceiver('paint-clock', this);
  void set paintClock(FrameClock value) => _staticInfo.setGPropertyOnReceiver('paint-clock', this, value);
  static const String PAINT_CLOCK_PROPERTY = 'paint-clock';
  static const String PARENT_PROPERTY = 'parent';
  static const String SCREEN_PROPERTY = 'screen';
  factory StyleContext() => _staticInfo.callStatic('new', []);
  static void addProviderForScreen(Screen screen, StyleProvider provider, int priority) => _staticInfo.callStatic('add_provider_for_screen', [screen, provider, priority]);
  static void removeProviderForScreen(Screen screen, StyleProvider provider) => _staticInfo.callStatic('remove_provider_for_screen', [screen, provider]);
  static void resetWidgets(Screen screen) => _staticInfo.callStatic('reset_widgets', [screen]);
  void addClass(String className) => _staticInfo.callMethodOnReceiver('add_class', this, [className]);
  void addProvider(StyleProvider provider, int priority) => _staticInfo.callMethodOnReceiver('add_provider', this, [provider, priority]);
  void addRegion(String regionName, RegionFlags flags) => _staticInfo.callMethodOnReceiver('add_region', this, [regionName, flags]);
  void cancelAnimations(dynamic regionId /* this will fail */) => _staticInfo.callMethodOnReceiver('cancel_animations', this, [regionId]);
  void getBackgroundColor(StateFlags state) => _staticInfo.callMethodOnReceiver('get_background_color', this, [state]);
  void getBorder(StateFlags state) => _staticInfo.callMethodOnReceiver('get_border', this, [state]);
  void getBorderColor(StateFlags state) => _staticInfo.callMethodOnReceiver('get_border_color', this, [state]);
  void getColor(StateFlags state) => _staticInfo.callMethodOnReceiver('get_color', this, [state]);
  TextDirection get direction => _staticInfo.callMethodOnReceiver('get_direction', this, []);
  FontDescription getFont(StateFlags state) => _staticInfo.callMethodOnReceiver('get_font', this, [state]);
  FrameClock getFrameClock() => _staticInfo.callMethodOnReceiver('get_frame_clock', this, []);
  JunctionSides getJunctionSides() => _staticInfo.callMethodOnReceiver('get_junction_sides', this, []);
  void getMargin(StateFlags state) => _staticInfo.callMethodOnReceiver('get_margin', this, [state]);
  void getPadding(StateFlags state) => _staticInfo.callMethodOnReceiver('get_padding', this, [state]);
  StyleContext get parent => _staticInfo.callMethodOnReceiver('get_parent', this, []);
  WidgetPath getPath() => _staticInfo.callMethodOnReceiver('get_path', this, []);
  void styleContextGetProperty(String property, StateFlags state) => _staticInfo.callMethodOnReceiver('get_property', this, [property, state]);
  int getScale() => _staticInfo.callMethodOnReceiver('get_scale', this, []);
  Screen get screen => _staticInfo.callMethodOnReceiver('get_screen', this, []);
  CssSection getSection(String property) => _staticInfo.callMethodOnReceiver('get_section', this, [property]);
  StateFlags getState() => _staticInfo.callMethodOnReceiver('get_state', this, []);
  void getStyleProperty(String propertyName, Value value) => _staticInfo.callMethodOnReceiver('get_style_property', this, [propertyName, value]);
  bool hasClass(String className) => _staticInfo.callMethodOnReceiver('has_class', this, [className]);
  bool hasRegion(String regionName) => _staticInfo.callMethodOnReceiver('has_region', this, [regionName]);
  void invalidate() => _staticInfo.callMethodOnReceiver('invalidate', this, []);
  GLibList /* this will fail */ listClasses() => _staticInfo.callMethodOnReceiver('list_classes', this, []);
  GLibList /* this will fail */ listRegions() => _staticInfo.callMethodOnReceiver('list_regions', this, []);
  bool lookupColor(String colorName) => _staticInfo.callMethodOnReceiver('lookup_color', this, [colorName]);
  IconSet lookupIconSet(String stockId) => _staticInfo.callMethodOnReceiver('lookup_icon_set', this, [stockId]);
  void notifyStateChange(gdk.Window window, dynamic regionId /* this will fail */, StateType state, bool stateValue) => _staticInfo.callMethodOnReceiver('notify_state_change', this, [window, regionId, state, stateValue]);
  void popAnimatableRegion() => _staticInfo.callMethodOnReceiver('pop_animatable_region', this, []);
  void pushAnimatableRegion(dynamic regionId /* this will fail */) => _staticInfo.callMethodOnReceiver('push_animatable_region', this, [regionId]);
  void removeClass(String className) => _staticInfo.callMethodOnReceiver('remove_class', this, [className]);
  void removeProvider(StyleProvider provider) => _staticInfo.callMethodOnReceiver('remove_provider', this, [provider]);
  void removeRegion(String regionName) => _staticInfo.callMethodOnReceiver('remove_region', this, [regionName]);
  void restore() => _staticInfo.callMethodOnReceiver('restore', this, []);
  void save() => _staticInfo.callMethodOnReceiver('save', this, []);
  void scrollAnimations(gdk.Window window, int dx, int dy) => _staticInfo.callMethodOnReceiver('scroll_animations', this, [window, dx, dy]);
  void setBackground(gdk.Window window) => _staticInfo.callMethodOnReceiver('set_background', this, [window]);
  void set direction(TextDirection direction) => _staticInfo.callMethodOnReceiver('set_direction', this, [direction]);
  void setFrameClock(FrameClock frameClock) => _staticInfo.callMethodOnReceiver('set_frame_clock', this, [frameClock]);
  void setJunctionSides(JunctionSides sides) => _staticInfo.callMethodOnReceiver('set_junction_sides', this, [sides]);
  void set parent(StyleContext parent) => _staticInfo.callMethodOnReceiver('set_parent', this, [parent]);
  void setPath(WidgetPath path) => _staticInfo.callMethodOnReceiver('set_path', this, [path]);
  void setScale(int scale) => _staticInfo.callMethodOnReceiver('set_scale', this, [scale]);
  void set screen(Screen screen) => _staticInfo.callMethodOnReceiver('set_screen', this, [screen]);
  void setState(StateFlags flags) => _staticInfo.callMethodOnReceiver('set_state', this, [flags]);
  bool stateIsRunning(StateType state) => _staticInfo.callMethodOnReceiver('state_is_running', this, [state]);
  int _connectToChanged(bool after, void func()) => signalConnect('changed', func, after);
  Stream get onChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class StyleProperties extends GObjectObject with StyleProvider {
  StyleProperties.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'StyleProperties');

  factory StyleProperties() => _staticInfo.callStatic('new', []);
  void clear() => _staticInfo.callMethodOnReceiver('clear', this, []);
  bool stylePropertiesGetProperty(String property, StateFlags state) => _staticInfo.callMethodOnReceiver('get_property', this, [property, state]);
  SymbolicColor lookupColor(String name) => _staticInfo.callMethodOnReceiver('lookup_color', this, [name]);
  void mapColor(String name, SymbolicColor color) => _staticInfo.callMethodOnReceiver('map_color', this, [name, color]);
  void merge(StyleProperties propsToMerge, bool replace) => _staticInfo.callMethodOnReceiver('merge', this, [propsToMerge, replace]);
  void stylePropertiesSetProperty(String property, StateFlags state, Value value) => _staticInfo.callMethodOnReceiver('set_property', this, [property, state, value]);
  void unsetProperty(String property, StateFlags state) => _staticInfo.callMethodOnReceiver('unset_property', this, [property, state]);
}

typedef void StylePropertyParser(String string, Value value);
abstract class StyleProvider extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'StyleProvider');



  IconFactory getIconFactory(WidgetPath path) => _staticInfo.callMethodOnReceiver('get_icon_factory', this, [path]);
  StyleProperties getStyle(WidgetPath path) => _staticInfo.callMethodOnReceiver('get_style', this, [path]);
  bool getStyleProperty(WidgetPath path, StateFlags state, ParamSpec pspec) => _staticInfo.callMethodOnReceiver('get_style_property', this, [path, state, pspec]);
}

class Switch extends Widget with ImplementorIface, Actionable, Activatable, Buildable {
  Switch.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Switch');

  static const String ACTIVE_PROPERTY = 'active';
  static const String STATE_PROPERTY = 'state';
  factory Switch() => _staticInfo.callStatic('new', []);
  bool get active => _staticInfo.callMethodOnReceiver('get_active', this, []);
  bool get state => _staticInfo.callMethodOnReceiver('get_state', this, []);
  void set active(bool isActive) => _staticInfo.callMethodOnReceiver('set_active', this, [isActive]);
  void set state(bool state) => _staticInfo.callMethodOnReceiver('set_state', this, [state]);
  int _connectToActivate(bool after, void func()) => signalConnect('activate', func, after);
  Stream get onActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivate {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivate(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToStateSet(bool after, bool func(bool state)) => signalConnect('state-set', func, after);
  Stream<SwitchStateSetEvent> get onStateSet {
    int signalId;
    StreamController<SwitchStateSetEvent> controller;
    controller = new StreamController<SwitchStateSetEvent>(
      onListen: () {
          signalId = _connectToStateSet(false, (bool state) {
              var result = new SwitchStateSetEvent(state);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<SwitchStateSetEvent> get afterStateSet {
    int signalId;
    StreamController<SwitchStateSetEvent> controller;
    controller = new StreamController<SwitchStateSetEvent>(
      onListen: () {
          signalId = _connectToStateSet(true, (bool state) {
              var result = new SwitchStateSetEvent(state);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class SwitchStateSetEvent {
  final bool state;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  SwitchStateSetEvent(this.state);
}

class SwitchAccessible extends WidgetAccessible with atk.Action, Component {
  SwitchAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SwitchAccessible');

}

class SymbolicColor extends GObjectBase {
  SymbolicColor.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'SymbolicColor');

  factory SymbolicColor.alpha(SymbolicColor color, num factor) => _staticInfo.callStatic('new_alpha', [color, factor]);
  factory SymbolicColor.literal(RGBA color) => _staticInfo.callStatic('new_literal', [color]);
  factory SymbolicColor.mix(SymbolicColor color1, SymbolicColor color2, num factor) => _staticInfo.callStatic('new_mix', [color1, color2, factor]);
  factory SymbolicColor.name(String name) => _staticInfo.callStatic('new_name', [name]);
  factory SymbolicColor.shade(SymbolicColor color, num factor) => _staticInfo.callStatic('new_shade', [color, factor]);
  factory SymbolicColor.win32(String themeClass, int id) => _staticInfo.callStatic('new_win32', [themeClass, id]);
  SymbolicColor ref() => _staticInfo.callMethodOnReceiver('ref', this, []);
  bool resolve(StyleProperties props) => _staticInfo.callMethodOnReceiver('resolve', this, [props]);
  String toString() => _staticInfo.callMethodOnReceiver('to_string', this, []);
  void unref() => _staticInfo.callMethodOnReceiver('unref', this, []);
}

class Table extends Container with ImplementorIface, Buildable {
  Table.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Table');

  int get columnSpacing => _staticInfo.getGPropertyOnReceiver('column-spacing', this);
  void set columnSpacing(int value) => _staticInfo.setGPropertyOnReceiver('column-spacing', this, value);
  static const String COLUMN_SPACING_PROPERTY = 'column-spacing';
  static const String HOMOGENEOUS_PROPERTY = 'homogeneous';
  int get nColumns => _staticInfo.getGPropertyOnReceiver('n-columns', this);
  void set nColumns(int value) => _staticInfo.setGPropertyOnReceiver('n-columns', this, value);
  static const String N_COLUMNS_PROPERTY = 'n-columns';
  int get nRows => _staticInfo.getGPropertyOnReceiver('n-rows', this);
  void set nRows(int value) => _staticInfo.setGPropertyOnReceiver('n-rows', this, value);
  static const String N_ROWS_PROPERTY = 'n-rows';
  static const String ROW_SPACING_PROPERTY = 'row-spacing';
  factory Table(int rows, int columns, bool homogeneous) => _staticInfo.callStatic('new', [rows, columns, homogeneous]);
  void attach(Widget child, int leftAttach, int rightAttach, int topAttach, int bottomAttach, AttachOptions xoptions, AttachOptions yoptions, int xpadding, int ypadding) => _staticInfo.callMethodOnReceiver('attach', this, [child, leftAttach, rightAttach, topAttach, bottomAttach, xoptions, yoptions, xpadding, ypadding]);
  void attachDefaults(Widget widget, int leftAttach, int rightAttach, int topAttach, int bottomAttach) => _staticInfo.callMethodOnReceiver('attach_defaults', this, [widget, leftAttach, rightAttach, topAttach, bottomAttach]);
  int getColSpacing(int column) => _staticInfo.callMethodOnReceiver('get_col_spacing', this, [column]);
  int getDefaultColSpacing() => _staticInfo.callMethodOnReceiver('get_default_col_spacing', this, []);
  int getDefaultRowSpacing() => _staticInfo.callMethodOnReceiver('get_default_row_spacing', this, []);
  bool get homogeneous => _staticInfo.callMethodOnReceiver('get_homogeneous', this, []);
  int getRowSpacing(int row) => _staticInfo.callMethodOnReceiver('get_row_spacing', this, [row]);
  void getSize() => _staticInfo.callMethodOnReceiver('get_size', this, []);
  void resize(int rows, int columns) => _staticInfo.callMethodOnReceiver('resize', this, [rows, columns]);
  void setColSpacing(int column, int spacing) => _staticInfo.callMethodOnReceiver('set_col_spacing', this, [column, spacing]);
  void setColSpacings(int spacing) => _staticInfo.callMethodOnReceiver('set_col_spacings', this, [spacing]);
  void set homogeneous(bool homogeneous) => _staticInfo.callMethodOnReceiver('set_homogeneous', this, [homogeneous]);
  void setRowSpacing(int row, int spacing) => _staticInfo.callMethodOnReceiver('set_row_spacing', this, [row, spacing]);
  void setRowSpacings(int spacing) => _staticInfo.callMethodOnReceiver('set_row_spacings', this, [spacing]);
}

class TableChild extends GObjectBase {
  TableChild.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TableChild');

  Widget get widget => getFieldOfObject('widget', 0);
  void set widget(Widget value) => setFieldOfObject('widget', 0, value);
  int get leftAttach => getFieldOfObject('left_attach', 1);
  void set leftAttach(int value) => setFieldOfObject('left_attach', 1, value);
  int get rightAttach => getFieldOfObject('right_attach', 2);
  void set rightAttach(int value) => setFieldOfObject('right_attach', 2, value);
  int get topAttach => getFieldOfObject('top_attach', 3);
  void set topAttach(int value) => setFieldOfObject('top_attach', 3, value);
  int get bottomAttach => getFieldOfObject('bottom_attach', 4);
  void set bottomAttach(int value) => setFieldOfObject('bottom_attach', 4, value);
  int get xpadding => getFieldOfObject('xpadding', 5);
  void set xpadding(int value) => setFieldOfObject('xpadding', 5, value);
  int get ypadding => getFieldOfObject('ypadding', 6);
  void set ypadding(int value) => setFieldOfObject('ypadding', 6, value);
  int get xexpand => getFieldOfObject('xexpand', 7);
  void set xexpand(int value) => setFieldOfObject('xexpand', 7, value);
  int get yexpand => getFieldOfObject('yexpand', 8);
  void set yexpand(int value) => setFieldOfObject('yexpand', 8, value);
  int get xshrink => getFieldOfObject('xshrink', 9);
  void set xshrink(int value) => setFieldOfObject('xshrink', 9, value);
  int get yshrink => getFieldOfObject('yshrink', 10);
  void set yshrink(int value) => setFieldOfObject('yshrink', 10, value);
  int get xfill => getFieldOfObject('xfill', 11);
  void set xfill(int value) => setFieldOfObject('xfill', 11, value);
  int get yfill => getFieldOfObject('yfill', 12);
  void set yfill(int value) => setFieldOfObject('yfill', 12, value);
}

class TableRowCol extends GObjectBase {
  TableRowCol.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TableRowCol');

  int get requisition => getFieldOfObject('requisition', 0);
  void set requisition(int value) => setFieldOfObject('requisition', 0, value);
  int get allocation => getFieldOfObject('allocation', 1);
  void set allocation(int value) => setFieldOfObject('allocation', 1, value);
  int get spacing => getFieldOfObject('spacing', 2);
  void set spacing(int value) => setFieldOfObject('spacing', 2, value);
  int get needExpand => getFieldOfObject('need_expand', 3);
  void set needExpand(int value) => setFieldOfObject('need_expand', 3, value);
  int get needShrink => getFieldOfObject('need_shrink', 4);
  void set needShrink(int value) => setFieldOfObject('need_shrink', 4, value);
  int get expand => getFieldOfObject('expand', 5);
  void set expand(int value) => setFieldOfObject('expand', 5, value);
  int get shrink => getFieldOfObject('shrink', 6);
  void set shrink(int value) => setFieldOfObject('shrink', 6, value);
  int get empty => getFieldOfObject('empty', 7);
  void set empty(int value) => setFieldOfObject('empty', 7, value);
}

class TargetEntry extends GObjectBase {
  TargetEntry.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TargetEntry');

  String get target => getFieldOfObject('target', 0);
  void set target(String value) => setFieldOfObject('target', 0, value);
  int get flags => getFieldOfObject('flags', 1);
  void set flags(int value) => setFieldOfObject('flags', 1, value);
  int get info => getFieldOfObject('info', 2);
  void set info(int value) => setFieldOfObject('info', 2, value);
  factory TargetEntry(String target, int flags, int info) => _staticInfo.callStatic('new', [target, flags, info]);
  TargetEntry copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void free() => _staticInfo.callMethodOnReceiver('free', this, []);
}

class TargetFlags extends GEnumBase {
  const TargetFlags(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TargetFlags');

  static const TargetFlags NULL = const TargetFlags(0);
  static const TargetFlags SAME_APP = const TargetFlags(1);
  bool get sameApp => (index & 1) == 1;
  static const TargetFlags SAME_WIDGET = const TargetFlags(2);
  bool get sameWidget => (index & 2) == 2;
  static const TargetFlags OTHER_APP = const TargetFlags(4);
  bool get otherApp => (index & 4) == 4;
  static const TargetFlags OTHER_WIDGET = const TargetFlags(8);
  bool get otherWidget => (index & 8) == 8;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'TargetFlags.SAME_APP';
      case 2: return 'TargetFlags.SAME_WIDGET';
      case 4: return 'TargetFlags.OTHER_APP';
      case 8: return 'TargetFlags.OTHER_WIDGET';
      default: return 'new TargetFlags($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'TargetFlags.NULL';
    }
    List codes = [];
    for (var i=1; i <= 8; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  TargetFlags operator|(TargetFlags other) =>
    new TargetFlags(index | other.index);
  TargetFlags operator&(TargetFlags other) =>
    new TargetFlags(index & other.index);
}

class TargetList extends GObjectBase {
  TargetList.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TargetList');

  factory TargetList(List<TargetEntry> targets) => _staticInfo.callStatic('new', [targets]);
  void add(Atom target, int flags, int info) => _staticInfo.callMethodOnReceiver('add', this, [target, flags, info]);
  void addImageTargets(int info, bool writable) => _staticInfo.callMethodOnReceiver('add_image_targets', this, [info, writable]);
  void addRichTextTargets(int info, bool deserializable, TextBuffer buffer) => _staticInfo.callMethodOnReceiver('add_rich_text_targets', this, [info, deserializable, buffer]);
  void addTable(List<TargetEntry> targets) => _staticInfo.callMethodOnReceiver('add_table', this, [targets]);
  void addTextTargets(int info) => _staticInfo.callMethodOnReceiver('add_text_targets', this, [info]);
  void addUriTargets(int info) => _staticInfo.callMethodOnReceiver('add_uri_targets', this, [info]);
  bool find(Atom target) => _staticInfo.callMethodOnReceiver('find', this, [target]);
  TargetList ref() => _staticInfo.callMethodOnReceiver('ref', this, []);
  void remove(Atom target) => _staticInfo.callMethodOnReceiver('remove', this, [target]);
  void unref() => _staticInfo.callMethodOnReceiver('unref', this, []);
}

class TargetPair extends GObjectBase {
  TargetPair.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TargetPair');

  Atom get target => getFieldOfObject('target', 0);
  void set target(Atom value) => setFieldOfObject('target', 0, value);
  int get flags => getFieldOfObject('flags', 1);
  void set flags(int value) => setFieldOfObject('flags', 1, value);
  int get info => getFieldOfObject('info', 2);
  void set info(int value) => setFieldOfObject('info', 2, value);
}

class TearoffMenuItem extends MenuItem with ImplementorIface, Actionable, Activatable, Buildable {
  TearoffMenuItem.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TearoffMenuItem');

  factory TearoffMenuItem() => _staticInfo.callStatic('new', []);
}

class TextAppearance extends GObjectBase {
  TextAppearance.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextAppearance');

  Color get bgColor => getFieldOfObject('bg_color', 0);
  void set bgColor(Color value) => setFieldOfObject('bg_color', 0, value);
  Color get fgColor => getFieldOfObject('fg_color', 1);
  void set fgColor(Color value) => setFieldOfObject('fg_color', 1, value);
  int get rise => getFieldOfObject('rise', 2);
  void set rise(int value) => setFieldOfObject('rise', 2, value);
  int get underline => getFieldOfObject('underline', 3);
  void set underline(int value) => setFieldOfObject('underline', 3, value);
  int get strikethrough => getFieldOfObject('strikethrough', 4);
  void set strikethrough(int value) => setFieldOfObject('strikethrough', 4, value);
  int get drawBg => getFieldOfObject('draw_bg', 5);
  void set drawBg(int value) => setFieldOfObject('draw_bg', 5, value);
  int get insideSelection => getFieldOfObject('inside_selection', 6);
  void set insideSelection(int value) => setFieldOfObject('inside_selection', 6, value);
  int get isText => getFieldOfObject('is_text', 7);
  void set isText(int value) => setFieldOfObject('is_text', 7, value);
}

class TextAttributes extends GObjectBase {
  TextAttributes.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextAttributes');

  int get refcount => getFieldOfObject('refcount', 0);
  TextAppearance get appearance => getFieldOfObject('appearance', 1);
  void set appearance(TextAppearance value) => setFieldOfObject('appearance', 1, value);
  Justification get justification => getFieldOfObject('justification', 2);
  void set justification(Justification value) => setFieldOfObject('justification', 2, value);
  TextDirection get direction => getFieldOfObject('direction', 3);
  void set direction(TextDirection value) => setFieldOfObject('direction', 3, value);
  FontDescription get font => getFieldOfObject('font', 4);
  void set font(FontDescription value) => setFieldOfObject('font', 4, value);
  num get fontScale => getFieldOfObject('font_scale', 5);
  void set fontScale(num value) => setFieldOfObject('font_scale', 5, value);
  int get leftMargin => getFieldOfObject('left_margin', 6);
  void set leftMargin(int value) => setFieldOfObject('left_margin', 6, value);
  int get rightMargin => getFieldOfObject('right_margin', 7);
  void set rightMargin(int value) => setFieldOfObject('right_margin', 7, value);
  int get indent => getFieldOfObject('indent', 8);
  void set indent(int value) => setFieldOfObject('indent', 8, value);
  int get pixelsAboveLines => getFieldOfObject('pixels_above_lines', 9);
  void set pixelsAboveLines(int value) => setFieldOfObject('pixels_above_lines', 9, value);
  int get pixelsBelowLines => getFieldOfObject('pixels_below_lines', 10);
  void set pixelsBelowLines(int value) => setFieldOfObject('pixels_below_lines', 10, value);
  int get pixelsInsideWrap => getFieldOfObject('pixels_inside_wrap', 11);
  void set pixelsInsideWrap(int value) => setFieldOfObject('pixels_inside_wrap', 11, value);
  TabArray get tabs => getFieldOfObject('tabs', 12);
  void set tabs(TabArray value) => setFieldOfObject('tabs', 12, value);
  WrapMode get wrapMode => getFieldOfObject('wrap_mode', 13);
  void set wrapMode(WrapMode value) => setFieldOfObject('wrap_mode', 13, value);
  Language get language => getFieldOfObject('language', 14);
  void set language(Language value) => setFieldOfObject('language', 14, value);
  Color get pgBgColor => getFieldOfObject('pg_bg_color', 15);
  int get invisible => getFieldOfObject('invisible', 16);
  void set invisible(int value) => setFieldOfObject('invisible', 16, value);
  int get bgFullHeight => getFieldOfObject('bg_full_height', 17);
  void set bgFullHeight(int value) => setFieldOfObject('bg_full_height', 17, value);
  int get editable => getFieldOfObject('editable', 18);
  void set editable(int value) => setFieldOfObject('editable', 18, value);
  int get noFallback => getFieldOfObject('no_fallback', 19);
  void set noFallback(int value) => setFieldOfObject('no_fallback', 19, value);
  RGBA get pgBgRgba => getFieldOfObject('pg_bg_rgba', 20);
  int get letterSpacing => getFieldOfObject('letter_spacing', 21);
  void set letterSpacing(int value) => setFieldOfObject('letter_spacing', 21, value);
  factory TextAttributes() => _staticInfo.callStatic('new', []);
  TextAttributes copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void copyValues(TextAttributes dest) => _staticInfo.callMethodOnReceiver('copy_values', this, [dest]);
  TextAttributes ref() => _staticInfo.callMethodOnReceiver('ref', this, []);
  void unref() => _staticInfo.callMethodOnReceiver('unref', this, []);
}

class TextBTree extends GObjectBase {
  TextBTree.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextBTree');

}

class TextBuffer extends GObjectObject {
  TextBuffer.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextBuffer');

  static const String COPY_TARGET_LIST_PROPERTY = 'copy-target-list';
  int get cursorPosition => _staticInfo.getGPropertyOnReceiver('cursor-position', this);
  static const String CURSOR_POSITION_PROPERTY = 'cursor-position';
  static const String HAS_SELECTION_PROPERTY = 'has-selection';
  static const String PASTE_TARGET_LIST_PROPERTY = 'paste-target-list';
  void set tagTable(TextTagTable value) => _staticInfo.setGPropertyOnReceiver('tag-table', this, value);
  static const String TAG_TABLE_PROPERTY = 'tag-table';
  static const String TEXT_PROPERTY = 'text';
  factory TextBuffer(TextTagTable table) => _staticInfo.callStatic('new', [table]);
  void addMark(TextMark mark, TextIter where) => _staticInfo.callMethodOnReceiver('add_mark', this, [mark, where]);
  void addSelectionClipboard(Clipboard clipboard) => _staticInfo.callMethodOnReceiver('add_selection_clipboard', this, [clipboard]);
  void applyTag(TextTag tag, TextIter start, TextIter end) => _staticInfo.callMethodOnReceiver('apply_tag', this, [tag, start, end]);
  void applyTagByName(String name, TextIter start, TextIter end) => _staticInfo.callMethodOnReceiver('apply_tag_by_name', this, [name, start, end]);
  bool backspace(TextIter iter, bool interactive, bool defaultEditable) => _staticInfo.callMethodOnReceiver('backspace', this, [iter, interactive, defaultEditable]);
  void beginUserAction() => _staticInfo.callMethodOnReceiver('begin_user_action', this, []);
  void copyClipboard(Clipboard clipboard) => _staticInfo.callMethodOnReceiver('copy_clipboard', this, [clipboard]);
  TextChildAnchor createChildAnchor(TextIter iter) => _staticInfo.callMethodOnReceiver('create_child_anchor', this, [iter]);
  TextMark createMark(String markName, TextIter where, bool leftGravity) => _staticInfo.callMethodOnReceiver('create_mark', this, [markName, where, leftGravity]);
  void cutClipboard(Clipboard clipboard, bool defaultEditable) => _staticInfo.callMethodOnReceiver('cut_clipboard', this, [clipboard, defaultEditable]);
  void delete(TextIter start, TextIter end) => _staticInfo.callMethodOnReceiver('delete', this, [start, end]);
  bool deleteInteractive(TextIter startIter, TextIter endIter, bool defaultEditable) => _staticInfo.callMethodOnReceiver('delete_interactive', this, [startIter, endIter, defaultEditable]);
  void deleteMark(TextMark mark) => _staticInfo.callMethodOnReceiver('delete_mark', this, [mark]);
  void deleteMarkByName(String name) => _staticInfo.callMethodOnReceiver('delete_mark_by_name', this, [name]);
  bool deleteSelection(bool interactive, bool defaultEditable) => _staticInfo.callMethodOnReceiver('delete_selection', this, [interactive, defaultEditable]);
  bool deserialize(TextBuffer contentBuffer, Atom format, TextIter iter, List<int> data) => _staticInfo.callMethodOnReceiver('deserialize', this, [contentBuffer, format, iter, data]);
  bool deserializeGetCanCreateTags(Atom format) => _staticInfo.callMethodOnReceiver('deserialize_get_can_create_tags', this, [format]);
  void deserializeSetCanCreateTags(Atom format, bool canCreateTags) => _staticInfo.callMethodOnReceiver('deserialize_set_can_create_tags', this, [format, canCreateTags]);
  void endUserAction() => _staticInfo.callMethodOnReceiver('end_user_action', this, []);
  void getBounds() => _staticInfo.callMethodOnReceiver('get_bounds', this, []);
  int getCharCount() => _staticInfo.callMethodOnReceiver('get_char_count', this, []);
  TargetList get copyTargetList => _staticInfo.callMethodOnReceiver('get_copy_target_list', this, []);
  List<Atom> getDeserializeFormats() => _staticInfo.callMethodOnReceiver('get_deserialize_formats', this, []);
  void getEndIter() => _staticInfo.callMethodOnReceiver('get_end_iter', this, []);
  bool get hasSelection => _staticInfo.callMethodOnReceiver('get_has_selection', this, []);
  TextMark getInsert() => _staticInfo.callMethodOnReceiver('get_insert', this, []);
  void getIterAtChildAnchor(TextChildAnchor anchor) => _staticInfo.callMethodOnReceiver('get_iter_at_child_anchor', this, [anchor]);
  void getIterAtLine(int lineNumber) => _staticInfo.callMethodOnReceiver('get_iter_at_line', this, [lineNumber]);
  void getIterAtLineIndex(int lineNumber, int byteIndex) => _staticInfo.callMethodOnReceiver('get_iter_at_line_index', this, [lineNumber, byteIndex]);
  void getIterAtLineOffset(int lineNumber, int charOffset) => _staticInfo.callMethodOnReceiver('get_iter_at_line_offset', this, [lineNumber, charOffset]);
  void getIterAtMark(TextMark mark) => _staticInfo.callMethodOnReceiver('get_iter_at_mark', this, [mark]);
  void getIterAtOffset(int charOffset) => _staticInfo.callMethodOnReceiver('get_iter_at_offset', this, [charOffset]);
  int getLineCount() => _staticInfo.callMethodOnReceiver('get_line_count', this, []);
  TextMark getMark(String name) => _staticInfo.callMethodOnReceiver('get_mark', this, [name]);
  bool getModified() => _staticInfo.callMethodOnReceiver('get_modified', this, []);
  TargetList get pasteTargetList => _staticInfo.callMethodOnReceiver('get_paste_target_list', this, []);
  TextMark getSelectionBound() => _staticInfo.callMethodOnReceiver('get_selection_bound', this, []);
  bool getSelectionBounds() => _staticInfo.callMethodOnReceiver('get_selection_bounds', this, []);
  List<Atom> getSerializeFormats() => _staticInfo.callMethodOnReceiver('get_serialize_formats', this, []);
  String getSlice(TextIter start, TextIter end, bool includeHiddenChars) => _staticInfo.callMethodOnReceiver('get_slice', this, [start, end, includeHiddenChars]);
  void getStartIter() => _staticInfo.callMethodOnReceiver('get_start_iter', this, []);
  TextTagTable get tagTable_ => _staticInfo.callMethodOnReceiver('get_tag_table', this, []);
  String getText(TextIter start, TextIter end, bool includeHiddenChars) => _staticInfo.callMethodOnReceiver('get_text', this, [start, end, includeHiddenChars]);
  void insert(TextIter iter, String text, int len) => _staticInfo.callMethodOnReceiver('insert', this, [iter, text, len]);
  void insertAtCursor(String text, int len) => _staticInfo.callMethodOnReceiver('insert_at_cursor', this, [text, len]);
  void insertChildAnchor(TextIter iter, TextChildAnchor anchor) => _staticInfo.callMethodOnReceiver('insert_child_anchor', this, [iter, anchor]);
  bool insertInteractive(TextIter iter, String text, int len, bool defaultEditable) => _staticInfo.callMethodOnReceiver('insert_interactive', this, [iter, text, len, defaultEditable]);
  bool insertInteractiveAtCursor(String text, int len, bool defaultEditable) => _staticInfo.callMethodOnReceiver('insert_interactive_at_cursor', this, [text, len, defaultEditable]);
  void insertMarkup(TextIter iter, String markup, int len) => _staticInfo.callMethodOnReceiver('insert_markup', this, [iter, markup, len]);
  void insertPixbuf(TextIter iter, Pixbuf pixbuf) => _staticInfo.callMethodOnReceiver('insert_pixbuf', this, [iter, pixbuf]);
  void insertRange(TextIter iter, TextIter start, TextIter end) => _staticInfo.callMethodOnReceiver('insert_range', this, [iter, start, end]);
  bool insertRangeInteractive(TextIter iter, TextIter start, TextIter end, bool defaultEditable) => _staticInfo.callMethodOnReceiver('insert_range_interactive', this, [iter, start, end, defaultEditable]);
  void moveMark(TextMark mark, TextIter where) => _staticInfo.callMethodOnReceiver('move_mark', this, [mark, where]);
  void moveMarkByName(String name, TextIter where) => _staticInfo.callMethodOnReceiver('move_mark_by_name', this, [name, where]);
  void pasteClipboard(Clipboard clipboard, TextIter overrideLocation, bool defaultEditable) => _staticInfo.callMethodOnReceiver('paste_clipboard', this, [clipboard, overrideLocation, defaultEditable]);
  void placeCursor(TextIter where) => _staticInfo.callMethodOnReceiver('place_cursor', this, [where]);
  Atom registerDeserializeFormat(String mimeType, TextBufferDeserializeFunc function) => _staticInfo.callMethodOnReceiver('register_deserialize_format', this, [mimeType, function]);
  Atom registerDeserializeTagset(String tagsetName) => _staticInfo.callMethodOnReceiver('register_deserialize_tagset', this, [tagsetName]);
  Atom registerSerializeFormat(String mimeType, TextBufferSerializeFunc function) => _staticInfo.callMethodOnReceiver('register_serialize_format', this, [mimeType, function]);
  Atom registerSerializeTagset(String tagsetName) => _staticInfo.callMethodOnReceiver('register_serialize_tagset', this, [tagsetName]);
  void removeAllTags(TextIter start, TextIter end) => _staticInfo.callMethodOnReceiver('remove_all_tags', this, [start, end]);
  void removeSelectionClipboard(Clipboard clipboard) => _staticInfo.callMethodOnReceiver('remove_selection_clipboard', this, [clipboard]);
  void removeTag(TextTag tag, TextIter start, TextIter end) => _staticInfo.callMethodOnReceiver('remove_tag', this, [tag, start, end]);
  void removeTagByName(String name, TextIter start, TextIter end) => _staticInfo.callMethodOnReceiver('remove_tag_by_name', this, [name, start, end]);
  void selectRange(TextIter ins, TextIter bound) => _staticInfo.callMethodOnReceiver('select_range', this, [ins, bound]);
  List<int> serialize(TextBuffer contentBuffer, Atom format, TextIter start, TextIter end) => _staticInfo.callMethodOnReceiver('serialize', this, [contentBuffer, format, start, end]);
  void setModified(bool setting) => _staticInfo.callMethodOnReceiver('set_modified', this, [setting]);
  void setText(String text, int len) => _staticInfo.callMethodOnReceiver('set_text', this, [text, len]);
  void unregisterDeserializeFormat(Atom format) => _staticInfo.callMethodOnReceiver('unregister_deserialize_format', this, [format]);
  void unregisterSerializeFormat(Atom format) => _staticInfo.callMethodOnReceiver('unregister_serialize_format', this, [format]);
  int _connectToApplyTag(bool after, void func(TextTag tag, TextIter start, TextIter end)) => signalConnect('apply-tag', func, after);
  Stream<TextBufferApplyTagEvent> get onApplyTag {
    int signalId;
    StreamController<TextBufferApplyTagEvent> controller;
    controller = new StreamController<TextBufferApplyTagEvent>(
      onListen: () {
          signalId = _connectToApplyTag(false, (TextTag tag, TextIter start, TextIter end) {
              var result = new TextBufferApplyTagEvent(tag, start, end);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextBufferApplyTagEvent> get afterApplyTag {
    int signalId;
    StreamController<TextBufferApplyTagEvent> controller;
    controller = new StreamController<TextBufferApplyTagEvent>(
      onListen: () {
          signalId = _connectToApplyTag(true, (TextTag tag, TextIter start, TextIter end) {
              var result = new TextBufferApplyTagEvent(tag, start, end);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToBeginUserAction(bool after, void func()) => signalConnect('begin-user-action', func, after);
  Stream get onBeginUserAction {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToBeginUserAction(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterBeginUserAction {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToBeginUserAction(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToChanged(bool after, void func()) => signalConnect('changed', func, after);
  Stream get onChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDeleteRange(bool after, void func(TextIter start, TextIter end)) => signalConnect('delete-range', func, after);
  Stream<TextBufferDeleteRangeEvent> get onDeleteRange {
    int signalId;
    StreamController<TextBufferDeleteRangeEvent> controller;
    controller = new StreamController<TextBufferDeleteRangeEvent>(
      onListen: () {
          signalId = _connectToDeleteRange(false, (TextIter start, TextIter end) {
              var result = new TextBufferDeleteRangeEvent(start, end);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextBufferDeleteRangeEvent> get afterDeleteRange {
    int signalId;
    StreamController<TextBufferDeleteRangeEvent> controller;
    controller = new StreamController<TextBufferDeleteRangeEvent>(
      onListen: () {
          signalId = _connectToDeleteRange(true, (TextIter start, TextIter end) {
              var result = new TextBufferDeleteRangeEvent(start, end);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToEndUserAction(bool after, void func()) => signalConnect('end-user-action', func, after);
  Stream get onEndUserAction {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToEndUserAction(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterEndUserAction {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToEndUserAction(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToInsertChildAnchor(bool after, void func(TextIter location, TextChildAnchor anchor)) => signalConnect('insert-child-anchor', func, after);
  Stream<TextBufferInsertChildAnchorEvent> get onInsertChildAnchor {
    int signalId;
    StreamController<TextBufferInsertChildAnchorEvent> controller;
    controller = new StreamController<TextBufferInsertChildAnchorEvent>(
      onListen: () {
          signalId = _connectToInsertChildAnchor(false, (TextIter location, TextChildAnchor anchor) {
              var result = new TextBufferInsertChildAnchorEvent(location, anchor);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextBufferInsertChildAnchorEvent> get afterInsertChildAnchor {
    int signalId;
    StreamController<TextBufferInsertChildAnchorEvent> controller;
    controller = new StreamController<TextBufferInsertChildAnchorEvent>(
      onListen: () {
          signalId = _connectToInsertChildAnchor(true, (TextIter location, TextChildAnchor anchor) {
              var result = new TextBufferInsertChildAnchorEvent(location, anchor);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToInsertPixbuf(bool after, void func(TextIter location, Pixbuf pixbuf)) => signalConnect('insert-pixbuf', func, after);
  Stream<TextBufferInsertPixbufEvent> get onInsertPixbuf {
    int signalId;
    StreamController<TextBufferInsertPixbufEvent> controller;
    controller = new StreamController<TextBufferInsertPixbufEvent>(
      onListen: () {
          signalId = _connectToInsertPixbuf(false, (TextIter location, Pixbuf pixbuf) {
              var result = new TextBufferInsertPixbufEvent(location, pixbuf);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextBufferInsertPixbufEvent> get afterInsertPixbuf {
    int signalId;
    StreamController<TextBufferInsertPixbufEvent> controller;
    controller = new StreamController<TextBufferInsertPixbufEvent>(
      onListen: () {
          signalId = _connectToInsertPixbuf(true, (TextIter location, Pixbuf pixbuf) {
              var result = new TextBufferInsertPixbufEvent(location, pixbuf);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToInsertText(bool after, void func(TextIter location, String text, int len)) => signalConnect('insert-text', func, after);
  Stream<TextBufferInsertTextEvent> get onInsertText {
    int signalId;
    StreamController<TextBufferInsertTextEvent> controller;
    controller = new StreamController<TextBufferInsertTextEvent>(
      onListen: () {
          signalId = _connectToInsertText(false, (TextIter location, String text, int len) {
              var result = new TextBufferInsertTextEvent(location, text, len);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextBufferInsertTextEvent> get afterInsertText {
    int signalId;
    StreamController<TextBufferInsertTextEvent> controller;
    controller = new StreamController<TextBufferInsertTextEvent>(
      onListen: () {
          signalId = _connectToInsertText(true, (TextIter location, String text, int len) {
              var result = new TextBufferInsertTextEvent(location, text, len);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMarkDeleted(bool after, void func(TextMark mark)) => signalConnect('mark-deleted', func, after);
  Stream<TextMark> get onMarkDeleted {
    int signalId;
    StreamController<TextMark> controller;
    controller = new StreamController<TextMark>(
      onListen: () {
          signalId = _connectToMarkDeleted(false, (TextMark mark) {
              controller.add(mark);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextMark> get afterMarkDeleted {
    int signalId;
    StreamController<TextMark> controller;
    controller = new StreamController<TextMark>(
      onListen: () {
          signalId = _connectToMarkDeleted(true, (TextMark mark) {
              controller.add(mark);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMarkSet(bool after, void func(TextIter location, TextMark mark)) => signalConnect('mark-set', func, after);
  Stream<TextBufferMarkSetEvent> get onMarkSet {
    int signalId;
    StreamController<TextBufferMarkSetEvent> controller;
    controller = new StreamController<TextBufferMarkSetEvent>(
      onListen: () {
          signalId = _connectToMarkSet(false, (TextIter location, TextMark mark) {
              var result = new TextBufferMarkSetEvent(location, mark);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextBufferMarkSetEvent> get afterMarkSet {
    int signalId;
    StreamController<TextBufferMarkSetEvent> controller;
    controller = new StreamController<TextBufferMarkSetEvent>(
      onListen: () {
          signalId = _connectToMarkSet(true, (TextIter location, TextMark mark) {
              var result = new TextBufferMarkSetEvent(location, mark);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToModifiedChanged(bool after, void func()) => signalConnect('modified-changed', func, after);
  Stream get onModifiedChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToModifiedChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterModifiedChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToModifiedChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPasteDone(bool after, void func(Clipboard clipboard)) => signalConnect('paste-done', func, after);
  Stream<Clipboard> get onPasteDone {
    int signalId;
    StreamController<Clipboard> controller;
    controller = new StreamController<Clipboard>(
      onListen: () {
          signalId = _connectToPasteDone(false, (Clipboard clipboard) {
              controller.add(clipboard);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Clipboard> get afterPasteDone {
    int signalId;
    StreamController<Clipboard> controller;
    controller = new StreamController<Clipboard>(
      onListen: () {
          signalId = _connectToPasteDone(true, (Clipboard clipboard) {
              controller.add(clipboard);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRemoveTag(bool after, void func(TextTag tag, TextIter start, TextIter end)) => signalConnect('remove-tag', func, after);
  Stream<TextBufferRemoveTagEvent> get onRemoveTag {
    int signalId;
    StreamController<TextBufferRemoveTagEvent> controller;
    controller = new StreamController<TextBufferRemoveTagEvent>(
      onListen: () {
          signalId = _connectToRemoveTag(false, (TextTag tag, TextIter start, TextIter end) {
              var result = new TextBufferRemoveTagEvent(tag, start, end);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextBufferRemoveTagEvent> get afterRemoveTag {
    int signalId;
    StreamController<TextBufferRemoveTagEvent> controller;
    controller = new StreamController<TextBufferRemoveTagEvent>(
      onListen: () {
          signalId = _connectToRemoveTag(true, (TextTag tag, TextIter start, TextIter end) {
              var result = new TextBufferRemoveTagEvent(tag, start, end);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class TextBufferApplyTagEvent {
  final TextTag tag;
  final TextIter start;
  final TextIter end;

  TextBufferApplyTagEvent(this.tag, this.start, this.end);
}

class TextBufferDeleteRangeEvent {
  final TextIter start;
  final TextIter end;

  TextBufferDeleteRangeEvent(this.start, this.end);
}

class TextBufferInsertChildAnchorEvent {
  final TextIter location;
  final TextChildAnchor anchor;

  TextBufferInsertChildAnchorEvent(this.location, this.anchor);
}

class TextBufferInsertPixbufEvent {
  final TextIter location;
  final Pixbuf pixbuf;

  TextBufferInsertPixbufEvent(this.location, this.pixbuf);
}

class TextBufferInsertTextEvent {
  final TextIter location;
  final String text;
  final int len;

  TextBufferInsertTextEvent(this.location, this.text, this.len);
}

class TextBufferMarkSetEvent {
  final TextIter location;
  final TextMark mark;

  TextBufferMarkSetEvent(this.location, this.mark);
}

class TextBufferRemoveTagEvent {
  final TextTag tag;
  final TextIter start;
  final TextIter end;

  TextBufferRemoveTagEvent(this.tag, this.start, this.end);
}

typedef void TextBufferDeserializeFunc(TextBuffer registerBuffer, TextBuffer contentBuffer, TextIter iter, List<int> data, bool createTags);
typedef int TextBufferSerializeFunc(TextBuffer registerBuffer, TextBuffer contentBuffer, TextIter start, TextIter end, int length);
class TextBufferTargetInfo extends GEnumBase {
  const TextBufferTargetInfo(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextBufferTargetInfo');

  static const TextBufferTargetInfo BUFFER_CONTENTS = const TextBufferTargetInfo(-1);
  static const TextBufferTargetInfo RICH_TEXT = const TextBufferTargetInfo(-2);
  static const TextBufferTargetInfo TEXT = const TextBufferTargetInfo(-3);
  String toString() {
    switch(index) {
      case -1: return 'TextBufferTargetInfo.BUFFER_CONTENTS';
      case -2: return 'TextBufferTargetInfo.RICH_TEXT';
      case -3: return 'TextBufferTargetInfo.TEXT';
      default: return 'new TextBufferTargetInfo($index)';
    }
  }
}

class TextCellAccessible extends RendererCellAccessible with atk.Action, Component, Text {
  TextCellAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextCellAccessible');

}

typedef bool TextCharPredicate(int ch);
class TextChildAnchor extends GObjectObject {
  TextChildAnchor.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextChildAnchor');

  factory TextChildAnchor() => _staticInfo.callStatic('new', []);
  bool getDeleted() => _staticInfo.callMethodOnReceiver('get_deleted', this, []);
  GLibList /* this will fail */ getWidgets() => _staticInfo.callMethodOnReceiver('get_widgets', this, []);
}

class TextDirection extends GEnumBase {
  const TextDirection(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextDirection');

  static const TextDirection NONE = const TextDirection(0);
  static const TextDirection LTR = const TextDirection(1);
  static const TextDirection RTL = const TextDirection(2);
  String toString() {
    switch(index) {
      case 0: return 'TextDirection.NONE';
      case 1: return 'TextDirection.LTR';
      case 2: return 'TextDirection.RTL';
      default: return 'new TextDirection($index)';
    }
  }
}

class TextExtendSelection extends GEnumBase {
  const TextExtendSelection(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextExtendSelection');

  static const TextExtendSelection WORD = const TextExtendSelection(0);
  static const TextExtendSelection LINE = const TextExtendSelection(1);
  String toString() {
    switch(index) {
      case 0: return 'TextExtendSelection.WORD';
      case 1: return 'TextExtendSelection.LINE';
      default: return 'new TextExtendSelection($index)';
    }
  }
}

class TextIter extends GObjectBase {
  TextIter.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextIter');

  dynamic /* this will fail */ get dummy1 => getFieldOfObject('dummy1', 0);
  dynamic /* this will fail */ get dummy2 => getFieldOfObject('dummy2', 1);
  int get dummy3 => getFieldOfObject('dummy3', 2);
  int get dummy4 => getFieldOfObject('dummy4', 3);
  int get dummy5 => getFieldOfObject('dummy5', 4);
  int get dummy6 => getFieldOfObject('dummy6', 5);
  int get dummy7 => getFieldOfObject('dummy7', 6);
  int get dummy8 => getFieldOfObject('dummy8', 7);
  dynamic /* this will fail */ get dummy9 => getFieldOfObject('dummy9', 8);
  dynamic /* this will fail */ get dummy10 => getFieldOfObject('dummy10', 9);
  int get dummy11 => getFieldOfObject('dummy11', 10);
  int get dummy12 => getFieldOfObject('dummy12', 11);
  int get dummy13 => getFieldOfObject('dummy13', 12);
  dynamic /* this will fail */ get dummy14 => getFieldOfObject('dummy14', 13);
  void assign(TextIter other) => _staticInfo.callMethodOnReceiver('assign', this, [other]);
  bool backwardChar() => _staticInfo.callMethodOnReceiver('backward_char', this, []);
  bool backwardChars(int count) => _staticInfo.callMethodOnReceiver('backward_chars', this, [count]);
  bool backwardCursorPosition() => _staticInfo.callMethodOnReceiver('backward_cursor_position', this, []);
  bool backwardCursorPositions(int count) => _staticInfo.callMethodOnReceiver('backward_cursor_positions', this, [count]);
  bool backwardFindChar(TextCharPredicate pred, TextIter limit) => _staticInfo.callMethodOnReceiver('backward_find_char', this, [pred, limit]);
  bool backwardLine() => _staticInfo.callMethodOnReceiver('backward_line', this, []);
  bool backwardLines(int count) => _staticInfo.callMethodOnReceiver('backward_lines', this, [count]);
  bool backwardSearch(String str, TextSearchFlags flags, TextIter limit) => _staticInfo.callMethodOnReceiver('backward_search', this, [str, flags, limit]);
  bool backwardSentenceStart() => _staticInfo.callMethodOnReceiver('backward_sentence_start', this, []);
  bool backwardSentenceStarts(int count) => _staticInfo.callMethodOnReceiver('backward_sentence_starts', this, [count]);
  bool backwardToTagToggle(TextTag tag) => _staticInfo.callMethodOnReceiver('backward_to_tag_toggle', this, [tag]);
  bool backwardVisibleCursorPosition() => _staticInfo.callMethodOnReceiver('backward_visible_cursor_position', this, []);
  bool backwardVisibleCursorPositions(int count) => _staticInfo.callMethodOnReceiver('backward_visible_cursor_positions', this, [count]);
  bool backwardVisibleLine() => _staticInfo.callMethodOnReceiver('backward_visible_line', this, []);
  bool backwardVisibleLines(int count) => _staticInfo.callMethodOnReceiver('backward_visible_lines', this, [count]);
  bool backwardVisibleWordStart() => _staticInfo.callMethodOnReceiver('backward_visible_word_start', this, []);
  bool backwardVisibleWordStarts(int count) => _staticInfo.callMethodOnReceiver('backward_visible_word_starts', this, [count]);
  bool backwardWordStart() => _staticInfo.callMethodOnReceiver('backward_word_start', this, []);
  bool backwardWordStarts(int count) => _staticInfo.callMethodOnReceiver('backward_word_starts', this, [count]);
  bool beginsTag(TextTag tag) => _staticInfo.callMethodOnReceiver('begins_tag', this, [tag]);
  bool canInsert(bool defaultEditability) => _staticInfo.callMethodOnReceiver('can_insert', this, [defaultEditability]);
  int compare(TextIter rhs) => _staticInfo.callMethodOnReceiver('compare', this, [rhs]);
  TextIter copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  bool editable(bool defaultSetting) => _staticInfo.callMethodOnReceiver('editable', this, [defaultSetting]);
  bool endsLine() => _staticInfo.callMethodOnReceiver('ends_line', this, []);
  bool endsSentence() => _staticInfo.callMethodOnReceiver('ends_sentence', this, []);
  bool endsTag(TextTag tag) => _staticInfo.callMethodOnReceiver('ends_tag', this, [tag]);
  bool endsWord() => _staticInfo.callMethodOnReceiver('ends_word', this, []);
  bool equal(TextIter rhs) => _staticInfo.callMethodOnReceiver('equal', this, [rhs]);
  bool forwardChar() => _staticInfo.callMethodOnReceiver('forward_char', this, []);
  bool forwardChars(int count) => _staticInfo.callMethodOnReceiver('forward_chars', this, [count]);
  bool forwardCursorPosition() => _staticInfo.callMethodOnReceiver('forward_cursor_position', this, []);
  bool forwardCursorPositions(int count) => _staticInfo.callMethodOnReceiver('forward_cursor_positions', this, [count]);
  bool forwardFindChar(TextCharPredicate pred, TextIter limit) => _staticInfo.callMethodOnReceiver('forward_find_char', this, [pred, limit]);
  bool forwardLine() => _staticInfo.callMethodOnReceiver('forward_line', this, []);
  bool forwardLines(int count) => _staticInfo.callMethodOnReceiver('forward_lines', this, [count]);
  bool forwardSearch(String str, TextSearchFlags flags, TextIter limit) => _staticInfo.callMethodOnReceiver('forward_search', this, [str, flags, limit]);
  bool forwardSentenceEnd() => _staticInfo.callMethodOnReceiver('forward_sentence_end', this, []);
  bool forwardSentenceEnds(int count) => _staticInfo.callMethodOnReceiver('forward_sentence_ends', this, [count]);
  void forwardToEnd() => _staticInfo.callMethodOnReceiver('forward_to_end', this, []);
  bool forwardToLineEnd() => _staticInfo.callMethodOnReceiver('forward_to_line_end', this, []);
  bool forwardToTagToggle(TextTag tag) => _staticInfo.callMethodOnReceiver('forward_to_tag_toggle', this, [tag]);
  bool forwardVisibleCursorPosition() => _staticInfo.callMethodOnReceiver('forward_visible_cursor_position', this, []);
  bool forwardVisibleCursorPositions(int count) => _staticInfo.callMethodOnReceiver('forward_visible_cursor_positions', this, [count]);
  bool forwardVisibleLine() => _staticInfo.callMethodOnReceiver('forward_visible_line', this, []);
  bool forwardVisibleLines(int count) => _staticInfo.callMethodOnReceiver('forward_visible_lines', this, [count]);
  bool forwardVisibleWordEnd() => _staticInfo.callMethodOnReceiver('forward_visible_word_end', this, []);
  bool forwardVisibleWordEnds(int count) => _staticInfo.callMethodOnReceiver('forward_visible_word_ends', this, [count]);
  bool forwardWordEnd() => _staticInfo.callMethodOnReceiver('forward_word_end', this, []);
  bool forwardWordEnds(int count) => _staticInfo.callMethodOnReceiver('forward_word_ends', this, [count]);
  void free() => _staticInfo.callMethodOnReceiver('free', this, []);
  bool getAttributes() => _staticInfo.callMethodOnReceiver('get_attributes', this, []);
  TextBuffer getBuffer() => _staticInfo.callMethodOnReceiver('get_buffer', this, []);
  int getBytesInLine() => _staticInfo.callMethodOnReceiver('get_bytes_in_line', this, []);
  int getChar() => _staticInfo.callMethodOnReceiver('get_char', this, []);
  int getCharsInLine() => _staticInfo.callMethodOnReceiver('get_chars_in_line', this, []);
  TextChildAnchor getChildAnchor() => _staticInfo.callMethodOnReceiver('get_child_anchor', this, []);
  Language getLanguage() => _staticInfo.callMethodOnReceiver('get_language', this, []);
  int getLine() => _staticInfo.callMethodOnReceiver('get_line', this, []);
  int getLineIndex() => _staticInfo.callMethodOnReceiver('get_line_index', this, []);
  int getLineOffset() => _staticInfo.callMethodOnReceiver('get_line_offset', this, []);
  SList /* this will fail */ getMarks() => _staticInfo.callMethodOnReceiver('get_marks', this, []);
  int getOffset() => _staticInfo.callMethodOnReceiver('get_offset', this, []);
  Pixbuf getPixbuf() => _staticInfo.callMethodOnReceiver('get_pixbuf', this, []);
  String getSlice(TextIter end) => _staticInfo.callMethodOnReceiver('get_slice', this, [end]);
  SList /* this will fail */ getTags() => _staticInfo.callMethodOnReceiver('get_tags', this, []);
  String getText(TextIter end) => _staticInfo.callMethodOnReceiver('get_text', this, [end]);
  SList /* this will fail */ getToggledTags(bool toggledOn) => _staticInfo.callMethodOnReceiver('get_toggled_tags', this, [toggledOn]);
  int getVisibleLineIndex() => _staticInfo.callMethodOnReceiver('get_visible_line_index', this, []);
  int getVisibleLineOffset() => _staticInfo.callMethodOnReceiver('get_visible_line_offset', this, []);
  String getVisibleSlice(TextIter end) => _staticInfo.callMethodOnReceiver('get_visible_slice', this, [end]);
  String getVisibleText(TextIter end) => _staticInfo.callMethodOnReceiver('get_visible_text', this, [end]);
  bool hasTag(TextTag tag) => _staticInfo.callMethodOnReceiver('has_tag', this, [tag]);
  bool inRange(TextIter start, TextIter end) => _staticInfo.callMethodOnReceiver('in_range', this, [start, end]);
  bool insideSentence() => _staticInfo.callMethodOnReceiver('inside_sentence', this, []);
  bool insideWord() => _staticInfo.callMethodOnReceiver('inside_word', this, []);
  bool isCursorPosition() => _staticInfo.callMethodOnReceiver('is_cursor_position', this, []);
  bool isEnd() => _staticInfo.callMethodOnReceiver('is_end', this, []);
  bool isStart() => _staticInfo.callMethodOnReceiver('is_start', this, []);
  void order(TextIter second) => _staticInfo.callMethodOnReceiver('order', this, [second]);
  void setLine(int lineNumber) => _staticInfo.callMethodOnReceiver('set_line', this, [lineNumber]);
  void setLineIndex(int byteOnLine) => _staticInfo.callMethodOnReceiver('set_line_index', this, [byteOnLine]);
  void setLineOffset(int charOnLine) => _staticInfo.callMethodOnReceiver('set_line_offset', this, [charOnLine]);
  void setOffset(int charOffset) => _staticInfo.callMethodOnReceiver('set_offset', this, [charOffset]);
  void setVisibleLineIndex(int byteOnLine) => _staticInfo.callMethodOnReceiver('set_visible_line_index', this, [byteOnLine]);
  void setVisibleLineOffset(int charOnLine) => _staticInfo.callMethodOnReceiver('set_visible_line_offset', this, [charOnLine]);
  bool startsLine() => _staticInfo.callMethodOnReceiver('starts_line', this, []);
  bool startsSentence() => _staticInfo.callMethodOnReceiver('starts_sentence', this, []);
  bool startsWord() => _staticInfo.callMethodOnReceiver('starts_word', this, []);
  bool togglesTag(TextTag tag) => _staticInfo.callMethodOnReceiver('toggles_tag', this, [tag]);
}

class TextMark extends GObjectObject {
  TextMark.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextMark');

  void set leftGravity(bool value) => _staticInfo.setGPropertyOnReceiver('left-gravity', this, value);
  static const String LEFT_GRAVITY_PROPERTY = 'left-gravity';
  void set name(String value) => _staticInfo.setGPropertyOnReceiver('name', this, value);
  static const String NAME_PROPERTY = 'name';
  factory TextMark(String name, bool leftGravity) => _staticInfo.callStatic('new', [name, leftGravity]);
  TextBuffer getBuffer() => _staticInfo.callMethodOnReceiver('get_buffer', this, []);
  bool getDeleted() => _staticInfo.callMethodOnReceiver('get_deleted', this, []);
  bool get leftGravity_ => _staticInfo.callMethodOnReceiver('get_left_gravity', this, []);
  String get name_ => _staticInfo.callMethodOnReceiver('get_name', this, []);
  bool getVisible() => _staticInfo.callMethodOnReceiver('get_visible', this, []);
  void setVisible(bool setting) => _staticInfo.callMethodOnReceiver('set_visible', this, [setting]);
}

class TextSearchFlags extends GEnumBase {
  const TextSearchFlags(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextSearchFlags');

  static const TextSearchFlags NULL = const TextSearchFlags(0);
  static const TextSearchFlags VISIBLE_ONLY = const TextSearchFlags(1);
  bool get visibleOnly => (index & 1) == 1;
  static const TextSearchFlags TEXT_ONLY = const TextSearchFlags(2);
  bool get textOnly => (index & 2) == 2;
  static const TextSearchFlags CASE_INSENSITIVE = const TextSearchFlags(4);
  bool get caseInsensitive => (index & 4) == 4;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'TextSearchFlags.VISIBLE_ONLY';
      case 2: return 'TextSearchFlags.TEXT_ONLY';
      case 4: return 'TextSearchFlags.CASE_INSENSITIVE';
      default: return 'new TextSearchFlags($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'TextSearchFlags.NULL';
    }
    List codes = [];
    for (var i=1; i <= 4; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  TextSearchFlags operator|(TextSearchFlags other) =>
    new TextSearchFlags(index | other.index);
  TextSearchFlags operator&(TextSearchFlags other) =>
    new TextSearchFlags(index & other.index);
}

class TextTag extends GObjectObject {
  TextTag.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextTag');

  bool get accumulativeMargin => _staticInfo.getGPropertyOnReceiver('accumulative-margin', this);
  void set accumulativeMargin(bool value) => _staticInfo.setGPropertyOnReceiver('accumulative-margin', this, value);
  static const String ACCUMULATIVE_MARGIN_PROPERTY = 'accumulative-margin';
  void set background(String value) => _staticInfo.setGPropertyOnReceiver('background', this, value);
  static const String BACKGROUND_PROPERTY = 'background';
  bool get backgroundFullHeight => _staticInfo.getGPropertyOnReceiver('background-full-height', this);
  void set backgroundFullHeight(bool value) => _staticInfo.setGPropertyOnReceiver('background-full-height', this, value);
  static const String BACKGROUND_FULL_HEIGHT_PROPERTY = 'background-full-height';
  bool get backgroundFullHeightSet => _staticInfo.getGPropertyOnReceiver('background-full-height-set', this);
  void set backgroundFullHeightSet(bool value) => _staticInfo.setGPropertyOnReceiver('background-full-height-set', this, value);
  static const String BACKGROUND_FULL_HEIGHT_SET_PROPERTY = 'background-full-height-set';
  Color get backgroundGdk => _staticInfo.getGPropertyOnReceiver('background-gdk', this);
  void set backgroundGdk(Color value) => _staticInfo.setGPropertyOnReceiver('background-gdk', this, value);
  static const String BACKGROUND_GDK_PROPERTY = 'background-gdk';
  RGBA get backgroundRgba => _staticInfo.getGPropertyOnReceiver('background-rgba', this);
  void set backgroundRgba(RGBA value) => _staticInfo.setGPropertyOnReceiver('background-rgba', this, value);
  static const String BACKGROUND_RGBA_PROPERTY = 'background-rgba';
  bool get backgroundSet => _staticInfo.getGPropertyOnReceiver('background-set', this);
  void set backgroundSet(bool value) => _staticInfo.setGPropertyOnReceiver('background-set', this, value);
  static const String BACKGROUND_SET_PROPERTY = 'background-set';
  TextDirection get direction => _staticInfo.getGPropertyOnReceiver('direction', this);
  void set direction(TextDirection value) => _staticInfo.setGPropertyOnReceiver('direction', this, value);
  static const String DIRECTION_PROPERTY = 'direction';
  bool get editable => _staticInfo.getGPropertyOnReceiver('editable', this);
  void set editable(bool value) => _staticInfo.setGPropertyOnReceiver('editable', this, value);
  static const String EDITABLE_PROPERTY = 'editable';
  bool get editableSet => _staticInfo.getGPropertyOnReceiver('editable-set', this);
  void set editableSet(bool value) => _staticInfo.setGPropertyOnReceiver('editable-set', this, value);
  static const String EDITABLE_SET_PROPERTY = 'editable-set';
  bool get fallback => _staticInfo.getGPropertyOnReceiver('fallback', this);
  void set fallback(bool value) => _staticInfo.setGPropertyOnReceiver('fallback', this, value);
  static const String FALLBACK_PROPERTY = 'fallback';
  bool get fallbackSet => _staticInfo.getGPropertyOnReceiver('fallback-set', this);
  void set fallbackSet(bool value) => _staticInfo.setGPropertyOnReceiver('fallback-set', this, value);
  static const String FALLBACK_SET_PROPERTY = 'fallback-set';
  String get family => _staticInfo.getGPropertyOnReceiver('family', this);
  void set family(String value) => _staticInfo.setGPropertyOnReceiver('family', this, value);
  static const String FAMILY_PROPERTY = 'family';
  bool get familySet => _staticInfo.getGPropertyOnReceiver('family-set', this);
  void set familySet(bool value) => _staticInfo.setGPropertyOnReceiver('family-set', this, value);
  static const String FAMILY_SET_PROPERTY = 'family-set';
  String get font => _staticInfo.getGPropertyOnReceiver('font', this);
  void set font(String value) => _staticInfo.setGPropertyOnReceiver('font', this, value);
  static const String FONT_PROPERTY = 'font';
  FontDescription get fontDesc => _staticInfo.getGPropertyOnReceiver('font-desc', this);
  void set fontDesc(FontDescription value) => _staticInfo.setGPropertyOnReceiver('font-desc', this, value);
  static const String FONT_DESC_PROPERTY = 'font-desc';
  String get fontFeatures => _staticInfo.getGPropertyOnReceiver('font-features', this);
  void set fontFeatures(String value) => _staticInfo.setGPropertyOnReceiver('font-features', this, value);
  static const String FONT_FEATURES_PROPERTY = 'font-features';
  bool get fontFeaturesSet => _staticInfo.getGPropertyOnReceiver('font-features-set', this);
  void set fontFeaturesSet(bool value) => _staticInfo.setGPropertyOnReceiver('font-features-set', this, value);
  static const String FONT_FEATURES_SET_PROPERTY = 'font-features-set';
  void set foreground(String value) => _staticInfo.setGPropertyOnReceiver('foreground', this, value);
  static const String FOREGROUND_PROPERTY = 'foreground';
  Color get foregroundGdk => _staticInfo.getGPropertyOnReceiver('foreground-gdk', this);
  void set foregroundGdk(Color value) => _staticInfo.setGPropertyOnReceiver('foreground-gdk', this, value);
  static const String FOREGROUND_GDK_PROPERTY = 'foreground-gdk';
  RGBA get foregroundRgba => _staticInfo.getGPropertyOnReceiver('foreground-rgba', this);
  void set foregroundRgba(RGBA value) => _staticInfo.setGPropertyOnReceiver('foreground-rgba', this, value);
  static const String FOREGROUND_RGBA_PROPERTY = 'foreground-rgba';
  bool get foregroundSet => _staticInfo.getGPropertyOnReceiver('foreground-set', this);
  void set foregroundSet(bool value) => _staticInfo.setGPropertyOnReceiver('foreground-set', this, value);
  static const String FOREGROUND_SET_PROPERTY = 'foreground-set';
  int get indent => _staticInfo.getGPropertyOnReceiver('indent', this);
  void set indent(int value) => _staticInfo.setGPropertyOnReceiver('indent', this, value);
  static const String INDENT_PROPERTY = 'indent';
  bool get indentSet => _staticInfo.getGPropertyOnReceiver('indent-set', this);
  void set indentSet(bool value) => _staticInfo.setGPropertyOnReceiver('indent-set', this, value);
  static const String INDENT_SET_PROPERTY = 'indent-set';
  bool get invisible => _staticInfo.getGPropertyOnReceiver('invisible', this);
  void set invisible(bool value) => _staticInfo.setGPropertyOnReceiver('invisible', this, value);
  static const String INVISIBLE_PROPERTY = 'invisible';
  bool get invisibleSet => _staticInfo.getGPropertyOnReceiver('invisible-set', this);
  void set invisibleSet(bool value) => _staticInfo.setGPropertyOnReceiver('invisible-set', this, value);
  static const String INVISIBLE_SET_PROPERTY = 'invisible-set';
  Justification get justification => _staticInfo.getGPropertyOnReceiver('justification', this);
  void set justification(Justification value) => _staticInfo.setGPropertyOnReceiver('justification', this, value);
  static const String JUSTIFICATION_PROPERTY = 'justification';
  bool get justificationSet => _staticInfo.getGPropertyOnReceiver('justification-set', this);
  void set justificationSet(bool value) => _staticInfo.setGPropertyOnReceiver('justification-set', this, value);
  static const String JUSTIFICATION_SET_PROPERTY = 'justification-set';
  String get language => _staticInfo.getGPropertyOnReceiver('language', this);
  void set language(String value) => _staticInfo.setGPropertyOnReceiver('language', this, value);
  static const String LANGUAGE_PROPERTY = 'language';
  bool get languageSet => _staticInfo.getGPropertyOnReceiver('language-set', this);
  void set languageSet(bool value) => _staticInfo.setGPropertyOnReceiver('language-set', this, value);
  static const String LANGUAGE_SET_PROPERTY = 'language-set';
  int get leftMargin => _staticInfo.getGPropertyOnReceiver('left-margin', this);
  void set leftMargin(int value) => _staticInfo.setGPropertyOnReceiver('left-margin', this, value);
  static const String LEFT_MARGIN_PROPERTY = 'left-margin';
  bool get leftMarginSet => _staticInfo.getGPropertyOnReceiver('left-margin-set', this);
  void set leftMarginSet(bool value) => _staticInfo.setGPropertyOnReceiver('left-margin-set', this, value);
  static const String LEFT_MARGIN_SET_PROPERTY = 'left-margin-set';
  int get letterSpacing => _staticInfo.getGPropertyOnReceiver('letter-spacing', this);
  void set letterSpacing(int value) => _staticInfo.setGPropertyOnReceiver('letter-spacing', this, value);
  static const String LETTER_SPACING_PROPERTY = 'letter-spacing';
  bool get letterSpacingSet => _staticInfo.getGPropertyOnReceiver('letter-spacing-set', this);
  void set letterSpacingSet(bool value) => _staticInfo.setGPropertyOnReceiver('letter-spacing-set', this, value);
  static const String LETTER_SPACING_SET_PROPERTY = 'letter-spacing-set';
  String get name => _staticInfo.getGPropertyOnReceiver('name', this);
  void set name(String value) => _staticInfo.setGPropertyOnReceiver('name', this, value);
  static const String NAME_PROPERTY = 'name';
  void set paragraphBackground(String value) => _staticInfo.setGPropertyOnReceiver('paragraph-background', this, value);
  static const String PARAGRAPH_BACKGROUND_PROPERTY = 'paragraph-background';
  Color get paragraphBackgroundGdk => _staticInfo.getGPropertyOnReceiver('paragraph-background-gdk', this);
  void set paragraphBackgroundGdk(Color value) => _staticInfo.setGPropertyOnReceiver('paragraph-background-gdk', this, value);
  static const String PARAGRAPH_BACKGROUND_GDK_PROPERTY = 'paragraph-background-gdk';
  RGBA get paragraphBackgroundRgba => _staticInfo.getGPropertyOnReceiver('paragraph-background-rgba', this);
  void set paragraphBackgroundRgba(RGBA value) => _staticInfo.setGPropertyOnReceiver('paragraph-background-rgba', this, value);
  static const String PARAGRAPH_BACKGROUND_RGBA_PROPERTY = 'paragraph-background-rgba';
  bool get paragraphBackgroundSet => _staticInfo.getGPropertyOnReceiver('paragraph-background-set', this);
  void set paragraphBackgroundSet(bool value) => _staticInfo.setGPropertyOnReceiver('paragraph-background-set', this, value);
  static const String PARAGRAPH_BACKGROUND_SET_PROPERTY = 'paragraph-background-set';
  int get pixelsAboveLines => _staticInfo.getGPropertyOnReceiver('pixels-above-lines', this);
  void set pixelsAboveLines(int value) => _staticInfo.setGPropertyOnReceiver('pixels-above-lines', this, value);
  static const String PIXELS_ABOVE_LINES_PROPERTY = 'pixels-above-lines';
  bool get pixelsAboveLinesSet => _staticInfo.getGPropertyOnReceiver('pixels-above-lines-set', this);
  void set pixelsAboveLinesSet(bool value) => _staticInfo.setGPropertyOnReceiver('pixels-above-lines-set', this, value);
  static const String PIXELS_ABOVE_LINES_SET_PROPERTY = 'pixels-above-lines-set';
  int get pixelsBelowLines => _staticInfo.getGPropertyOnReceiver('pixels-below-lines', this);
  void set pixelsBelowLines(int value) => _staticInfo.setGPropertyOnReceiver('pixels-below-lines', this, value);
  static const String PIXELS_BELOW_LINES_PROPERTY = 'pixels-below-lines';
  bool get pixelsBelowLinesSet => _staticInfo.getGPropertyOnReceiver('pixels-below-lines-set', this);
  void set pixelsBelowLinesSet(bool value) => _staticInfo.setGPropertyOnReceiver('pixels-below-lines-set', this, value);
  static const String PIXELS_BELOW_LINES_SET_PROPERTY = 'pixels-below-lines-set';
  int get pixelsInsideWrap => _staticInfo.getGPropertyOnReceiver('pixels-inside-wrap', this);
  void set pixelsInsideWrap(int value) => _staticInfo.setGPropertyOnReceiver('pixels-inside-wrap', this, value);
  static const String PIXELS_INSIDE_WRAP_PROPERTY = 'pixels-inside-wrap';
  bool get pixelsInsideWrapSet => _staticInfo.getGPropertyOnReceiver('pixels-inside-wrap-set', this);
  void set pixelsInsideWrapSet(bool value) => _staticInfo.setGPropertyOnReceiver('pixels-inside-wrap-set', this, value);
  static const String PIXELS_INSIDE_WRAP_SET_PROPERTY = 'pixels-inside-wrap-set';
  int get rightMargin => _staticInfo.getGPropertyOnReceiver('right-margin', this);
  void set rightMargin(int value) => _staticInfo.setGPropertyOnReceiver('right-margin', this, value);
  static const String RIGHT_MARGIN_PROPERTY = 'right-margin';
  bool get rightMarginSet => _staticInfo.getGPropertyOnReceiver('right-margin-set', this);
  void set rightMarginSet(bool value) => _staticInfo.setGPropertyOnReceiver('right-margin-set', this, value);
  static const String RIGHT_MARGIN_SET_PROPERTY = 'right-margin-set';
  int get rise => _staticInfo.getGPropertyOnReceiver('rise', this);
  void set rise(int value) => _staticInfo.setGPropertyOnReceiver('rise', this, value);
  static const String RISE_PROPERTY = 'rise';
  bool get riseSet => _staticInfo.getGPropertyOnReceiver('rise-set', this);
  void set riseSet(bool value) => _staticInfo.setGPropertyOnReceiver('rise-set', this, value);
  static const String RISE_SET_PROPERTY = 'rise-set';
  num get scale => _staticInfo.getGPropertyOnReceiver('scale', this);
  void set scale(num value) => _staticInfo.setGPropertyOnReceiver('scale', this, value);
  static const String SCALE_PROPERTY = 'scale';
  bool get scaleSet => _staticInfo.getGPropertyOnReceiver('scale-set', this);
  void set scaleSet(bool value) => _staticInfo.setGPropertyOnReceiver('scale-set', this, value);
  static const String SCALE_SET_PROPERTY = 'scale-set';
  int get size => _staticInfo.getGPropertyOnReceiver('size', this);
  void set size(int value) => _staticInfo.setGPropertyOnReceiver('size', this, value);
  static const String SIZE_PROPERTY = 'size';
  num get sizePoints => _staticInfo.getGPropertyOnReceiver('size-points', this);
  void set sizePoints(num value) => _staticInfo.setGPropertyOnReceiver('size-points', this, value);
  static const String SIZE_POINTS_PROPERTY = 'size-points';
  bool get sizeSet => _staticInfo.getGPropertyOnReceiver('size-set', this);
  void set sizeSet(bool value) => _staticInfo.setGPropertyOnReceiver('size-set', this, value);
  static const String SIZE_SET_PROPERTY = 'size-set';
  Stretch get stretch => _staticInfo.getGPropertyOnReceiver('stretch', this);
  void set stretch(Stretch value) => _staticInfo.setGPropertyOnReceiver('stretch', this, value);
  static const String STRETCH_PROPERTY = 'stretch';
  bool get stretchSet => _staticInfo.getGPropertyOnReceiver('stretch-set', this);
  void set stretchSet(bool value) => _staticInfo.setGPropertyOnReceiver('stretch-set', this, value);
  static const String STRETCH_SET_PROPERTY = 'stretch-set';
  bool get strikethrough => _staticInfo.getGPropertyOnReceiver('strikethrough', this);
  void set strikethrough(bool value) => _staticInfo.setGPropertyOnReceiver('strikethrough', this, value);
  static const String STRIKETHROUGH_PROPERTY = 'strikethrough';
  RGBA get strikethroughRgba => _staticInfo.getGPropertyOnReceiver('strikethrough-rgba', this);
  void set strikethroughRgba(RGBA value) => _staticInfo.setGPropertyOnReceiver('strikethrough-rgba', this, value);
  static const String STRIKETHROUGH_RGBA_PROPERTY = 'strikethrough-rgba';
  bool get strikethroughRgbaSet => _staticInfo.getGPropertyOnReceiver('strikethrough-rgba-set', this);
  void set strikethroughRgbaSet(bool value) => _staticInfo.setGPropertyOnReceiver('strikethrough-rgba-set', this, value);
  static const String STRIKETHROUGH_RGBA_SET_PROPERTY = 'strikethrough-rgba-set';
  bool get strikethroughSet => _staticInfo.getGPropertyOnReceiver('strikethrough-set', this);
  void set strikethroughSet(bool value) => _staticInfo.setGPropertyOnReceiver('strikethrough-set', this, value);
  static const String STRIKETHROUGH_SET_PROPERTY = 'strikethrough-set';
  pango.Style get style => _staticInfo.getGPropertyOnReceiver('style', this);
  void set style(pango.Style value) => _staticInfo.setGPropertyOnReceiver('style', this, value);
  static const String STYLE_PROPERTY = 'style';
  bool get styleSet => _staticInfo.getGPropertyOnReceiver('style-set', this);
  void set styleSet(bool value) => _staticInfo.setGPropertyOnReceiver('style-set', this, value);
  static const String STYLE_SET_PROPERTY = 'style-set';
  TabArray get tabs => _staticInfo.getGPropertyOnReceiver('tabs', this);
  void set tabs(TabArray value) => _staticInfo.setGPropertyOnReceiver('tabs', this, value);
  static const String TABS_PROPERTY = 'tabs';
  bool get tabsSet => _staticInfo.getGPropertyOnReceiver('tabs-set', this);
  void set tabsSet(bool value) => _staticInfo.setGPropertyOnReceiver('tabs-set', this, value);
  static const String TABS_SET_PROPERTY = 'tabs-set';
  Underline get underline => _staticInfo.getGPropertyOnReceiver('underline', this);
  void set underline(Underline value) => _staticInfo.setGPropertyOnReceiver('underline', this, value);
  static const String UNDERLINE_PROPERTY = 'underline';
  RGBA get underlineRgba => _staticInfo.getGPropertyOnReceiver('underline-rgba', this);
  void set underlineRgba(RGBA value) => _staticInfo.setGPropertyOnReceiver('underline-rgba', this, value);
  static const String UNDERLINE_RGBA_PROPERTY = 'underline-rgba';
  bool get underlineRgbaSet => _staticInfo.getGPropertyOnReceiver('underline-rgba-set', this);
  void set underlineRgbaSet(bool value) => _staticInfo.setGPropertyOnReceiver('underline-rgba-set', this, value);
  static const String UNDERLINE_RGBA_SET_PROPERTY = 'underline-rgba-set';
  bool get underlineSet => _staticInfo.getGPropertyOnReceiver('underline-set', this);
  void set underlineSet(bool value) => _staticInfo.setGPropertyOnReceiver('underline-set', this, value);
  static const String UNDERLINE_SET_PROPERTY = 'underline-set';
  pango.Variant get variant => _staticInfo.getGPropertyOnReceiver('variant', this);
  void set variant(pango.Variant value) => _staticInfo.setGPropertyOnReceiver('variant', this, value);
  static const String VARIANT_PROPERTY = 'variant';
  bool get variantSet => _staticInfo.getGPropertyOnReceiver('variant-set', this);
  void set variantSet(bool value) => _staticInfo.setGPropertyOnReceiver('variant-set', this, value);
  static const String VARIANT_SET_PROPERTY = 'variant-set';
  int get weight => _staticInfo.getGPropertyOnReceiver('weight', this);
  void set weight(int value) => _staticInfo.setGPropertyOnReceiver('weight', this, value);
  static const String WEIGHT_PROPERTY = 'weight';
  bool get weightSet => _staticInfo.getGPropertyOnReceiver('weight-set', this);
  void set weightSet(bool value) => _staticInfo.setGPropertyOnReceiver('weight-set', this, value);
  static const String WEIGHT_SET_PROPERTY = 'weight-set';
  WrapMode get wrapMode => _staticInfo.getGPropertyOnReceiver('wrap-mode', this);
  void set wrapMode(WrapMode value) => _staticInfo.setGPropertyOnReceiver('wrap-mode', this, value);
  static const String WRAP_MODE_PROPERTY = 'wrap-mode';
  bool get wrapModeSet => _staticInfo.getGPropertyOnReceiver('wrap-mode-set', this);
  void set wrapModeSet(bool value) => _staticInfo.setGPropertyOnReceiver('wrap-mode-set', this, value);
  static const String WRAP_MODE_SET_PROPERTY = 'wrap-mode-set';
  factory TextTag(String name) => _staticInfo.callStatic('new', [name]);
  bool event(GObjectObject eventObject, Event event, TextIter iter) => _staticInfo.callMethodOnReceiver('event', this, [eventObject, event, iter]);
  int getPriority() => _staticInfo.callMethodOnReceiver('get_priority', this, []);
  void setPriority(int priority) => _staticInfo.callMethodOnReceiver('set_priority', this, [priority]);
  int _connectToEvent(bool after, bool func(GObjectObject object, Event event, TextIter iter)) => signalConnect('event', func, after);
  Stream<TextTagEventEvent> get onEvent {
    int signalId;
    StreamController<TextTagEventEvent> controller;
    controller = new StreamController<TextTagEventEvent>(
      onListen: () {
          signalId = _connectToEvent(false, (GObjectObject object, Event event, TextIter iter) {
              var result = new TextTagEventEvent(object, event, iter);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextTagEventEvent> get afterEvent {
    int signalId;
    StreamController<TextTagEventEvent> controller;
    controller = new StreamController<TextTagEventEvent>(
      onListen: () {
          signalId = _connectToEvent(true, (GObjectObject object, Event event, TextIter iter) {
              var result = new TextTagEventEvent(object, event, iter);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class TextTagEventEvent {
  final GObjectObject object;
  final Event event;
  final TextIter iter;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  TextTagEventEvent(this.object, this.event, this.iter);
}

class TextTagTable extends GObjectObject with Buildable {
  TextTagTable.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextTagTable');

  factory TextTagTable() => _staticInfo.callStatic('new', []);
  bool add(TextTag tag) => _staticInfo.callMethodOnReceiver('add', this, [tag]);
  void foreach(TextTagTableForeach func) => _staticInfo.callMethodOnReceiver('foreach', this, [func]);
  int getSize() => _staticInfo.callMethodOnReceiver('get_size', this, []);
  TextTag lookup(String name) => _staticInfo.callMethodOnReceiver('lookup', this, [name]);
  void remove(TextTag tag) => _staticInfo.callMethodOnReceiver('remove', this, [tag]);
  int _connectToTagAdded(bool after, void func(TextTag tag)) => signalConnect('tag-added', func, after);
  Stream<TextTag> get onTagAdded {
    int signalId;
    StreamController<TextTag> controller;
    controller = new StreamController<TextTag>(
      onListen: () {
          signalId = _connectToTagAdded(false, (TextTag tag) {
              controller.add(tag);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextTag> get afterTagAdded {
    int signalId;
    StreamController<TextTag> controller;
    controller = new StreamController<TextTag>(
      onListen: () {
          signalId = _connectToTagAdded(true, (TextTag tag) {
              controller.add(tag);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToTagChanged(bool after, void func(TextTag tag, bool sizeChanged)) => signalConnect('tag-changed', func, after);
  Stream<TextTagTableTagChangedEvent> get onTagChanged {
    int signalId;
    StreamController<TextTagTableTagChangedEvent> controller;
    controller = new StreamController<TextTagTableTagChangedEvent>(
      onListen: () {
          signalId = _connectToTagChanged(false, (TextTag tag, bool sizeChanged) {
              var result = new TextTagTableTagChangedEvent(tag, sizeChanged);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextTagTableTagChangedEvent> get afterTagChanged {
    int signalId;
    StreamController<TextTagTableTagChangedEvent> controller;
    controller = new StreamController<TextTagTableTagChangedEvent>(
      onListen: () {
          signalId = _connectToTagChanged(true, (TextTag tag, bool sizeChanged) {
              var result = new TextTagTableTagChangedEvent(tag, sizeChanged);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToTagRemoved(bool after, void func(TextTag tag)) => signalConnect('tag-removed', func, after);
  Stream<TextTag> get onTagRemoved {
    int signalId;
    StreamController<TextTag> controller;
    controller = new StreamController<TextTag>(
      onListen: () {
          signalId = _connectToTagRemoved(false, (TextTag tag) {
              controller.add(tag);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextTag> get afterTagRemoved {
    int signalId;
    StreamController<TextTag> controller;
    controller = new StreamController<TextTag>(
      onListen: () {
          signalId = _connectToTagRemoved(true, (TextTag tag) {
              controller.add(tag);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class TextTagTableTagChangedEvent {
  final TextTag tag;
  final bool sizeChanged;

  TextTagTableTagChangedEvent(this.tag, this.sizeChanged);
}

typedef void TextTagTableForeach(TextTag tag);
class TextView extends Container with ImplementorIface, Buildable, Scrollable {
  TextView.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextView');

  static const String ACCEPTS_TAB_PROPERTY = 'accepts-tab';
  static const String BOTTOM_MARGIN_PROPERTY = 'bottom-margin';
  static const String BUFFER_PROPERTY = 'buffer';
  static const String CURSOR_VISIBLE_PROPERTY = 'cursor-visible';
  static const String EDITABLE_PROPERTY = 'editable';
  String get imModule => _staticInfo.getGPropertyOnReceiver('im-module', this);
  void set imModule(String value) => _staticInfo.setGPropertyOnReceiver('im-module', this, value);
  static const String IM_MODULE_PROPERTY = 'im-module';
  static const String INDENT_PROPERTY = 'indent';
  static const String INPUT_HINTS_PROPERTY = 'input-hints';
  static const String INPUT_PURPOSE_PROPERTY = 'input-purpose';
  static const String JUSTIFICATION_PROPERTY = 'justification';
  static const String LEFT_MARGIN_PROPERTY = 'left-margin';
  static const String MONOSPACE_PROPERTY = 'monospace';
  static const String OVERWRITE_PROPERTY = 'overwrite';
  static const String PIXELS_ABOVE_LINES_PROPERTY = 'pixels-above-lines';
  static const String PIXELS_BELOW_LINES_PROPERTY = 'pixels-below-lines';
  static const String PIXELS_INSIDE_WRAP_PROPERTY = 'pixels-inside-wrap';
  bool get populateAll => _staticInfo.getGPropertyOnReceiver('populate-all', this);
  void set populateAll(bool value) => _staticInfo.setGPropertyOnReceiver('populate-all', this, value);
  static const String POPULATE_ALL_PROPERTY = 'populate-all';
  static const String RIGHT_MARGIN_PROPERTY = 'right-margin';
  static const String TABS_PROPERTY = 'tabs';
  static const String TOP_MARGIN_PROPERTY = 'top-margin';
  static const String WRAP_MODE_PROPERTY = 'wrap-mode';
  factory TextView() => _staticInfo.callStatic('new', []);
  factory TextView.withBuffer(TextBuffer buffer) => _staticInfo.callStatic('new_with_buffer', [buffer]);
  void addChildAtAnchor(Widget child, TextChildAnchor anchor) => _staticInfo.callMethodOnReceiver('add_child_at_anchor', this, [child, anchor]);
  void addChildInWindow(Widget child, TextWindowType whichWindow, int xpos, int ypos) => _staticInfo.callMethodOnReceiver('add_child_in_window', this, [child, whichWindow, xpos, ypos]);
  bool backwardDisplayLine(TextIter iter) => _staticInfo.callMethodOnReceiver('backward_display_line', this, [iter]);
  bool backwardDisplayLineStart(TextIter iter) => _staticInfo.callMethodOnReceiver('backward_display_line_start', this, [iter]);
  void bufferToWindowCoords(TextWindowType win, int bufferX, int bufferY) => _staticInfo.callMethodOnReceiver('buffer_to_window_coords', this, [win, bufferX, bufferY]);
  bool forwardDisplayLine(TextIter iter) => _staticInfo.callMethodOnReceiver('forward_display_line', this, [iter]);
  bool forwardDisplayLineEnd(TextIter iter) => _staticInfo.callMethodOnReceiver('forward_display_line_end', this, [iter]);
  bool get acceptsTab => _staticInfo.callMethodOnReceiver('get_accepts_tab', this, []);
  int getBorderWindowSize(TextWindowType type) => _staticInfo.callMethodOnReceiver('get_border_window_size', this, [type]);
  int get bottomMargin => _staticInfo.callMethodOnReceiver('get_bottom_margin', this, []);
  TextBuffer get buffer => _staticInfo.callMethodOnReceiver('get_buffer', this, []);
  void getCursorLocations(TextIter iter) => _staticInfo.callMethodOnReceiver('get_cursor_locations', this, [iter]);
  bool get cursorVisible => _staticInfo.callMethodOnReceiver('get_cursor_visible', this, []);
  TextAttributes getDefaultAttributes() => _staticInfo.callMethodOnReceiver('get_default_attributes', this, []);
  bool get editable => _staticInfo.callMethodOnReceiver('get_editable', this, []);
  Adjustment getHadjustment() => _staticInfo.callMethodOnReceiver('get_hadjustment', this, []);
  int get indent => _staticInfo.callMethodOnReceiver('get_indent', this, []);
  InputHints get inputHints => _staticInfo.callMethodOnReceiver('get_input_hints', this, []);
  InputPurpose get inputPurpose => _staticInfo.callMethodOnReceiver('get_input_purpose', this, []);
  void getIterAtLocation(int x, int y) => _staticInfo.callMethodOnReceiver('get_iter_at_location', this, [x, y]);
  void getIterAtPosition(int x, int y) => _staticInfo.callMethodOnReceiver('get_iter_at_position', this, [x, y]);
  void getIterLocation(TextIter iter) => _staticInfo.callMethodOnReceiver('get_iter_location', this, [iter]);
  Justification get justification => _staticInfo.callMethodOnReceiver('get_justification', this, []);
  int get leftMargin => _staticInfo.callMethodOnReceiver('get_left_margin', this, []);
  void getLineAtY(int y) => _staticInfo.callMethodOnReceiver('get_line_at_y', this, [y]);
  void getLineYrange(TextIter iter) => _staticInfo.callMethodOnReceiver('get_line_yrange', this, [iter]);
  bool get monospace => _staticInfo.callMethodOnReceiver('get_monospace', this, []);
  bool get overwrite => _staticInfo.callMethodOnReceiver('get_overwrite', this, []);
  int get pixelsAboveLines => _staticInfo.callMethodOnReceiver('get_pixels_above_lines', this, []);
  int get pixelsBelowLines => _staticInfo.callMethodOnReceiver('get_pixels_below_lines', this, []);
  int get pixelsInsideWrap => _staticInfo.callMethodOnReceiver('get_pixels_inside_wrap', this, []);
  int get rightMargin => _staticInfo.callMethodOnReceiver('get_right_margin', this, []);
  TabArray get tabs => _staticInfo.callMethodOnReceiver('get_tabs', this, []);
  int get topMargin => _staticInfo.callMethodOnReceiver('get_top_margin', this, []);
  Adjustment getVadjustment() => _staticInfo.callMethodOnReceiver('get_vadjustment', this, []);
  void getVisibleRect() => _staticInfo.callMethodOnReceiver('get_visible_rect', this, []);
  gdk.Window getWindow(TextWindowType win) => _staticInfo.callMethodOnReceiver('get_window', this, [win]);
  TextWindowType getWindowType(gdk.Window window) => _staticInfo.callMethodOnReceiver('get_window_type', this, [window]);
  WrapMode get wrapMode => _staticInfo.callMethodOnReceiver('get_wrap_mode', this, []);
  bool imContextFilterKeypress(EventKey event) => _staticInfo.callMethodOnReceiver('im_context_filter_keypress', this, [event]);
  void moveChild(Widget child, int xpos, int ypos) => _staticInfo.callMethodOnReceiver('move_child', this, [child, xpos, ypos]);
  bool moveMarkOnscreen(TextMark mark) => _staticInfo.callMethodOnReceiver('move_mark_onscreen', this, [mark]);
  bool moveVisually(TextIter iter, int count) => _staticInfo.callMethodOnReceiver('move_visually', this, [iter, count]);
  bool placeCursorOnscreen() => _staticInfo.callMethodOnReceiver('place_cursor_onscreen', this, []);
  void resetImContext() => _staticInfo.callMethodOnReceiver('reset_im_context', this, []);
  void scrollMarkOnscreen(TextMark mark) => _staticInfo.callMethodOnReceiver('scroll_mark_onscreen', this, [mark]);
  bool scrollToIter(TextIter iter, num withinMargin, bool useAlign, num xalign, num yalign) => _staticInfo.callMethodOnReceiver('scroll_to_iter', this, [iter, withinMargin, useAlign, xalign, yalign]);
  void scrollToMark(TextMark mark, num withinMargin, bool useAlign, num xalign, num yalign) => _staticInfo.callMethodOnReceiver('scroll_to_mark', this, [mark, withinMargin, useAlign, xalign, yalign]);
  void set acceptsTab(bool acceptsTab) => _staticInfo.callMethodOnReceiver('set_accepts_tab', this, [acceptsTab]);
  void setBorderWindowSize(TextWindowType type, int size) => _staticInfo.callMethodOnReceiver('set_border_window_size', this, [type, size]);
  void set bottomMargin(int bottomMargin) => _staticInfo.callMethodOnReceiver('set_bottom_margin', this, [bottomMargin]);
  void set buffer(TextBuffer buffer) => _staticInfo.callMethodOnReceiver('set_buffer', this, [buffer]);
  void set cursorVisible(bool setting) => _staticInfo.callMethodOnReceiver('set_cursor_visible', this, [setting]);
  void set editable(bool setting) => _staticInfo.callMethodOnReceiver('set_editable', this, [setting]);
  void set indent(int indent) => _staticInfo.callMethodOnReceiver('set_indent', this, [indent]);
  void set inputHints(InputHints hints) => _staticInfo.callMethodOnReceiver('set_input_hints', this, [hints]);
  void set inputPurpose(InputPurpose purpose) => _staticInfo.callMethodOnReceiver('set_input_purpose', this, [purpose]);
  void set justification(Justification justification) => _staticInfo.callMethodOnReceiver('set_justification', this, [justification]);
  void set leftMargin(int leftMargin) => _staticInfo.callMethodOnReceiver('set_left_margin', this, [leftMargin]);
  void set monospace(bool monospace) => _staticInfo.callMethodOnReceiver('set_monospace', this, [monospace]);
  void set overwrite(bool overwrite) => _staticInfo.callMethodOnReceiver('set_overwrite', this, [overwrite]);
  void set pixelsAboveLines(int pixelsAboveLines) => _staticInfo.callMethodOnReceiver('set_pixels_above_lines', this, [pixelsAboveLines]);
  void set pixelsBelowLines(int pixelsBelowLines) => _staticInfo.callMethodOnReceiver('set_pixels_below_lines', this, [pixelsBelowLines]);
  void set pixelsInsideWrap(int pixelsInsideWrap) => _staticInfo.callMethodOnReceiver('set_pixels_inside_wrap', this, [pixelsInsideWrap]);
  void set rightMargin(int rightMargin) => _staticInfo.callMethodOnReceiver('set_right_margin', this, [rightMargin]);
  void set tabs(TabArray tabs) => _staticInfo.callMethodOnReceiver('set_tabs', this, [tabs]);
  void set topMargin(int topMargin) => _staticInfo.callMethodOnReceiver('set_top_margin', this, [topMargin]);
  void set wrapMode(WrapMode wrapMode) => _staticInfo.callMethodOnReceiver('set_wrap_mode', this, [wrapMode]);
  bool startsDisplayLine(TextIter iter) => _staticInfo.callMethodOnReceiver('starts_display_line', this, [iter]);
  void windowToBufferCoords(TextWindowType win, int windowX, int windowY) => _staticInfo.callMethodOnReceiver('window_to_buffer_coords', this, [win, windowX, windowY]);
  int _connectToBackspace(bool after, void func()) => signalConnect('backspace', func, after);
  Stream get onBackspace {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToBackspace(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterBackspace {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToBackspace(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCopyClipboard(bool after, void func()) => signalConnect('copy-clipboard', func, after);
  Stream get onCopyClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCopyClipboard(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterCopyClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCopyClipboard(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCutClipboard(bool after, void func()) => signalConnect('cut-clipboard', func, after);
  Stream get onCutClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCutClipboard(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterCutClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCutClipboard(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDeleteFromCursor(bool after, void func(DeleteType type, int count)) => signalConnect('delete-from-cursor', func, after);
  Stream<TextViewDeleteFromCursorEvent> get onDeleteFromCursor {
    int signalId;
    StreamController<TextViewDeleteFromCursorEvent> controller;
    controller = new StreamController<TextViewDeleteFromCursorEvent>(
      onListen: () {
          signalId = _connectToDeleteFromCursor(false, (DeleteType type, int count) {
              var result = new TextViewDeleteFromCursorEvent(type, count);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextViewDeleteFromCursorEvent> get afterDeleteFromCursor {
    int signalId;
    StreamController<TextViewDeleteFromCursorEvent> controller;
    controller = new StreamController<TextViewDeleteFromCursorEvent>(
      onListen: () {
          signalId = _connectToDeleteFromCursor(true, (DeleteType type, int count) {
              var result = new TextViewDeleteFromCursorEvent(type, count);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToExtendSelection(bool after, bool func(TextExtendSelection granularity, TextIter location, TextIter start, TextIter end)) => signalConnect('extend-selection', func, after);
  Stream<TextViewExtendSelectionEvent> get onExtendSelection {
    int signalId;
    StreamController<TextViewExtendSelectionEvent> controller;
    controller = new StreamController<TextViewExtendSelectionEvent>(
      onListen: () {
          signalId = _connectToExtendSelection(false, (TextExtendSelection granularity, TextIter location, TextIter start, TextIter end) {
              var result = new TextViewExtendSelectionEvent(granularity, location, start, end);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextViewExtendSelectionEvent> get afterExtendSelection {
    int signalId;
    StreamController<TextViewExtendSelectionEvent> controller;
    controller = new StreamController<TextViewExtendSelectionEvent>(
      onListen: () {
          signalId = _connectToExtendSelection(true, (TextExtendSelection granularity, TextIter location, TextIter start, TextIter end) {
              var result = new TextViewExtendSelectionEvent(granularity, location, start, end);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToInsertAtCursor(bool after, void func(String string)) => signalConnect('insert-at-cursor', func, after);
  Stream<String> get onInsertAtCursor {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToInsertAtCursor(false, (String string) {
              controller.add(string);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<String> get afterInsertAtCursor {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToInsertAtCursor(true, (String string) {
              controller.add(string);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveCursor(bool after, void func(MovementStep step, int count, bool extendSelection)) => signalConnect('move-cursor', func, after);
  Stream<TextViewMoveCursorEvent> get onMoveCursor {
    int signalId;
    StreamController<TextViewMoveCursorEvent> controller;
    controller = new StreamController<TextViewMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(false, (MovementStep step, int count, bool extendSelection) {
              var result = new TextViewMoveCursorEvent(step, count, extendSelection);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextViewMoveCursorEvent> get afterMoveCursor {
    int signalId;
    StreamController<TextViewMoveCursorEvent> controller;
    controller = new StreamController<TextViewMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(true, (MovementStep step, int count, bool extendSelection) {
              var result = new TextViewMoveCursorEvent(step, count, extendSelection);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveViewport(bool after, void func(ScrollStep step, int count)) => signalConnect('move-viewport', func, after);
  Stream<TextViewMoveViewportEvent> get onMoveViewport {
    int signalId;
    StreamController<TextViewMoveViewportEvent> controller;
    controller = new StreamController<TextViewMoveViewportEvent>(
      onListen: () {
          signalId = _connectToMoveViewport(false, (ScrollStep step, int count) {
              var result = new TextViewMoveViewportEvent(step, count);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextViewMoveViewportEvent> get afterMoveViewport {
    int signalId;
    StreamController<TextViewMoveViewportEvent> controller;
    controller = new StreamController<TextViewMoveViewportEvent>(
      onListen: () {
          signalId = _connectToMoveViewport(true, (ScrollStep step, int count) {
              var result = new TextViewMoveViewportEvent(step, count);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPasteClipboard(bool after, void func()) => signalConnect('paste-clipboard', func, after);
  Stream get onPasteClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPasteClipboard(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterPasteClipboard {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToPasteClipboard(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPopulatePopup(bool after, void func(Widget popup)) => signalConnect('populate-popup', func, after);
  Stream<Widget> get onPopulatePopup {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToPopulatePopup(false, (Widget popup) {
              controller.add(popup);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Widget> get afterPopulatePopup {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToPopulatePopup(true, (Widget popup) {
              controller.add(popup);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPreeditChanged(bool after, void func(String preedit)) => signalConnect('preedit-changed', func, after);
  Stream<String> get onPreeditChanged {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToPreeditChanged(false, (String preedit) {
              controller.add(preedit);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<String> get afterPreeditChanged {
    int signalId;
    StreamController<String> controller;
    controller = new StreamController<String>(
      onListen: () {
          signalId = _connectToPreeditChanged(true, (String preedit) {
              controller.add(preedit);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectAll(bool after, void func(bool select)) => signalConnect('select-all', func, after);
  Stream<bool> get onSelectAll {
    int signalId;
    StreamController<bool> controller;
    controller = new StreamController<bool>(
      onListen: () {
          signalId = _connectToSelectAll(false, (bool select) {
              controller.add(select);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<bool> get afterSelectAll {
    int signalId;
    StreamController<bool> controller;
    controller = new StreamController<bool>(
      onListen: () {
          signalId = _connectToSelectAll(true, (bool select) {
              controller.add(select);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSetAnchor(bool after, void func()) => signalConnect('set-anchor', func, after);
  Stream get onSetAnchor {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSetAnchor(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSetAnchor {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSetAnchor(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToToggleCursorVisible(bool after, void func()) => signalConnect('toggle-cursor-visible', func, after);
  Stream get onToggleCursorVisible {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggleCursorVisible(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterToggleCursorVisible {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggleCursorVisible(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToToggleOverwrite(bool after, void func()) => signalConnect('toggle-overwrite', func, after);
  Stream get onToggleOverwrite {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggleOverwrite(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterToggleOverwrite {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggleOverwrite(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class TextViewDeleteFromCursorEvent {
  final DeleteType type;
  final int count;

  TextViewDeleteFromCursorEvent(this.type, this.count);
}

class TextViewExtendSelectionEvent {
  final TextExtendSelection granularity;
  final TextIter location;
  final TextIter start;
  final TextIter end;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  TextViewExtendSelectionEvent(this.granularity, this.location, this.start, this.end);
}

class TextViewMoveCursorEvent {
  final MovementStep step;
  final int count;
  final bool extendSelection;

  TextViewMoveCursorEvent(this.step, this.count, this.extendSelection);
}

class TextViewMoveViewportEvent {
  final ScrollStep step;
  final int count;

  TextViewMoveViewportEvent(this.step, this.count);
}

class TextViewAccessible extends ContainerAccessible with Component, EditableText, StreamableContent, Text {
  TextViewAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextViewAccessible');

}

class TextViewLayer extends GEnumBase {
  const TextViewLayer(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextViewLayer');

  static const TextViewLayer BELOW = const TextViewLayer(0);
  static const TextViewLayer ABOVE = const TextViewLayer(1);
  String toString() {
    switch(index) {
      case 0: return 'TextViewLayer.BELOW';
      case 1: return 'TextViewLayer.ABOVE';
      default: return 'new TextViewLayer($index)';
    }
  }
}

class TextWindowType extends GEnumBase {
  const TextWindowType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TextWindowType');

  static const TextWindowType PRIVATE = const TextWindowType(0);
  static const TextWindowType WIDGET = const TextWindowType(1);
  static const TextWindowType TEXT = const TextWindowType(2);
  static const TextWindowType LEFT = const TextWindowType(3);
  static const TextWindowType RIGHT = const TextWindowType(4);
  static const TextWindowType TOP = const TextWindowType(5);
  static const TextWindowType BOTTOM = const TextWindowType(6);
  String toString() {
    switch(index) {
      case 0: return 'TextWindowType.PRIVATE';
      case 1: return 'TextWindowType.WIDGET';
      case 2: return 'TextWindowType.TEXT';
      case 3: return 'TextWindowType.LEFT';
      case 4: return 'TextWindowType.RIGHT';
      case 5: return 'TextWindowType.TOP';
      case 6: return 'TextWindowType.BOTTOM';
      default: return 'new TextWindowType($index)';
    }
  }
}

class ThemeEngine extends GObjectBase {
  ThemeEngine.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ThemeEngine');

}

class ThemingEngine extends GObjectObject {
  ThemingEngine.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ThemingEngine');

  String get name => _staticInfo.getGPropertyOnReceiver('name', this);
  void set name(String value) => _staticInfo.setGPropertyOnReceiver('name', this, value);
  static const String NAME_PROPERTY = 'name';
  static ThemingEngine load(String name) => _staticInfo.callStatic('load', [name]);
  void getBackgroundColor(StateFlags state) => _staticInfo.callMethodOnReceiver('get_background_color', this, [state]);
  void getBorder(StateFlags state) => _staticInfo.callMethodOnReceiver('get_border', this, [state]);
  void getBorderColor(StateFlags state) => _staticInfo.callMethodOnReceiver('get_border_color', this, [state]);
  void getColor(StateFlags state) => _staticInfo.callMethodOnReceiver('get_color', this, [state]);
  TextDirection getDirection() => _staticInfo.callMethodOnReceiver('get_direction', this, []);
  FontDescription getFont(StateFlags state) => _staticInfo.callMethodOnReceiver('get_font', this, [state]);
  JunctionSides getJunctionSides() => _staticInfo.callMethodOnReceiver('get_junction_sides', this, []);
  void getMargin(StateFlags state) => _staticInfo.callMethodOnReceiver('get_margin', this, [state]);
  void getPadding(StateFlags state) => _staticInfo.callMethodOnReceiver('get_padding', this, [state]);
  WidgetPath getPath() => _staticInfo.callMethodOnReceiver('get_path', this, []);
  void themingEngineGetProperty(String property, StateFlags state) => _staticInfo.callMethodOnReceiver('get_property', this, [property, state]);
  Screen getScreen() => _staticInfo.callMethodOnReceiver('get_screen', this, []);
  StateFlags getState() => _staticInfo.callMethodOnReceiver('get_state', this, []);
  void getStyleProperty(String propertyName) => _staticInfo.callMethodOnReceiver('get_style_property', this, [propertyName]);
  bool hasClass(String styleClass) => _staticInfo.callMethodOnReceiver('has_class', this, [styleClass]);
  bool hasRegion(String styleRegion) => _staticInfo.callMethodOnReceiver('has_region', this, [styleRegion]);
  bool lookupColor(String colorName) => _staticInfo.callMethodOnReceiver('lookup_color', this, [colorName]);
  bool stateIsRunning(StateType state) => _staticInfo.callMethodOnReceiver('state_is_running', this, [state]);
}

typedef bool TickCallback(Widget widget, FrameClock frameClock);
class ToggleAction extends Action with Buildable {
  ToggleAction.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToggleAction');

  static const String ACTIVE_PROPERTY = 'active';
  static const String DRAW_AS_RADIO_PROPERTY = 'draw-as-radio';
  factory ToggleAction(String name, String label, String tooltip, String stockId) => _staticInfo.callStatic('new', [name, label, tooltip, stockId]);
  bool get active => _staticInfo.callMethodOnReceiver('get_active', this, []);
  bool get drawAsRadio => _staticInfo.callMethodOnReceiver('get_draw_as_radio', this, []);
  void set active(bool isActive) => _staticInfo.callMethodOnReceiver('set_active', this, [isActive]);
  void set drawAsRadio(bool drawAsRadio) => _staticInfo.callMethodOnReceiver('set_draw_as_radio', this, [drawAsRadio]);
  void toggled() => _staticInfo.callMethodOnReceiver('toggled', this, []);
  int _connectToToggled(bool after, void func()) => signalConnect('toggled', func, after);
  Stream get onToggled {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggled(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterToggled {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggled(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ToggleActionEntry extends GObjectBase {
  ToggleActionEntry.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToggleActionEntry');

  String get name => getFieldOfObject('name', 0);
  void set name(String value) => setFieldOfObject('name', 0, value);
  String get stockId => getFieldOfObject('stock_id', 1);
  void set stockId(String value) => setFieldOfObject('stock_id', 1, value);
  String get label => getFieldOfObject('label', 2);
  void set label(String value) => setFieldOfObject('label', 2, value);
  String get accelerator => getFieldOfObject('accelerator', 3);
  void set accelerator(String value) => setFieldOfObject('accelerator', 3, value);
  String get tooltip => getFieldOfObject('tooltip', 4);
  void set tooltip(String value) => setFieldOfObject('tooltip', 4, value);
  Callback get callback => getFieldOfObject('callback', 5);
  void set callback(Callback value) => setFieldOfObject('callback', 5, value);
  bool get isActive => getFieldOfObject('is_active', 6);
  void set isActive(bool value) => setFieldOfObject('is_active', 6, value);
}

class ToggleButton extends Button with ImplementorIface, Actionable, Activatable, Buildable {
  ToggleButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToggleButton');

  static const String ACTIVE_PROPERTY = 'active';
  bool get drawIndicator => _staticInfo.getGPropertyOnReceiver('draw-indicator', this);
  void set drawIndicator(bool value) => _staticInfo.setGPropertyOnReceiver('draw-indicator', this, value);
  static const String DRAW_INDICATOR_PROPERTY = 'draw-indicator';
  static const String INCONSISTENT_PROPERTY = 'inconsistent';
  factory ToggleButton() => _staticInfo.callStatic('new', []);
  factory ToggleButton.withLabel(String label) => _staticInfo.callStatic('new_with_label', [label]);
  factory ToggleButton.withMnemonic(String label) => _staticInfo.callStatic('new_with_mnemonic', [label]);
  bool get active => _staticInfo.callMethodOnReceiver('get_active', this, []);
  bool get inconsistent => _staticInfo.callMethodOnReceiver('get_inconsistent', this, []);
  bool getMode() => _staticInfo.callMethodOnReceiver('get_mode', this, []);
  void set active(bool isActive) => _staticInfo.callMethodOnReceiver('set_active', this, [isActive]);
  void set inconsistent(bool setting) => _staticInfo.callMethodOnReceiver('set_inconsistent', this, [setting]);
  void setMode(bool drawIndicator) => _staticInfo.callMethodOnReceiver('set_mode', this, [drawIndicator]);
  void toggled() => _staticInfo.callMethodOnReceiver('toggled', this, []);
  int _connectToToggled(bool after, void func()) => signalConnect('toggled', func, after);
  Stream get onToggled {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggled(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterToggled {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggled(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ToggleButtonAccessible extends ButtonAccessible with atk.Action, Component, atk.Image {
  ToggleButtonAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToggleButtonAccessible');

}

class ToggleToolButton extends ToolButton with ImplementorIface, Actionable, Activatable, Buildable {
  ToggleToolButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToggleToolButton');

  static const String ACTIVE_PROPERTY = 'active';
  factory ToggleToolButton() => _staticInfo.callStatic('new', []);
  factory ToggleToolButton.fromStock(String stockId) => _staticInfo.callStatic('new_from_stock', [stockId]);
  bool get active => _staticInfo.callMethodOnReceiver('get_active', this, []);
  void set active(bool isActive) => _staticInfo.callMethodOnReceiver('set_active', this, [isActive]);
  int _connectToToggled(bool after, void func()) => signalConnect('toggled', func, after);
  Stream get onToggled {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggled(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterToggled {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToggled(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ToolButton extends ToolItem with ImplementorIface, Actionable, Activatable, Buildable {
  ToolButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToolButton');

  static const String ICON_NAME_PROPERTY = 'icon-name';
  static const String ICON_WIDGET_PROPERTY = 'icon-widget';
  static const String LABEL_PROPERTY = 'label';
  static const String LABEL_WIDGET_PROPERTY = 'label-widget';
  static const String STOCK_ID_PROPERTY = 'stock-id';
  static const String USE_UNDERLINE_PROPERTY = 'use-underline';
  factory ToolButton(Widget iconWidget, String label) => _staticInfo.callStatic('new', [iconWidget, label]);
  factory ToolButton.fromStock(String stockId) => _staticInfo.callStatic('new_from_stock', [stockId]);
  String get iconName => _staticInfo.callMethodOnReceiver('get_icon_name', this, []);
  Widget get iconWidget => _staticInfo.callMethodOnReceiver('get_icon_widget', this, []);
  String get label => _staticInfo.callMethodOnReceiver('get_label', this, []);
  Widget get labelWidget => _staticInfo.callMethodOnReceiver('get_label_widget', this, []);
  String get stockId => _staticInfo.callMethodOnReceiver('get_stock_id', this, []);
  bool get useUnderline => _staticInfo.callMethodOnReceiver('get_use_underline', this, []);
  void set iconName(String iconName) => _staticInfo.callMethodOnReceiver('set_icon_name', this, [iconName]);
  void set iconWidget(Widget iconWidget) => _staticInfo.callMethodOnReceiver('set_icon_widget', this, [iconWidget]);
  void set label(String label) => _staticInfo.callMethodOnReceiver('set_label', this, [label]);
  void set labelWidget(Widget labelWidget) => _staticInfo.callMethodOnReceiver('set_label_widget', this, [labelWidget]);
  void set stockId(String stockId) => _staticInfo.callMethodOnReceiver('set_stock_id', this, [stockId]);
  void set useUnderline(bool useUnderline) => _staticInfo.callMethodOnReceiver('set_use_underline', this, [useUnderline]);
  int _connectToClicked(bool after, void func()) => signalConnect('clicked', func, after);
  Stream get onClicked {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClicked(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterClicked {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClicked(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ToolItem extends Bin with ImplementorIface, Activatable, Buildable {
  ToolItem.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToolItem');

  static const String IS_IMPORTANT_PROPERTY = 'is-important';
  static const String VISIBLE_HORIZONTAL_PROPERTY = 'visible-horizontal';
  static const String VISIBLE_VERTICAL_PROPERTY = 'visible-vertical';
  factory ToolItem() => _staticInfo.callStatic('new', []);
  EllipsizeMode getEllipsizeMode() => _staticInfo.callMethodOnReceiver('get_ellipsize_mode', this, []);
  bool getExpand() => _staticInfo.callMethodOnReceiver('get_expand', this, []);
  bool getHomogeneous() => _staticInfo.callMethodOnReceiver('get_homogeneous', this, []);
  int getIconSize() => _staticInfo.callMethodOnReceiver('get_icon_size', this, []);
  bool get isImportant => _staticInfo.callMethodOnReceiver('get_is_important', this, []);
  Orientation getOrientation() => _staticInfo.callMethodOnReceiver('get_orientation', this, []);
  Widget getProxyMenuItem(String menuItemId) => _staticInfo.callMethodOnReceiver('get_proxy_menu_item', this, [menuItemId]);
  ReliefStyle getReliefStyle() => _staticInfo.callMethodOnReceiver('get_relief_style', this, []);
  num getTextAlignment() => _staticInfo.callMethodOnReceiver('get_text_alignment', this, []);
  Orientation getTextOrientation() => _staticInfo.callMethodOnReceiver('get_text_orientation', this, []);
  SizeGroup getTextSizeGroup() => _staticInfo.callMethodOnReceiver('get_text_size_group', this, []);
  ToolbarStyle getToolbarStyle() => _staticInfo.callMethodOnReceiver('get_toolbar_style', this, []);
  bool getUseDragWindow() => _staticInfo.callMethodOnReceiver('get_use_drag_window', this, []);
  bool get visibleHorizontal => _staticInfo.callMethodOnReceiver('get_visible_horizontal', this, []);
  bool get visibleVertical => _staticInfo.callMethodOnReceiver('get_visible_vertical', this, []);
  void rebuildMenu() => _staticInfo.callMethodOnReceiver('rebuild_menu', this, []);
  Widget retrieveProxyMenuItem() => _staticInfo.callMethodOnReceiver('retrieve_proxy_menu_item', this, []);
  void setExpand(bool expand) => _staticInfo.callMethodOnReceiver('set_expand', this, [expand]);
  void setHomogeneous(bool homogeneous) => _staticInfo.callMethodOnReceiver('set_homogeneous', this, [homogeneous]);
  void set isImportant(bool isImportant) => _staticInfo.callMethodOnReceiver('set_is_important', this, [isImportant]);
  void setProxyMenuItem(String menuItemId, Widget menuItem) => _staticInfo.callMethodOnReceiver('set_proxy_menu_item', this, [menuItemId, menuItem]);
  void setTooltipMarkup(String markup) => _staticInfo.callMethodOnReceiver('set_tooltip_markup', this, [markup]);
  void setTooltipText(String text) => _staticInfo.callMethodOnReceiver('set_tooltip_text', this, [text]);
  void setUseDragWindow(bool useDragWindow) => _staticInfo.callMethodOnReceiver('set_use_drag_window', this, [useDragWindow]);
  void set visibleHorizontal(bool visibleHorizontal) => _staticInfo.callMethodOnReceiver('set_visible_horizontal', this, [visibleHorizontal]);
  void set visibleVertical(bool visibleVertical) => _staticInfo.callMethodOnReceiver('set_visible_vertical', this, [visibleVertical]);
  void toolbarReconfigured() => _staticInfo.callMethodOnReceiver('toolbar_reconfigured', this, []);
  int _connectToCreateMenuProxy(bool after, bool func()) => signalConnect('create-menu-proxy', func, after);
  Stream<ToolItemCreateMenuProxyEvent> get onCreateMenuProxy {
    int signalId;
    StreamController<ToolItemCreateMenuProxyEvent> controller;
    controller = new StreamController<ToolItemCreateMenuProxyEvent>(
      onListen: () {
          signalId = _connectToCreateMenuProxy(false, () {
              var result = new ToolItemCreateMenuProxyEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ToolItemCreateMenuProxyEvent> get afterCreateMenuProxy {
    int signalId;
    StreamController<ToolItemCreateMenuProxyEvent> controller;
    controller = new StreamController<ToolItemCreateMenuProxyEvent>(
      onListen: () {
          signalId = _connectToCreateMenuProxy(true, () {
              var result = new ToolItemCreateMenuProxyEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToToolbarReconfigured(bool after, void func()) => signalConnect('toolbar-reconfigured', func, after);
  Stream get onToolbarReconfigured {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToolbarReconfigured(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterToolbarReconfigured {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToToolbarReconfigured(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ToolItemCreateMenuProxyEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  ToolItemCreateMenuProxyEvent();
}

class ToolItemGroup extends Container with ImplementorIface, Buildable, ToolShell {
  ToolItemGroup.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToolItemGroup');

  static const String COLLAPSED_PROPERTY = 'collapsed';
  static const String ELLIPSIZE_PROPERTY = 'ellipsize';
  static const String HEADER_RELIEF_PROPERTY = 'header-relief';
  static const String LABEL_PROPERTY = 'label';
  static const String LABEL_WIDGET_PROPERTY = 'label-widget';
  factory ToolItemGroup(String label) => _staticInfo.callStatic('new', [label]);
  bool get collapsed => _staticInfo.callMethodOnReceiver('get_collapsed', this, []);
  ToolItem getDropItem(int x, int y) => _staticInfo.callMethodOnReceiver('get_drop_item', this, [x, y]);
  EllipsizeMode get ellipsize => _staticInfo.callMethodOnReceiver('get_ellipsize', this, []);
  ReliefStyle get headerRelief => _staticInfo.callMethodOnReceiver('get_header_relief', this, []);
  int getItemPosition(ToolItem item) => _staticInfo.callMethodOnReceiver('get_item_position', this, [item]);
  String get label => _staticInfo.callMethodOnReceiver('get_label', this, []);
  Widget get labelWidget => _staticInfo.callMethodOnReceiver('get_label_widget', this, []);
  int getNItems() => _staticInfo.callMethodOnReceiver('get_n_items', this, []);
  ToolItem getNthItem(int index) => _staticInfo.callMethodOnReceiver('get_nth_item', this, [index]);
  void insert(ToolItem item, int position) => _staticInfo.callMethodOnReceiver('insert', this, [item, position]);
  void set collapsed(bool collapsed) => _staticInfo.callMethodOnReceiver('set_collapsed', this, [collapsed]);
  void set ellipsize(EllipsizeMode ellipsize) => _staticInfo.callMethodOnReceiver('set_ellipsize', this, [ellipsize]);
  void set headerRelief(ReliefStyle style) => _staticInfo.callMethodOnReceiver('set_header_relief', this, [style]);
  void setItemPosition(ToolItem item, int position) => _staticInfo.callMethodOnReceiver('set_item_position', this, [item, position]);
  void set label(String label) => _staticInfo.callMethodOnReceiver('set_label', this, [label]);
  void set labelWidget(Widget labelWidget) => _staticInfo.callMethodOnReceiver('set_label_widget', this, [labelWidget]);
}

class ToolPalette extends Container with ImplementorIface, Buildable, Orientable, Scrollable {
  ToolPalette.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToolPalette');

  static const String ICON_SIZE_PROPERTY = 'icon-size';
  bool get iconSizeSet => _staticInfo.getGPropertyOnReceiver('icon-size-set', this);
  void set iconSizeSet(bool value) => _staticInfo.setGPropertyOnReceiver('icon-size-set', this, value);
  static const String ICON_SIZE_SET_PROPERTY = 'icon-size-set';
  ToolbarStyle get toolbarStyle => _staticInfo.getGPropertyOnReceiver('toolbar-style', this);
  void set toolbarStyle(ToolbarStyle value) => _staticInfo.setGPropertyOnReceiver('toolbar-style', this, value);
  static const String TOOLBAR_STYLE_PROPERTY = 'toolbar-style';
  factory ToolPalette() => _staticInfo.callStatic('new', []);
  static TargetEntry getDragTargetGroup() => _staticInfo.callStatic('get_drag_target_group', []);
  static TargetEntry getDragTargetItem() => _staticInfo.callStatic('get_drag_target_item', []);
  void addDragDest(Widget widget, DestDefaults flags, ToolPaletteDragTargets targets, DragAction actions) => _staticInfo.callMethodOnReceiver('add_drag_dest', this, [widget, flags, targets, actions]);
  Widget getDragItem(SelectionData selection) => _staticInfo.callMethodOnReceiver('get_drag_item', this, [selection]);
  ToolItemGroup getDropGroup(int x, int y) => _staticInfo.callMethodOnReceiver('get_drop_group', this, [x, y]);
  ToolItem getDropItem(int x, int y) => _staticInfo.callMethodOnReceiver('get_drop_item', this, [x, y]);
  bool getExclusive(ToolItemGroup group) => _staticInfo.callMethodOnReceiver('get_exclusive', this, [group]);
  bool getExpand(ToolItemGroup group) => _staticInfo.callMethodOnReceiver('get_expand', this, [group]);
  int getGroupPosition(ToolItemGroup group) => _staticInfo.callMethodOnReceiver('get_group_position', this, [group]);
  Adjustment getHadjustment() => _staticInfo.callMethodOnReceiver('get_hadjustment', this, []);
  int get iconSize => _staticInfo.callMethodOnReceiver('get_icon_size', this, []);
  ToolbarStyle getStyle() => _staticInfo.callMethodOnReceiver('get_style', this, []);
  Adjustment getVadjustment() => _staticInfo.callMethodOnReceiver('get_vadjustment', this, []);
  void setDragSource(ToolPaletteDragTargets targets) => _staticInfo.callMethodOnReceiver('set_drag_source', this, [targets]);
  void setExclusive(ToolItemGroup group, bool exclusive) => _staticInfo.callMethodOnReceiver('set_exclusive', this, [group, exclusive]);
  void setExpand(ToolItemGroup group, bool expand) => _staticInfo.callMethodOnReceiver('set_expand', this, [group, expand]);
  void setGroupPosition(ToolItemGroup group, int position) => _staticInfo.callMethodOnReceiver('set_group_position', this, [group, position]);
  void set iconSize(int iconSize) => _staticInfo.callMethodOnReceiver('set_icon_size', this, [iconSize]);
  void setStyle(ToolbarStyle style) => _staticInfo.callMethodOnReceiver('set_style', this, [style]);
  void unsetIconSize() => _staticInfo.callMethodOnReceiver('unset_icon_size', this, []);
  void unsetStyle() => _staticInfo.callMethodOnReceiver('unset_style', this, []);
}

class ToolPaletteDragTargets extends GEnumBase {
  const ToolPaletteDragTargets(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToolPaletteDragTargets');

  static const ToolPaletteDragTargets NULL = const ToolPaletteDragTargets(0);
  static const ToolPaletteDragTargets ITEMS = const ToolPaletteDragTargets(1);
  bool get items => (index & 1) == 1;
  static const ToolPaletteDragTargets GROUPS = const ToolPaletteDragTargets(2);
  bool get groups => (index & 2) == 2;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'ToolPaletteDragTargets.ITEMS';
      case 2: return 'ToolPaletteDragTargets.GROUPS';
      default: return 'new ToolPaletteDragTargets($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'ToolPaletteDragTargets.NULL';
    }
    List codes = [];
    for (var i=1; i <= 2; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  ToolPaletteDragTargets operator|(ToolPaletteDragTargets other) =>
    new ToolPaletteDragTargets(index | other.index);
  ToolPaletteDragTargets operator&(ToolPaletteDragTargets other) =>
    new ToolPaletteDragTargets(index & other.index);
}

abstract class ToolShell extends GObjectBase implements Widget {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToolShell');



  EllipsizeMode getEllipsizeMode() => _staticInfo.callMethodOnReceiver('get_ellipsize_mode', this, []);
  int getIconSize() => _staticInfo.callMethodOnReceiver('get_icon_size', this, []);
  Orientation getOrientation() => _staticInfo.callMethodOnReceiver('get_orientation', this, []);
  ReliefStyle getReliefStyle() => _staticInfo.callMethodOnReceiver('get_relief_style', this, []);
  ToolbarStyle getStyle() => _staticInfo.callMethodOnReceiver('get_style', this, []);
  num getTextAlignment() => _staticInfo.callMethodOnReceiver('get_text_alignment', this, []);
  Orientation getTextOrientation() => _staticInfo.callMethodOnReceiver('get_text_orientation', this, []);
  SizeGroup getTextSizeGroup() => _staticInfo.callMethodOnReceiver('get_text_size_group', this, []);
  void rebuildMenu() => _staticInfo.callMethodOnReceiver('rebuild_menu', this, []);
}

class Toolbar extends Container with ImplementorIface, Buildable, Orientable, ToolShell {
  Toolbar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Toolbar');

  static const String ICON_SIZE_PROPERTY = 'icon-size';
  bool get iconSizeSet => _staticInfo.getGPropertyOnReceiver('icon-size-set', this);
  void set iconSizeSet(bool value) => _staticInfo.setGPropertyOnReceiver('icon-size-set', this, value);
  static const String ICON_SIZE_SET_PROPERTY = 'icon-size-set';
  static const String SHOW_ARROW_PROPERTY = 'show-arrow';
  ToolbarStyle get toolbarStyle => _staticInfo.getGPropertyOnReceiver('toolbar-style', this);
  void set toolbarStyle(ToolbarStyle value) => _staticInfo.setGPropertyOnReceiver('toolbar-style', this, value);
  static const String TOOLBAR_STYLE_PROPERTY = 'toolbar-style';
  factory Toolbar() => _staticInfo.callStatic('new', []);
  int getDropIndex(int x, int y) => _staticInfo.callMethodOnReceiver('get_drop_index', this, [x, y]);
  IconSize get iconSize => _staticInfo.callMethodOnReceiver('get_icon_size', this, []);
  int getItemIndex(ToolItem item) => _staticInfo.callMethodOnReceiver('get_item_index', this, [item]);
  int getNItems() => _staticInfo.callMethodOnReceiver('get_n_items', this, []);
  ToolItem getNthItem(int n) => _staticInfo.callMethodOnReceiver('get_nth_item', this, [n]);
  ReliefStyle getReliefStyle() => _staticInfo.callMethodOnReceiver('get_relief_style', this, []);
  bool get showArrow => _staticInfo.callMethodOnReceiver('get_show_arrow', this, []);
  ToolbarStyle getStyle() => _staticInfo.callMethodOnReceiver('get_style', this, []);
  void insert(ToolItem item, int pos) => _staticInfo.callMethodOnReceiver('insert', this, [item, pos]);
  void setDropHighlightItem(ToolItem toolItem, int index_) => _staticInfo.callMethodOnReceiver('set_drop_highlight_item', this, [toolItem, index_]);
  void set iconSize(IconSize iconSize) => _staticInfo.callMethodOnReceiver('set_icon_size', this, [iconSize]);
  void set showArrow(bool showArrow) => _staticInfo.callMethodOnReceiver('set_show_arrow', this, [showArrow]);
  void setStyle(ToolbarStyle style) => _staticInfo.callMethodOnReceiver('set_style', this, [style]);
  void unsetIconSize() => _staticInfo.callMethodOnReceiver('unset_icon_size', this, []);
  void unsetStyle() => _staticInfo.callMethodOnReceiver('unset_style', this, []);
  int _connectToFocusHomeOrEnd(bool after, bool func(bool focusHome)) => signalConnect('focus-home-or-end', func, after);
  Stream<ToolbarFocusHomeOrEndEvent> get onFocusHomeOrEnd {
    int signalId;
    StreamController<ToolbarFocusHomeOrEndEvent> controller;
    controller = new StreamController<ToolbarFocusHomeOrEndEvent>(
      onListen: () {
          signalId = _connectToFocusHomeOrEnd(false, (bool focusHome) {
              var result = new ToolbarFocusHomeOrEndEvent(focusHome);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ToolbarFocusHomeOrEndEvent> get afterFocusHomeOrEnd {
    int signalId;
    StreamController<ToolbarFocusHomeOrEndEvent> controller;
    controller = new StreamController<ToolbarFocusHomeOrEndEvent>(
      onListen: () {
          signalId = _connectToFocusHomeOrEnd(true, (bool focusHome) {
              var result = new ToolbarFocusHomeOrEndEvent(focusHome);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToOrientationChanged(bool after, void func(Orientation orientation)) => signalConnect('orientation-changed', func, after);
  Stream<Orientation> get onOrientationChanged {
    int signalId;
    StreamController<Orientation> controller;
    controller = new StreamController<Orientation>(
      onListen: () {
          signalId = _connectToOrientationChanged(false, (Orientation orientation) {
              controller.add(orientation);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Orientation> get afterOrientationChanged {
    int signalId;
    StreamController<Orientation> controller;
    controller = new StreamController<Orientation>(
      onListen: () {
          signalId = _connectToOrientationChanged(true, (Orientation orientation) {
              controller.add(orientation);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPopupContextMenu(bool after, bool func(int x, int y, int button)) => signalConnect('popup-context-menu', func, after);
  Stream<ToolbarPopupContextMenuEvent> get onPopupContextMenu {
    int signalId;
    StreamController<ToolbarPopupContextMenuEvent> controller;
    controller = new StreamController<ToolbarPopupContextMenuEvent>(
      onListen: () {
          signalId = _connectToPopupContextMenu(false, (int x, int y, int button) {
              var result = new ToolbarPopupContextMenuEvent(x, y, button);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ToolbarPopupContextMenuEvent> get afterPopupContextMenu {
    int signalId;
    StreamController<ToolbarPopupContextMenuEvent> controller;
    controller = new StreamController<ToolbarPopupContextMenuEvent>(
      onListen: () {
          signalId = _connectToPopupContextMenu(true, (int x, int y, int button) {
              var result = new ToolbarPopupContextMenuEvent(x, y, button);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToStyleChanged(bool after, void func(ToolbarStyle style)) => signalConnect('style-changed', func, after);
  Stream<ToolbarStyle> get onStyleChanged {
    int signalId;
    StreamController<ToolbarStyle> controller;
    controller = new StreamController<ToolbarStyle>(
      onListen: () {
          signalId = _connectToStyleChanged(false, (ToolbarStyle style) {
              controller.add(style);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ToolbarStyle> get afterStyleChanged {
    int signalId;
    StreamController<ToolbarStyle> controller;
    controller = new StreamController<ToolbarStyle>(
      onListen: () {
          signalId = _connectToStyleChanged(true, (ToolbarStyle style) {
              controller.add(style);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class ToolbarFocusHomeOrEndEvent {
  final bool focusHome;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  ToolbarFocusHomeOrEndEvent(this.focusHome);
}

class ToolbarPopupContextMenuEvent {
  final int x;
  final int y;
  final int button;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  ToolbarPopupContextMenuEvent(this.x, this.y, this.button);
}

class ToolbarSpaceStyle extends GEnumBase {
  const ToolbarSpaceStyle(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToolbarSpaceStyle');

  static const ToolbarSpaceStyle EMPTY = const ToolbarSpaceStyle(0);
  static const ToolbarSpaceStyle LINE = const ToolbarSpaceStyle(1);
  String toString() {
    switch(index) {
      case 0: return 'ToolbarSpaceStyle.EMPTY';
      case 1: return 'ToolbarSpaceStyle.LINE';
      default: return 'new ToolbarSpaceStyle($index)';
    }
  }
}

class ToolbarStyle extends GEnumBase {
  const ToolbarStyle(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToolbarStyle');

  static const ToolbarStyle ICONS = const ToolbarStyle(0);
  static const ToolbarStyle TEXT = const ToolbarStyle(1);
  static const ToolbarStyle BOTH = const ToolbarStyle(2);
  static const ToolbarStyle BOTH_HORIZ = const ToolbarStyle(3);
  String toString() {
    switch(index) {
      case 0: return 'ToolbarStyle.ICONS';
      case 1: return 'ToolbarStyle.TEXT';
      case 2: return 'ToolbarStyle.BOTH';
      case 3: return 'ToolbarStyle.BOTH_HORIZ';
      default: return 'new ToolbarStyle($index)';
    }
  }
}

class Tooltip extends GObjectObject {
  Tooltip.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Tooltip');

  static void triggerTooltipQuery(Display display) => _staticInfo.callStatic('trigger_tooltip_query', [display]);
  void setCustom(Widget customWidget) => _staticInfo.callMethodOnReceiver('set_custom', this, [customWidget]);
  void setIcon(Pixbuf pixbuf) => _staticInfo.callMethodOnReceiver('set_icon', this, [pixbuf]);
  void setIconFromGicon(Icon gicon, int size) => _staticInfo.callMethodOnReceiver('set_icon_from_gicon', this, [gicon, size]);
  void setIconFromIconName(String iconName, int size) => _staticInfo.callMethodOnReceiver('set_icon_from_icon_name', this, [iconName, size]);
  void setIconFromStock(String stockId, int size) => _staticInfo.callMethodOnReceiver('set_icon_from_stock', this, [stockId, size]);
  void setMarkup(String markup) => _staticInfo.callMethodOnReceiver('set_markup', this, [markup]);
  void setText(String text) => _staticInfo.callMethodOnReceiver('set_text', this, [text]);
  void setTipArea(RectangleInt rect) => _staticInfo.callMethodOnReceiver('set_tip_area', this, [rect]);
}

class ToplevelAccessible extends AtkObject {
  ToplevelAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'ToplevelAccessible');

  GLibList /* this will fail */ getChildren() => _staticInfo.callMethodOnReceiver('get_children', this, []);
}

typedef String TranslateFunc(String path);
typedef void TreeCellDataFunc(TreeViewColumn treeColumn, CellRenderer cell, TreeModel treeModel, TreeIter iter);
typedef void TreeDestroyCountFunc(TreeView treeView, TreePath path, int children);
abstract class TreeDragDest extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeDragDest');



  bool dragDataReceived(TreePath dest, SelectionData selectionData) => _staticInfo.callMethodOnReceiver('drag_data_received', this, [dest, selectionData]);
  bool rowDropPossible(TreePath destPath, SelectionData selectionData) => _staticInfo.callMethodOnReceiver('row_drop_possible', this, [destPath, selectionData]);
}

abstract class TreeDragSource extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeDragSource');



  bool dragDataDelete(TreePath path) => _staticInfo.callMethodOnReceiver('drag_data_delete', this, [path]);
  bool dragDataGet(TreePath path, SelectionData selectionData) => _staticInfo.callMethodOnReceiver('drag_data_get', this, [path, selectionData]);
  bool rowDraggable(TreePath path) => _staticInfo.callMethodOnReceiver('row_draggable', this, [path]);
}

class TreeIter extends GObjectBase {
  TreeIter.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeIter');

  int get stamp => getFieldOfObject('stamp', 0);
  void set stamp(int value) => setFieldOfObject('stamp', 0, value);
  dynamic /* this will fail */ get userData => getFieldOfObject('user_data', 1);
  void set userData(dynamic value /* this will fail */) => setFieldOfObject('user_data', 1, value);
  dynamic /* this will fail */ get userData2 => getFieldOfObject('user_data2', 2);
  void set userData2(dynamic value /* this will fail */) => setFieldOfObject('user_data2', 2, value);
  dynamic /* this will fail */ get userData3 => getFieldOfObject('user_data3', 3);
  void set userData3(dynamic value /* this will fail */) => setFieldOfObject('user_data3', 3, value);
  TreeIter copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void free() => _staticInfo.callMethodOnReceiver('free', this, []);
}

typedef int TreeIterCompareFunc(TreeModel model, TreeIter a, TreeIter b);
abstract class TreeModel extends GObjectBase {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeModel');



  TreeModel filterNew(TreePath root) => _staticInfo.callMethodOnReceiver('filter_new', this, [root]);
  void foreach(TreeModelForeachFunc func) => _staticInfo.callMethodOnReceiver('foreach', this, [func]);
  int getColumnType(int index_) => _staticInfo.callMethodOnReceiver('get_column_type', this, [index_]);
  TreeModelFlags getFlags() => _staticInfo.callMethodOnReceiver('get_flags', this, []);
  bool getIter(TreePath path) => _staticInfo.callMethodOnReceiver('get_iter', this, [path]);
  bool getIterFirst() => _staticInfo.callMethodOnReceiver('get_iter_first', this, []);
  bool getIterFromString(String pathString) => _staticInfo.callMethodOnReceiver('get_iter_from_string', this, [pathString]);
  int getNColumns() => _staticInfo.callMethodOnReceiver('get_n_columns', this, []);
  TreePath getPath(TreeIter iter) => _staticInfo.callMethodOnReceiver('get_path', this, [iter]);
  String getStringFromIter(TreeIter iter) => _staticInfo.callMethodOnReceiver('get_string_from_iter', this, [iter]);
  void getValue(TreeIter iter, int column) => _staticInfo.callMethodOnReceiver('get_value', this, [iter, column]);
  bool iterChildren(TreeIter parent) => _staticInfo.callMethodOnReceiver('iter_children', this, [parent]);
  bool iterHasChild(TreeIter iter) => _staticInfo.callMethodOnReceiver('iter_has_child', this, [iter]);
  int iterNChildren(TreeIter iter) => _staticInfo.callMethodOnReceiver('iter_n_children', this, [iter]);
  bool iterNext(TreeIter iter) => _staticInfo.callMethodOnReceiver('iter_next', this, [iter]);
  bool iterNthChild(TreeIter parent, int n) => _staticInfo.callMethodOnReceiver('iter_nth_child', this, [parent, n]);
  bool iterParent(TreeIter child) => _staticInfo.callMethodOnReceiver('iter_parent', this, [child]);
  bool iterPrevious(TreeIter iter) => _staticInfo.callMethodOnReceiver('iter_previous', this, [iter]);
  void refNode(TreeIter iter) => _staticInfo.callMethodOnReceiver('ref_node', this, [iter]);
  void rowChanged(TreePath path, TreeIter iter) => _staticInfo.callMethodOnReceiver('row_changed', this, [path, iter]);
  void rowDeleted(TreePath path) => _staticInfo.callMethodOnReceiver('row_deleted', this, [path]);
  void rowHasChildToggled(TreePath path, TreeIter iter) => _staticInfo.callMethodOnReceiver('row_has_child_toggled', this, [path, iter]);
  void rowInserted(TreePath path, TreeIter iter) => _staticInfo.callMethodOnReceiver('row_inserted', this, [path, iter]);
  void rowsReordered(TreePath path, TreeIter iter, List<int> newOrder) => _staticInfo.callMethodOnReceiver('rows_reordered', this, [path, iter, newOrder]);
  TreeModel sortNewWithModel() => _staticInfo.callMethodOnReceiver('sort_new_with_model', this, []);
  void unrefNode(TreeIter iter) => _staticInfo.callMethodOnReceiver('unref_node', this, [iter]);
  int _connectToRowChanged(bool after, void func(TreePath path, TreeIter iter)) => signalConnect('row-changed', func, after);
  Stream<TreeModelRowChangedEvent> get onRowChanged {
    int signalId;
    StreamController<TreeModelRowChangedEvent> controller;
    controller = new StreamController<TreeModelRowChangedEvent>(
      onListen: () {
          signalId = _connectToRowChanged(false, (TreePath path, TreeIter iter) {
              var result = new TreeModelRowChangedEvent(path, iter);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeModelRowChangedEvent> get afterRowChanged {
    int signalId;
    StreamController<TreeModelRowChangedEvent> controller;
    controller = new StreamController<TreeModelRowChangedEvent>(
      onListen: () {
          signalId = _connectToRowChanged(true, (TreePath path, TreeIter iter) {
              var result = new TreeModelRowChangedEvent(path, iter);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRowDeleted(bool after, void func(TreePath path)) => signalConnect('row-deleted', func, after);
  Stream<TreePath> get onRowDeleted {
    int signalId;
    StreamController<TreePath> controller;
    controller = new StreamController<TreePath>(
      onListen: () {
          signalId = _connectToRowDeleted(false, (TreePath path) {
              controller.add(path);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreePath> get afterRowDeleted {
    int signalId;
    StreamController<TreePath> controller;
    controller = new StreamController<TreePath>(
      onListen: () {
          signalId = _connectToRowDeleted(true, (TreePath path) {
              controller.add(path);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRowHasChildToggled(bool after, void func(TreePath path, TreeIter iter)) => signalConnect('row-has-child-toggled', func, after);
  Stream<TreeModelRowHasChildToggledEvent> get onRowHasChildToggled {
    int signalId;
    StreamController<TreeModelRowHasChildToggledEvent> controller;
    controller = new StreamController<TreeModelRowHasChildToggledEvent>(
      onListen: () {
          signalId = _connectToRowHasChildToggled(false, (TreePath path, TreeIter iter) {
              var result = new TreeModelRowHasChildToggledEvent(path, iter);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeModelRowHasChildToggledEvent> get afterRowHasChildToggled {
    int signalId;
    StreamController<TreeModelRowHasChildToggledEvent> controller;
    controller = new StreamController<TreeModelRowHasChildToggledEvent>(
      onListen: () {
          signalId = _connectToRowHasChildToggled(true, (TreePath path, TreeIter iter) {
              var result = new TreeModelRowHasChildToggledEvent(path, iter);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRowInserted(bool after, void func(TreePath path, TreeIter iter)) => signalConnect('row-inserted', func, after);
  Stream<TreeModelRowInsertedEvent> get onRowInserted {
    int signalId;
    StreamController<TreeModelRowInsertedEvent> controller;
    controller = new StreamController<TreeModelRowInsertedEvent>(
      onListen: () {
          signalId = _connectToRowInserted(false, (TreePath path, TreeIter iter) {
              var result = new TreeModelRowInsertedEvent(path, iter);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeModelRowInsertedEvent> get afterRowInserted {
    int signalId;
    StreamController<TreeModelRowInsertedEvent> controller;
    controller = new StreamController<TreeModelRowInsertedEvent>(
      onListen: () {
          signalId = _connectToRowInserted(true, (TreePath path, TreeIter iter) {
              var result = new TreeModelRowInsertedEvent(path, iter);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class TreeModelRowChangedEvent {
  final TreePath path;
  final TreeIter iter;

  TreeModelRowChangedEvent(this.path, this.iter);
}

class TreeModelRowHasChildToggledEvent {
  final TreePath path;
  final TreeIter iter;

  TreeModelRowHasChildToggledEvent(this.path, this.iter);
}

class TreeModelRowInsertedEvent {
  final TreePath path;
  final TreeIter iter;

  TreeModelRowInsertedEvent(this.path, this.iter);
}

class TreeModelFilter extends GObjectObject with TreeDragSource, TreeModel {
  TreeModelFilter.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeModelFilter');

  TreeModel get childModel => _staticInfo.getGPropertyOnReceiver('child-model', this);
  void set childModel(TreeModel value) => _staticInfo.setGPropertyOnReceiver('child-model', this, value);
  static const String CHILD_MODEL_PROPERTY = 'child-model';
  TreePath get virtualRoot => _staticInfo.getGPropertyOnReceiver('virtual-root', this);
  void set virtualRoot(TreePath value) => _staticInfo.setGPropertyOnReceiver('virtual-root', this, value);
  static const String VIRTUAL_ROOT_PROPERTY = 'virtual-root';
  void clearCache() => _staticInfo.callMethodOnReceiver('clear_cache', this, []);
  bool convertChildIterToIter(TreeIter childIter) => _staticInfo.callMethodOnReceiver('convert_child_iter_to_iter', this, [childIter]);
  TreePath convertChildPathToPath(TreePath childPath) => _staticInfo.callMethodOnReceiver('convert_child_path_to_path', this, [childPath]);
  void convertIterToChildIter(TreeIter filterIter) => _staticInfo.callMethodOnReceiver('convert_iter_to_child_iter', this, [filterIter]);
  TreePath convertPathToChildPath(TreePath filterPath) => _staticInfo.callMethodOnReceiver('convert_path_to_child_path', this, [filterPath]);
  TreeModel getModel() => _staticInfo.callMethodOnReceiver('get_model', this, []);
  void refilter() => _staticInfo.callMethodOnReceiver('refilter', this, []);
  void setModifyFunc(List<int> types, TreeModelFilterModifyFunc func) => _staticInfo.callMethodOnReceiver('set_modify_func', this, [types, func]);
  void setVisibleColumn(int column) => _staticInfo.callMethodOnReceiver('set_visible_column', this, [column]);
  void setVisibleFunc(TreeModelFilterVisibleFunc func) => _staticInfo.callMethodOnReceiver('set_visible_func', this, [func]);
}

typedef Value TreeModelFilterModifyFunc(TreeModel model, TreeIter iter, int column);
typedef bool TreeModelFilterVisibleFunc(TreeModel model, TreeIter iter);
class TreeModelFlags extends GEnumBase {
  const TreeModelFlags(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeModelFlags');

  static const TreeModelFlags NULL = const TreeModelFlags(0);
  static const TreeModelFlags ITERS_PERSIST = const TreeModelFlags(1);
  bool get itersPersist => (index & 1) == 1;
  static const TreeModelFlags LIST_ONLY = const TreeModelFlags(2);
  bool get listOnly => (index & 2) == 2;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'TreeModelFlags.ITERS_PERSIST';
      case 2: return 'TreeModelFlags.LIST_ONLY';
      default: return 'new TreeModelFlags($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'TreeModelFlags.NULL';
    }
    List codes = [];
    for (var i=1; i <= 2; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  TreeModelFlags operator|(TreeModelFlags other) =>
    new TreeModelFlags(index | other.index);
  TreeModelFlags operator&(TreeModelFlags other) =>
    new TreeModelFlags(index & other.index);
}

typedef bool TreeModelForeachFunc(TreeModel model, TreePath path, TreeIter iter);
class TreeModelSort extends GObjectObject with TreeDragSource, TreeModel, TreeSortable {
  TreeModelSort.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeModelSort');

  void set model(TreeModel value) => _staticInfo.setGPropertyOnReceiver('model', this, value);
  static const String MODEL_PROPERTY = 'model';
  void clearCache() => _staticInfo.callMethodOnReceiver('clear_cache', this, []);
  bool convertChildIterToIter(TreeIter childIter) => _staticInfo.callMethodOnReceiver('convert_child_iter_to_iter', this, [childIter]);
  TreePath convertChildPathToPath(TreePath childPath) => _staticInfo.callMethodOnReceiver('convert_child_path_to_path', this, [childPath]);
  void convertIterToChildIter(TreeIter sortedIter) => _staticInfo.callMethodOnReceiver('convert_iter_to_child_iter', this, [sortedIter]);
  TreePath convertPathToChildPath(TreePath sortedPath) => _staticInfo.callMethodOnReceiver('convert_path_to_child_path', this, [sortedPath]);
  TreeModel get model_ => _staticInfo.callMethodOnReceiver('get_model', this, []);
  bool iterIsValid(TreeIter iter) => _staticInfo.callMethodOnReceiver('iter_is_valid', this, [iter]);
  void resetDefaultSortFunc() => _staticInfo.callMethodOnReceiver('reset_default_sort_func', this, []);
}

class TreePath extends GObjectBase {
  TreePath.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreePath');

  factory TreePath() => _staticInfo.callStatic('new', []);
  factory TreePath.first() => _staticInfo.callStatic('new_first', []);
  factory TreePath.fromIndices(List<int> indices) => _staticInfo.callStatic('new_from_indices', [indices]);
  factory TreePath.fromString(String path) => _staticInfo.callStatic('new_from_string', [path]);
  void appendIndex(int index_) => _staticInfo.callMethodOnReceiver('append_index', this, [index_]);
  int compare(TreePath b) => _staticInfo.callMethodOnReceiver('compare', this, [b]);
  TreePath copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void down() => _staticInfo.callMethodOnReceiver('down', this, []);
  void free() => _staticInfo.callMethodOnReceiver('free', this, []);
  int getDepth() => _staticInfo.callMethodOnReceiver('get_depth', this, []);
  List<int> getIndices() => _staticInfo.callMethodOnReceiver('get_indices', this, []);
  bool isAncestor(TreePath descendant) => _staticInfo.callMethodOnReceiver('is_ancestor', this, [descendant]);
  bool isDescendant(TreePath ancestor) => _staticInfo.callMethodOnReceiver('is_descendant', this, [ancestor]);
  void next() => _staticInfo.callMethodOnReceiver('next', this, []);
  void prependIndex(int index_) => _staticInfo.callMethodOnReceiver('prepend_index', this, [index_]);
  bool prev() => _staticInfo.callMethodOnReceiver('prev', this, []);
  String toString() => _staticInfo.callMethodOnReceiver('to_string', this, []);
  bool up() => _staticInfo.callMethodOnReceiver('up', this, []);
}

class TreeRowReference extends GObjectBase {
  TreeRowReference.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeRowReference');

  factory TreeRowReference(TreeModel model, TreePath path) => _staticInfo.callStatic('new', [model, path]);
  factory TreeRowReference.proxy(GObjectObject proxy, TreeModel model, TreePath path) => _staticInfo.callStatic('new_proxy', [proxy, model, path]);
  TreeRowReference copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void free() => _staticInfo.callMethodOnReceiver('free', this, []);
  TreeModel getModel() => _staticInfo.callMethodOnReceiver('get_model', this, []);
  TreePath getPath() => _staticInfo.callMethodOnReceiver('get_path', this, []);
  bool valid() => _staticInfo.callMethodOnReceiver('valid', this, []);
  static void deleted(GObjectObject proxy, TreePath path) => _staticInfo.callStatic('deleted', [proxy, path]);
  static void inserted(GObjectObject proxy, TreePath path) => _staticInfo.callStatic('inserted', [proxy, path]);
}

class TreeSelection extends GObjectObject {
  TreeSelection.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeSelection');

  static const String MODE_PROPERTY = 'mode';
  int countSelectedRows() => _staticInfo.callMethodOnReceiver('count_selected_rows', this, []);
  SelectionMode get mode => _staticInfo.callMethodOnReceiver('get_mode', this, []);
  bool getSelected() => _staticInfo.callMethodOnReceiver('get_selected', this, []);
  GLibList /* this will fail */ getSelectedRows() => _staticInfo.callMethodOnReceiver('get_selected_rows', this, []);
  TreeView getTreeView() => _staticInfo.callMethodOnReceiver('get_tree_view', this, []);
  bool iterIsSelected(TreeIter iter) => _staticInfo.callMethodOnReceiver('iter_is_selected', this, [iter]);
  bool pathIsSelected(TreePath path) => _staticInfo.callMethodOnReceiver('path_is_selected', this, [path]);
  void selectAll() => _staticInfo.callMethodOnReceiver('select_all', this, []);
  void selectIter(TreeIter iter) => _staticInfo.callMethodOnReceiver('select_iter', this, [iter]);
  void selectPath(TreePath path) => _staticInfo.callMethodOnReceiver('select_path', this, [path]);
  void selectRange(TreePath startPath, TreePath endPath) => _staticInfo.callMethodOnReceiver('select_range', this, [startPath, endPath]);
  void selectedForeach(TreeSelectionForeachFunc func) => _staticInfo.callMethodOnReceiver('selected_foreach', this, [func]);
  void set mode(SelectionMode type) => _staticInfo.callMethodOnReceiver('set_mode', this, [type]);
  void setSelectFunction(TreeSelectionFunc func) => _staticInfo.callMethodOnReceiver('set_select_function', this, [func]);
  void unselectAll() => _staticInfo.callMethodOnReceiver('unselect_all', this, []);
  void unselectIter(TreeIter iter) => _staticInfo.callMethodOnReceiver('unselect_iter', this, [iter]);
  void unselectPath(TreePath path) => _staticInfo.callMethodOnReceiver('unselect_path', this, [path]);
  void unselectRange(TreePath startPath, TreePath endPath) => _staticInfo.callMethodOnReceiver('unselect_range', this, [startPath, endPath]);
  int _connectToChanged(bool after, void func()) => signalConnect('changed', func, after);
  Stream get onChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

typedef void TreeSelectionForeachFunc(TreeModel model, TreePath path, TreeIter iter);
typedef bool TreeSelectionFunc(TreeSelection selection, TreeModel model, TreePath path, bool pathCurrentlySelected);
abstract class TreeSortable extends GObjectBase implements TreeModel {
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeSortable');



  bool getSortColumnId() => _staticInfo.callMethodOnReceiver('get_sort_column_id', this, []);
  bool hasDefaultSortFunc() => _staticInfo.callMethodOnReceiver('has_default_sort_func', this, []);
  void setDefaultSortFunc(TreeIterCompareFunc sortFunc) => _staticInfo.callMethodOnReceiver('set_default_sort_func', this, [sortFunc]);
  void setSortColumnId(int sortColumnId, SortType order) => _staticInfo.callMethodOnReceiver('set_sort_column_id', this, [sortColumnId, order]);
  void setSortFunc(int sortColumnId, TreeIterCompareFunc sortFunc) => _staticInfo.callMethodOnReceiver('set_sort_func', this, [sortColumnId, sortFunc]);
  void sortColumnChanged() => _staticInfo.callMethodOnReceiver('sort_column_changed', this, []);
  int _connectToSortColumnChanged(bool after, void func()) => signalConnect('sort-column-changed', func, after);
  Stream get onSortColumnChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSortColumnChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterSortColumnChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToSortColumnChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class TreeStore extends GObjectObject with Buildable, TreeDragDest, TreeDragSource, TreeModel, TreeSortable {
  TreeStore.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeStore');

  factory TreeStore(List<int> types) => _staticInfo.callStatic('new', [types]);
  void append(TreeIter parent) => _staticInfo.callMethodOnReceiver('append', this, [parent]);
  void clear() => _staticInfo.callMethodOnReceiver('clear', this, []);
  void insert(TreeIter parent, int position) => _staticInfo.callMethodOnReceiver('insert', this, [parent, position]);
  void insertAfter(TreeIter parent, TreeIter sibling) => _staticInfo.callMethodOnReceiver('insert_after', this, [parent, sibling]);
  void insertBefore(TreeIter parent, TreeIter sibling) => _staticInfo.callMethodOnReceiver('insert_before', this, [parent, sibling]);
  void insertWithValues(TreeIter parent, int position, List<int> columns, List<Value> values) => _staticInfo.callMethodOnReceiver('insert_with_values', this, [parent, position, columns, values]);
  bool isAncestor(TreeIter iter, TreeIter descendant) => _staticInfo.callMethodOnReceiver('is_ancestor', this, [iter, descendant]);
  int iterDepth(TreeIter iter) => _staticInfo.callMethodOnReceiver('iter_depth', this, [iter]);
  bool iterIsValid(TreeIter iter) => _staticInfo.callMethodOnReceiver('iter_is_valid', this, [iter]);
  void moveAfter(TreeIter iter, TreeIter position) => _staticInfo.callMethodOnReceiver('move_after', this, [iter, position]);
  void moveBefore(TreeIter iter, TreeIter position) => _staticInfo.callMethodOnReceiver('move_before', this, [iter, position]);
  void prepend(TreeIter parent) => _staticInfo.callMethodOnReceiver('prepend', this, [parent]);
  bool remove(TreeIter iter) => _staticInfo.callMethodOnReceiver('remove', this, [iter]);
  void setColumnTypes(List<int> types) => _staticInfo.callMethodOnReceiver('set_column_types', this, [types]);
  void setValue(TreeIter iter, int column, Value value) => _staticInfo.callMethodOnReceiver('set_value', this, [iter, column, value]);
  void set_(TreeIter iter, List<int> columns, List<Value> values) => _staticInfo.callMethodOnReceiver('set', this, [iter, columns, values]);
  void swap(TreeIter a, TreeIter b) => _staticInfo.callMethodOnReceiver('swap', this, [a, b]);
}

class TreeView extends Container with ImplementorIface, Buildable, Scrollable {
  TreeView.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeView');

  static const String ACTIVATE_ON_SINGLE_CLICK_PROPERTY = 'activate-on-single-click';
  TreeViewGridLines get enableGridLines => _staticInfo.getGPropertyOnReceiver('enable-grid-lines', this);
  void set enableGridLines(TreeViewGridLines value) => _staticInfo.setGPropertyOnReceiver('enable-grid-lines', this, value);
  static const String ENABLE_GRID_LINES_PROPERTY = 'enable-grid-lines';
  static const String ENABLE_SEARCH_PROPERTY = 'enable-search';
  static const String ENABLE_TREE_LINES_PROPERTY = 'enable-tree-lines';
  static const String EXPANDER_COLUMN_PROPERTY = 'expander-column';
  static const String FIXED_HEIGHT_MODE_PROPERTY = 'fixed-height-mode';
  static const String HEADERS_CLICKABLE_PROPERTY = 'headers-clickable';
  static const String HEADERS_VISIBLE_PROPERTY = 'headers-visible';
  static const String HOVER_EXPAND_PROPERTY = 'hover-expand';
  static const String HOVER_SELECTION_PROPERTY = 'hover-selection';
  static const String LEVEL_INDENTATION_PROPERTY = 'level-indentation';
  static const String MODEL_PROPERTY = 'model';
  static const String REORDERABLE_PROPERTY = 'reorderable';
  static const String RUBBER_BANDING_PROPERTY = 'rubber-banding';
  static const String RULES_HINT_PROPERTY = 'rules-hint';
  static const String SEARCH_COLUMN_PROPERTY = 'search-column';
  static const String SHOW_EXPANDERS_PROPERTY = 'show-expanders';
  static const String TOOLTIP_COLUMN_PROPERTY = 'tooltip-column';
  factory TreeView() => _staticInfo.callStatic('new', []);
  factory TreeView.withModel(TreeModel model) => _staticInfo.callStatic('new_with_model', [model]);
  int appendColumn(TreeViewColumn column) => _staticInfo.callMethodOnReceiver('append_column', this, [column]);
  void collapseAll() => _staticInfo.callMethodOnReceiver('collapse_all', this, []);
  bool collapseRow(TreePath path) => _staticInfo.callMethodOnReceiver('collapse_row', this, [path]);
  void columnsAutosize() => _staticInfo.callMethodOnReceiver('columns_autosize', this, []);
  void convertBinWindowToTreeCoords(int bx, int by) => _staticInfo.callMethodOnReceiver('convert_bin_window_to_tree_coords', this, [bx, by]);
  void convertBinWindowToWidgetCoords(int bx, int by) => _staticInfo.callMethodOnReceiver('convert_bin_window_to_widget_coords', this, [bx, by]);
  void convertTreeToBinWindowCoords(int tx, int ty) => _staticInfo.callMethodOnReceiver('convert_tree_to_bin_window_coords', this, [tx, ty]);
  void convertTreeToWidgetCoords(int tx, int ty) => _staticInfo.callMethodOnReceiver('convert_tree_to_widget_coords', this, [tx, ty]);
  void convertWidgetToBinWindowCoords(int wx, int wy) => _staticInfo.callMethodOnReceiver('convert_widget_to_bin_window_coords', this, [wx, wy]);
  void convertWidgetToTreeCoords(int wx, int wy) => _staticInfo.callMethodOnReceiver('convert_widget_to_tree_coords', this, [wx, wy]);
  Surface createRowDragIcon(TreePath path) => _staticInfo.callMethodOnReceiver('create_row_drag_icon', this, [path]);
  void enableModelDragDest(List<TargetEntry> targets, DragAction actions) => _staticInfo.callMethodOnReceiver('enable_model_drag_dest', this, [targets, actions]);
  void enableModelDragSource(ModifierType startButtonMask, List<TargetEntry> targets, DragAction actions) => _staticInfo.callMethodOnReceiver('enable_model_drag_source', this, [startButtonMask, targets, actions]);
  void expandAll() => _staticInfo.callMethodOnReceiver('expand_all', this, []);
  bool expandRow(TreePath path, bool openAll) => _staticInfo.callMethodOnReceiver('expand_row', this, [path, openAll]);
  void expandToPath(TreePath path) => _staticInfo.callMethodOnReceiver('expand_to_path', this, [path]);
  bool get activateOnSingleClick => _staticInfo.callMethodOnReceiver('get_activate_on_single_click', this, []);
  void getBackgroundArea(TreePath path, TreeViewColumn column) => _staticInfo.callMethodOnReceiver('get_background_area', this, [path, column]);
  gdk.Window getBinWindow() => _staticInfo.callMethodOnReceiver('get_bin_window', this, []);
  void getCellArea(TreePath path, TreeViewColumn column) => _staticInfo.callMethodOnReceiver('get_cell_area', this, [path, column]);
  TreeViewColumn getColumn(int n) => _staticInfo.callMethodOnReceiver('get_column', this, [n]);
  GLibList /* this will fail */ getColumns() => _staticInfo.callMethodOnReceiver('get_columns', this, []);
  void getCursor() => _staticInfo.callMethodOnReceiver('get_cursor', this, []);
  bool getDestRowAtPos(int dragX, int dragY) => _staticInfo.callMethodOnReceiver('get_dest_row_at_pos', this, [dragX, dragY]);
  void getDragDestRow() => _staticInfo.callMethodOnReceiver('get_drag_dest_row', this, []);
  bool get enableSearch => _staticInfo.callMethodOnReceiver('get_enable_search', this, []);
  bool get enableTreeLines => _staticInfo.callMethodOnReceiver('get_enable_tree_lines', this, []);
  TreeViewColumn get expanderColumn => _staticInfo.callMethodOnReceiver('get_expander_column', this, []);
  bool get fixedHeightMode => _staticInfo.callMethodOnReceiver('get_fixed_height_mode', this, []);
  TreeViewGridLines getGridLines() => _staticInfo.callMethodOnReceiver('get_grid_lines', this, []);
  Adjustment getHadjustment() => _staticInfo.callMethodOnReceiver('get_hadjustment', this, []);
  bool get headersClickable => _staticInfo.callMethodOnReceiver('get_headers_clickable', this, []);
  bool get headersVisible => _staticInfo.callMethodOnReceiver('get_headers_visible', this, []);
  bool get hoverExpand => _staticInfo.callMethodOnReceiver('get_hover_expand', this, []);
  bool get hoverSelection => _staticInfo.callMethodOnReceiver('get_hover_selection', this, []);
  int get levelIndentation => _staticInfo.callMethodOnReceiver('get_level_indentation', this, []);
  TreeModel get model => _staticInfo.callMethodOnReceiver('get_model', this, []);
  int getNColumns() => _staticInfo.callMethodOnReceiver('get_n_columns', this, []);
  bool getPathAtPos(int x, int y) => _staticInfo.callMethodOnReceiver('get_path_at_pos', this, [x, y]);
  bool get reorderable => _staticInfo.callMethodOnReceiver('get_reorderable', this, []);
  bool get rubberBanding => _staticInfo.callMethodOnReceiver('get_rubber_banding', this, []);
  bool get rulesHint => _staticInfo.callMethodOnReceiver('get_rules_hint', this, []);
  int get searchColumn => _staticInfo.callMethodOnReceiver('get_search_column', this, []);
  Entry getSearchEntry() => _staticInfo.callMethodOnReceiver('get_search_entry', this, []);
  TreeSelection getSelection() => _staticInfo.callMethodOnReceiver('get_selection', this, []);
  bool get showExpanders => _staticInfo.callMethodOnReceiver('get_show_expanders', this, []);
  int get tooltipColumn => _staticInfo.callMethodOnReceiver('get_tooltip_column', this, []);
  bool getTooltipContext(int x, int y, bool keyboardTip) => _staticInfo.callMethodOnReceiver('get_tooltip_context', this, [x, y, keyboardTip]);
  Adjustment getVadjustment() => _staticInfo.callMethodOnReceiver('get_vadjustment', this, []);
  bool getVisibleRange() => _staticInfo.callMethodOnReceiver('get_visible_range', this, []);
  void getVisibleRect() => _staticInfo.callMethodOnReceiver('get_visible_rect', this, []);
  int insertColumn(TreeViewColumn column, int position) => _staticInfo.callMethodOnReceiver('insert_column', this, [column, position]);
  int insertColumnWithDataFunc(int position, String title, CellRenderer cell, TreeCellDataFunc func) => _staticInfo.callMethodOnReceiver('insert_column_with_data_func', this, [position, title, cell, func]);
  bool isBlankAtPos(int x, int y) => _staticInfo.callMethodOnReceiver('is_blank_at_pos', this, [x, y]);
  bool isRubberBandingActive() => _staticInfo.callMethodOnReceiver('is_rubber_banding_active', this, []);
  void mapExpandedRows(TreeViewMappingFunc func) => _staticInfo.callMethodOnReceiver('map_expanded_rows', this, [func]);
  void moveColumnAfter(TreeViewColumn column, TreeViewColumn baseColumn) => _staticInfo.callMethodOnReceiver('move_column_after', this, [column, baseColumn]);
  int removeColumn(TreeViewColumn column) => _staticInfo.callMethodOnReceiver('remove_column', this, [column]);
  void rowActivated(TreePath path, TreeViewColumn column) => _staticInfo.callMethodOnReceiver('row_activated', this, [path, column]);
  bool rowExpanded(TreePath path) => _staticInfo.callMethodOnReceiver('row_expanded', this, [path]);
  void scrollToCell(TreePath path, TreeViewColumn column, bool useAlign, num rowAlign, num colAlign) => _staticInfo.callMethodOnReceiver('scroll_to_cell', this, [path, column, useAlign, rowAlign, colAlign]);
  void scrollToPoint(int treeX, int treeY) => _staticInfo.callMethodOnReceiver('scroll_to_point', this, [treeX, treeY]);
  void set activateOnSingleClick(bool single) => _staticInfo.callMethodOnReceiver('set_activate_on_single_click', this, [single]);
  void setColumnDragFunction(TreeViewColumnDropFunc func) => _staticInfo.callMethodOnReceiver('set_column_drag_function', this, [func]);
  void setCursor(TreePath path, TreeViewColumn focusColumn, bool startEditing) => _staticInfo.callMethodOnReceiver('set_cursor', this, [path, focusColumn, startEditing]);
  void setCursorOnCell(TreePath path, TreeViewColumn focusColumn, CellRenderer focusCell, bool startEditing) => _staticInfo.callMethodOnReceiver('set_cursor_on_cell', this, [path, focusColumn, focusCell, startEditing]);
  void setDestroyCountFunc(TreeDestroyCountFunc func) => _staticInfo.callMethodOnReceiver('set_destroy_count_func', this, [func]);
  void setDragDestRow(TreePath path, TreeViewDropPosition pos) => _staticInfo.callMethodOnReceiver('set_drag_dest_row', this, [path, pos]);
  void set enableSearch(bool enableSearch) => _staticInfo.callMethodOnReceiver('set_enable_search', this, [enableSearch]);
  void set enableTreeLines(bool enabled) => _staticInfo.callMethodOnReceiver('set_enable_tree_lines', this, [enabled]);
  void set expanderColumn(TreeViewColumn column) => _staticInfo.callMethodOnReceiver('set_expander_column', this, [column]);
  void set fixedHeightMode(bool enable) => _staticInfo.callMethodOnReceiver('set_fixed_height_mode', this, [enable]);
  void setGridLines(TreeViewGridLines gridLines) => _staticInfo.callMethodOnReceiver('set_grid_lines', this, [gridLines]);
  void setHadjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_hadjustment', this, [adjustment]);
  void set headersClickable(bool setting) => _staticInfo.callMethodOnReceiver('set_headers_clickable', this, [setting]);
  void set headersVisible(bool headersVisible) => _staticInfo.callMethodOnReceiver('set_headers_visible', this, [headersVisible]);
  void set hoverExpand(bool expand) => _staticInfo.callMethodOnReceiver('set_hover_expand', this, [expand]);
  void set hoverSelection(bool hover) => _staticInfo.callMethodOnReceiver('set_hover_selection', this, [hover]);
  void set levelIndentation(int indentation) => _staticInfo.callMethodOnReceiver('set_level_indentation', this, [indentation]);
  void set model(TreeModel model) => _staticInfo.callMethodOnReceiver('set_model', this, [model]);
  void set reorderable(bool reorderable) => _staticInfo.callMethodOnReceiver('set_reorderable', this, [reorderable]);
  void setRowSeparatorFunc(TreeViewRowSeparatorFunc func) => _staticInfo.callMethodOnReceiver('set_row_separator_func', this, [func]);
  void set rubberBanding(bool enable) => _staticInfo.callMethodOnReceiver('set_rubber_banding', this, [enable]);
  void set rulesHint(bool setting) => _staticInfo.callMethodOnReceiver('set_rules_hint', this, [setting]);
  void set searchColumn(int column) => _staticInfo.callMethodOnReceiver('set_search_column', this, [column]);
  void setSearchEntry(Entry entry) => _staticInfo.callMethodOnReceiver('set_search_entry', this, [entry]);
  void setSearchEqualFunc(TreeViewSearchEqualFunc searchEqualFunc) => _staticInfo.callMethodOnReceiver('set_search_equal_func', this, [searchEqualFunc]);
  void setSearchPositionFunc(TreeViewSearchPositionFunc func) => _staticInfo.callMethodOnReceiver('set_search_position_func', this, [func]);
  void set showExpanders(bool enabled) => _staticInfo.callMethodOnReceiver('set_show_expanders', this, [enabled]);
  void setTooltipCell(Tooltip tooltip, TreePath path, TreeViewColumn column, CellRenderer cell) => _staticInfo.callMethodOnReceiver('set_tooltip_cell', this, [tooltip, path, column, cell]);
  void set tooltipColumn(int column) => _staticInfo.callMethodOnReceiver('set_tooltip_column', this, [column]);
  void setTooltipRow(Tooltip tooltip, TreePath path) => _staticInfo.callMethodOnReceiver('set_tooltip_row', this, [tooltip, path]);
  void setVadjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_vadjustment', this, [adjustment]);
  void unsetRowsDragDest() => _staticInfo.callMethodOnReceiver('unset_rows_drag_dest', this, []);
  void unsetRowsDragSource() => _staticInfo.callMethodOnReceiver('unset_rows_drag_source', this, []);
  int _connectToColumnsChanged(bool after, void func()) => signalConnect('columns-changed', func, after);
  Stream get onColumnsChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToColumnsChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterColumnsChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToColumnsChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCursorChanged(bool after, void func()) => signalConnect('cursor-changed', func, after);
  Stream get onCursorChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCursorChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterCursorChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCursorChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToExpandCollapseCursorRow(bool after, bool func(bool object, bool p0, bool p1)) => signalConnect('expand-collapse-cursor-row', func, after);
  Stream<TreeViewExpandCollapseCursorRowEvent> get onExpandCollapseCursorRow {
    int signalId;
    StreamController<TreeViewExpandCollapseCursorRowEvent> controller;
    controller = new StreamController<TreeViewExpandCollapseCursorRowEvent>(
      onListen: () {
          signalId = _connectToExpandCollapseCursorRow(false, (bool object, bool p0, bool p1) {
              var result = new TreeViewExpandCollapseCursorRowEvent(object, p0, p1);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeViewExpandCollapseCursorRowEvent> get afterExpandCollapseCursorRow {
    int signalId;
    StreamController<TreeViewExpandCollapseCursorRowEvent> controller;
    controller = new StreamController<TreeViewExpandCollapseCursorRowEvent>(
      onListen: () {
          signalId = _connectToExpandCollapseCursorRow(true, (bool object, bool p0, bool p1) {
              var result = new TreeViewExpandCollapseCursorRowEvent(object, p0, p1);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveCursor(bool after, bool func(MovementStep step, int direction)) => signalConnect('move-cursor', func, after);
  Stream<TreeViewMoveCursorEvent> get onMoveCursor {
    int signalId;
    StreamController<TreeViewMoveCursorEvent> controller;
    controller = new StreamController<TreeViewMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(false, (MovementStep step, int direction) {
              var result = new TreeViewMoveCursorEvent(step, direction);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeViewMoveCursorEvent> get afterMoveCursor {
    int signalId;
    StreamController<TreeViewMoveCursorEvent> controller;
    controller = new StreamController<TreeViewMoveCursorEvent>(
      onListen: () {
          signalId = _connectToMoveCursor(true, (MovementStep step, int direction) {
              var result = new TreeViewMoveCursorEvent(step, direction);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRowActivated(bool after, void func(TreePath path, TreeViewColumn column)) => signalConnect('row-activated', func, after);
  Stream<TreeViewRowActivatedEvent> get onRowActivated {
    int signalId;
    StreamController<TreeViewRowActivatedEvent> controller;
    controller = new StreamController<TreeViewRowActivatedEvent>(
      onListen: () {
          signalId = _connectToRowActivated(false, (TreePath path, TreeViewColumn column) {
              var result = new TreeViewRowActivatedEvent(path, column);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeViewRowActivatedEvent> get afterRowActivated {
    int signalId;
    StreamController<TreeViewRowActivatedEvent> controller;
    controller = new StreamController<TreeViewRowActivatedEvent>(
      onListen: () {
          signalId = _connectToRowActivated(true, (TreePath path, TreeViewColumn column) {
              var result = new TreeViewRowActivatedEvent(path, column);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRowCollapsed(bool after, void func(TreeIter iter, TreePath path)) => signalConnect('row-collapsed', func, after);
  Stream<TreeViewRowCollapsedEvent> get onRowCollapsed {
    int signalId;
    StreamController<TreeViewRowCollapsedEvent> controller;
    controller = new StreamController<TreeViewRowCollapsedEvent>(
      onListen: () {
          signalId = _connectToRowCollapsed(false, (TreeIter iter, TreePath path) {
              var result = new TreeViewRowCollapsedEvent(iter, path);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeViewRowCollapsedEvent> get afterRowCollapsed {
    int signalId;
    StreamController<TreeViewRowCollapsedEvent> controller;
    controller = new StreamController<TreeViewRowCollapsedEvent>(
      onListen: () {
          signalId = _connectToRowCollapsed(true, (TreeIter iter, TreePath path) {
              var result = new TreeViewRowCollapsedEvent(iter, path);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRowExpanded(bool after, void func(TreeIter iter, TreePath path)) => signalConnect('row-expanded', func, after);
  Stream<TreeViewRowExpandedEvent> get onRowExpanded {
    int signalId;
    StreamController<TreeViewRowExpandedEvent> controller;
    controller = new StreamController<TreeViewRowExpandedEvent>(
      onListen: () {
          signalId = _connectToRowExpanded(false, (TreeIter iter, TreePath path) {
              var result = new TreeViewRowExpandedEvent(iter, path);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeViewRowExpandedEvent> get afterRowExpanded {
    int signalId;
    StreamController<TreeViewRowExpandedEvent> controller;
    controller = new StreamController<TreeViewRowExpandedEvent>(
      onListen: () {
          signalId = _connectToRowExpanded(true, (TreeIter iter, TreePath path) {
              var result = new TreeViewRowExpandedEvent(iter, path);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectAll(bool after, bool func()) => signalConnect('select-all', func, after);
  Stream<TreeViewSelectAllEvent> get onSelectAll {
    int signalId;
    StreamController<TreeViewSelectAllEvent> controller;
    controller = new StreamController<TreeViewSelectAllEvent>(
      onListen: () {
          signalId = _connectToSelectAll(false, () {
              var result = new TreeViewSelectAllEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeViewSelectAllEvent> get afterSelectAll {
    int signalId;
    StreamController<TreeViewSelectAllEvent> controller;
    controller = new StreamController<TreeViewSelectAllEvent>(
      onListen: () {
          signalId = _connectToSelectAll(true, () {
              var result = new TreeViewSelectAllEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectCursorParent(bool after, bool func()) => signalConnect('select-cursor-parent', func, after);
  Stream<TreeViewSelectCursorParentEvent> get onSelectCursorParent {
    int signalId;
    StreamController<TreeViewSelectCursorParentEvent> controller;
    controller = new StreamController<TreeViewSelectCursorParentEvent>(
      onListen: () {
          signalId = _connectToSelectCursorParent(false, () {
              var result = new TreeViewSelectCursorParentEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeViewSelectCursorParentEvent> get afterSelectCursorParent {
    int signalId;
    StreamController<TreeViewSelectCursorParentEvent> controller;
    controller = new StreamController<TreeViewSelectCursorParentEvent>(
      onListen: () {
          signalId = _connectToSelectCursorParent(true, () {
              var result = new TreeViewSelectCursorParentEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectCursorRow(bool after, bool func(bool object)) => signalConnect('select-cursor-row', func, after);
  Stream<TreeViewSelectCursorRowEvent> get onSelectCursorRow {
    int signalId;
    StreamController<TreeViewSelectCursorRowEvent> controller;
    controller = new StreamController<TreeViewSelectCursorRowEvent>(
      onListen: () {
          signalId = _connectToSelectCursorRow(false, (bool object) {
              var result = new TreeViewSelectCursorRowEvent(object);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeViewSelectCursorRowEvent> get afterSelectCursorRow {
    int signalId;
    StreamController<TreeViewSelectCursorRowEvent> controller;
    controller = new StreamController<TreeViewSelectCursorRowEvent>(
      onListen: () {
          signalId = _connectToSelectCursorRow(true, (bool object) {
              var result = new TreeViewSelectCursorRowEvent(object);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToStartInteractiveSearch(bool after, bool func()) => signalConnect('start-interactive-search', func, after);
  Stream<TreeViewStartInteractiveSearchEvent> get onStartInteractiveSearch {
    int signalId;
    StreamController<TreeViewStartInteractiveSearchEvent> controller;
    controller = new StreamController<TreeViewStartInteractiveSearchEvent>(
      onListen: () {
          signalId = _connectToStartInteractiveSearch(false, () {
              var result = new TreeViewStartInteractiveSearchEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeViewStartInteractiveSearchEvent> get afterStartInteractiveSearch {
    int signalId;
    StreamController<TreeViewStartInteractiveSearchEvent> controller;
    controller = new StreamController<TreeViewStartInteractiveSearchEvent>(
      onListen: () {
          signalId = _connectToStartInteractiveSearch(true, () {
              var result = new TreeViewStartInteractiveSearchEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToTestCollapseRow(bool after, bool func(TreeIter iter, TreePath path)) => signalConnect('test-collapse-row', func, after);
  Stream<TreeViewTestCollapseRowEvent> get onTestCollapseRow {
    int signalId;
    StreamController<TreeViewTestCollapseRowEvent> controller;
    controller = new StreamController<TreeViewTestCollapseRowEvent>(
      onListen: () {
          signalId = _connectToTestCollapseRow(false, (TreeIter iter, TreePath path) {
              var result = new TreeViewTestCollapseRowEvent(iter, path);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeViewTestCollapseRowEvent> get afterTestCollapseRow {
    int signalId;
    StreamController<TreeViewTestCollapseRowEvent> controller;
    controller = new StreamController<TreeViewTestCollapseRowEvent>(
      onListen: () {
          signalId = _connectToTestCollapseRow(true, (TreeIter iter, TreePath path) {
              var result = new TreeViewTestCollapseRowEvent(iter, path);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToTestExpandRow(bool after, bool func(TreeIter iter, TreePath path)) => signalConnect('test-expand-row', func, after);
  Stream<TreeViewTestExpandRowEvent> get onTestExpandRow {
    int signalId;
    StreamController<TreeViewTestExpandRowEvent> controller;
    controller = new StreamController<TreeViewTestExpandRowEvent>(
      onListen: () {
          signalId = _connectToTestExpandRow(false, (TreeIter iter, TreePath path) {
              var result = new TreeViewTestExpandRowEvent(iter, path);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeViewTestExpandRowEvent> get afterTestExpandRow {
    int signalId;
    StreamController<TreeViewTestExpandRowEvent> controller;
    controller = new StreamController<TreeViewTestExpandRowEvent>(
      onListen: () {
          signalId = _connectToTestExpandRow(true, (TreeIter iter, TreePath path) {
              var result = new TreeViewTestExpandRowEvent(iter, path);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToToggleCursorRow(bool after, bool func()) => signalConnect('toggle-cursor-row', func, after);
  Stream<TreeViewToggleCursorRowEvent> get onToggleCursorRow {
    int signalId;
    StreamController<TreeViewToggleCursorRowEvent> controller;
    controller = new StreamController<TreeViewToggleCursorRowEvent>(
      onListen: () {
          signalId = _connectToToggleCursorRow(false, () {
              var result = new TreeViewToggleCursorRowEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeViewToggleCursorRowEvent> get afterToggleCursorRow {
    int signalId;
    StreamController<TreeViewToggleCursorRowEvent> controller;
    controller = new StreamController<TreeViewToggleCursorRowEvent>(
      onListen: () {
          signalId = _connectToToggleCursorRow(true, () {
              var result = new TreeViewToggleCursorRowEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToUnselectAll(bool after, bool func()) => signalConnect('unselect-all', func, after);
  Stream<TreeViewUnselectAllEvent> get onUnselectAll {
    int signalId;
    StreamController<TreeViewUnselectAllEvent> controller;
    controller = new StreamController<TreeViewUnselectAllEvent>(
      onListen: () {
          signalId = _connectToUnselectAll(false, () {
              var result = new TreeViewUnselectAllEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TreeViewUnselectAllEvent> get afterUnselectAll {
    int signalId;
    StreamController<TreeViewUnselectAllEvent> controller;
    controller = new StreamController<TreeViewUnselectAllEvent>(
      onListen: () {
          signalId = _connectToUnselectAll(true, () {
              var result = new TreeViewUnselectAllEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class TreeViewExpandCollapseCursorRowEvent {
  final bool object;
  final bool p0;
  final bool p1;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  TreeViewExpandCollapseCursorRowEvent(this.object, this.p0, this.p1);
}

class TreeViewMoveCursorEvent {
  final MovementStep step;
  final int direction;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  TreeViewMoveCursorEvent(this.step, this.direction);
}

class TreeViewRowActivatedEvent {
  final TreePath path;
  final TreeViewColumn column;

  TreeViewRowActivatedEvent(this.path, this.column);
}

class TreeViewRowCollapsedEvent {
  final TreeIter iter;
  final TreePath path;

  TreeViewRowCollapsedEvent(this.iter, this.path);
}

class TreeViewRowExpandedEvent {
  final TreeIter iter;
  final TreePath path;

  TreeViewRowExpandedEvent(this.iter, this.path);
}

class TreeViewSelectAllEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  TreeViewSelectAllEvent();
}

class TreeViewSelectCursorParentEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  TreeViewSelectCursorParentEvent();
}

class TreeViewSelectCursorRowEvent {
  final bool object;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  TreeViewSelectCursorRowEvent(this.object);
}

class TreeViewStartInteractiveSearchEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  TreeViewStartInteractiveSearchEvent();
}

class TreeViewTestCollapseRowEvent {
  final TreeIter iter;
  final TreePath path;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  TreeViewTestCollapseRowEvent(this.iter, this.path);
}

class TreeViewTestExpandRowEvent {
  final TreeIter iter;
  final TreePath path;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  TreeViewTestExpandRowEvent(this.iter, this.path);
}

class TreeViewToggleCursorRowEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  TreeViewToggleCursorRowEvent();
}

class TreeViewUnselectAllEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  TreeViewUnselectAllEvent();
}

class TreeViewAccessible extends ContainerAccessible with Component, Selection, atk.Table, CellAccessibleParent {
  TreeViewAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeViewAccessible');

}

class TreeViewColumn extends InitiallyUnowned with Buildable, CellLayout {
  TreeViewColumn.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeViewColumn');

  static const String ALIGNMENT_PROPERTY = 'alignment';
  CellArea get cellArea => _staticInfo.getGPropertyOnReceiver('cell-area', this);
  void set cellArea(CellArea value) => _staticInfo.setGPropertyOnReceiver('cell-area', this, value);
  static const String CELL_AREA_PROPERTY = 'cell-area';
  static const String CLICKABLE_PROPERTY = 'clickable';
  static const String EXPAND_PROPERTY = 'expand';
  static const String FIXED_WIDTH_PROPERTY = 'fixed-width';
  static const String MAX_WIDTH_PROPERTY = 'max-width';
  static const String MIN_WIDTH_PROPERTY = 'min-width';
  static const String REORDERABLE_PROPERTY = 'reorderable';
  static const String RESIZABLE_PROPERTY = 'resizable';
  static const String SIZING_PROPERTY = 'sizing';
  static const String SORT_COLUMN_ID_PROPERTY = 'sort-column-id';
  static const String SORT_INDICATOR_PROPERTY = 'sort-indicator';
  static const String SORT_ORDER_PROPERTY = 'sort-order';
  static const String SPACING_PROPERTY = 'spacing';
  static const String TITLE_PROPERTY = 'title';
  static const String VISIBLE_PROPERTY = 'visible';
  static const String WIDGET_PROPERTY = 'widget';
  static const String WIDTH_PROPERTY = 'width';
  static const String X_OFFSET_PROPERTY = 'x-offset';
  factory TreeViewColumn() => _staticInfo.callStatic('new', []);
  factory TreeViewColumn.withArea(CellArea area) => _staticInfo.callStatic('new_with_area', [area]);
  void addAttribute(CellRenderer cellRenderer, String attribute, int column) => _staticInfo.callMethodOnReceiver('add_attribute', this, [cellRenderer, attribute, column]);
  bool cellGetPosition(CellRenderer cellRenderer) => _staticInfo.callMethodOnReceiver('cell_get_position', this, [cellRenderer]);
  void cellGetSize(RectangleInt cellArea) => _staticInfo.callMethodOnReceiver('cell_get_size', this, [cellArea]);
  bool cellIsVisible() => _staticInfo.callMethodOnReceiver('cell_is_visible', this, []);
  void cellSetCellData(TreeModel treeModel, TreeIter iter, bool isExpander, bool isExpanded) => _staticInfo.callMethodOnReceiver('cell_set_cell_data', this, [treeModel, iter, isExpander, isExpanded]);
  void clear() => _staticInfo.callMethodOnReceiver('clear', this, []);
  void clearAttributes(CellRenderer cellRenderer) => _staticInfo.callMethodOnReceiver('clear_attributes', this, [cellRenderer]);
  void clicked() => _staticInfo.callMethodOnReceiver('clicked', this, []);
  void focusCell(CellRenderer cell) => _staticInfo.callMethodOnReceiver('focus_cell', this, [cell]);
  num get alignment => _staticInfo.callMethodOnReceiver('get_alignment', this, []);
  Widget getButton() => _staticInfo.callMethodOnReceiver('get_button', this, []);
  bool get clickable => _staticInfo.callMethodOnReceiver('get_clickable', this, []);
  bool get expand => _staticInfo.callMethodOnReceiver('get_expand', this, []);
  int get fixedWidth => _staticInfo.callMethodOnReceiver('get_fixed_width', this, []);
  int get maxWidth => _staticInfo.callMethodOnReceiver('get_max_width', this, []);
  int get minWidth => _staticInfo.callMethodOnReceiver('get_min_width', this, []);
  bool get reorderable => _staticInfo.callMethodOnReceiver('get_reorderable', this, []);
  bool get resizable => _staticInfo.callMethodOnReceiver('get_resizable', this, []);
  TreeViewColumnSizing get sizing => _staticInfo.callMethodOnReceiver('get_sizing', this, []);
  int get sortColumnId => _staticInfo.callMethodOnReceiver('get_sort_column_id', this, []);
  bool get sortIndicator => _staticInfo.callMethodOnReceiver('get_sort_indicator', this, []);
  SortType get sortOrder => _staticInfo.callMethodOnReceiver('get_sort_order', this, []);
  int get spacing => _staticInfo.callMethodOnReceiver('get_spacing', this, []);
  String get title => _staticInfo.callMethodOnReceiver('get_title', this, []);
  Widget getTreeView() => _staticInfo.callMethodOnReceiver('get_tree_view', this, []);
  bool get visible => _staticInfo.callMethodOnReceiver('get_visible', this, []);
  Widget get widget => _staticInfo.callMethodOnReceiver('get_widget', this, []);
  int get width => _staticInfo.callMethodOnReceiver('get_width', this, []);
  int get xOffset => _staticInfo.callMethodOnReceiver('get_x_offset', this, []);
  void packEnd(CellRenderer cell, bool expand) => _staticInfo.callMethodOnReceiver('pack_end', this, [cell, expand]);
  void packStart(CellRenderer cell, bool expand) => _staticInfo.callMethodOnReceiver('pack_start', this, [cell, expand]);
  void queueResize() => _staticInfo.callMethodOnReceiver('queue_resize', this, []);
  void set alignment(num xalign) => _staticInfo.callMethodOnReceiver('set_alignment', this, [xalign]);
  void setCellDataFunc(CellRenderer cellRenderer, TreeCellDataFunc func) => _staticInfo.callMethodOnReceiver('set_cell_data_func', this, [cellRenderer, func]);
  void set clickable(bool clickable) => _staticInfo.callMethodOnReceiver('set_clickable', this, [clickable]);
  void set expand(bool expand) => _staticInfo.callMethodOnReceiver('set_expand', this, [expand]);
  void set fixedWidth(int fixedWidth) => _staticInfo.callMethodOnReceiver('set_fixed_width', this, [fixedWidth]);
  void set maxWidth(int maxWidth) => _staticInfo.callMethodOnReceiver('set_max_width', this, [maxWidth]);
  void set minWidth(int minWidth) => _staticInfo.callMethodOnReceiver('set_min_width', this, [minWidth]);
  void set reorderable(bool reorderable) => _staticInfo.callMethodOnReceiver('set_reorderable', this, [reorderable]);
  void set resizable(bool resizable) => _staticInfo.callMethodOnReceiver('set_resizable', this, [resizable]);
  void set sizing(TreeViewColumnSizing type) => _staticInfo.callMethodOnReceiver('set_sizing', this, [type]);
  void set sortColumnId(int sortColumnId) => _staticInfo.callMethodOnReceiver('set_sort_column_id', this, [sortColumnId]);
  void set sortIndicator(bool setting) => _staticInfo.callMethodOnReceiver('set_sort_indicator', this, [setting]);
  void set sortOrder(SortType order) => _staticInfo.callMethodOnReceiver('set_sort_order', this, [order]);
  void set spacing(int spacing) => _staticInfo.callMethodOnReceiver('set_spacing', this, [spacing]);
  void set title(String title) => _staticInfo.callMethodOnReceiver('set_title', this, [title]);
  void set visible(bool visible) => _staticInfo.callMethodOnReceiver('set_visible', this, [visible]);
  void set widget(Widget widget) => _staticInfo.callMethodOnReceiver('set_widget', this, [widget]);
  int _connectToClicked(bool after, void func()) => signalConnect('clicked', func, after);
  Stream get onClicked {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClicked(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterClicked {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToClicked(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

typedef bool TreeViewColumnDropFunc(TreeView treeView, TreeViewColumn column, TreeViewColumn prevColumn, TreeViewColumn nextColumn);
class TreeViewColumnSizing extends GEnumBase {
  const TreeViewColumnSizing(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeViewColumnSizing');

  static const TreeViewColumnSizing GROW_ONLY = const TreeViewColumnSizing(0);
  static const TreeViewColumnSizing AUTOSIZE = const TreeViewColumnSizing(1);
  static const TreeViewColumnSizing FIXED = const TreeViewColumnSizing(2);
  String toString() {
    switch(index) {
      case 0: return 'TreeViewColumnSizing.GROW_ONLY';
      case 1: return 'TreeViewColumnSizing.AUTOSIZE';
      case 2: return 'TreeViewColumnSizing.FIXED';
      default: return 'new TreeViewColumnSizing($index)';
    }
  }
}

class TreeViewDropPosition extends GEnumBase {
  const TreeViewDropPosition(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeViewDropPosition');

  static const TreeViewDropPosition BEFORE = const TreeViewDropPosition(0);
  static const TreeViewDropPosition AFTER = const TreeViewDropPosition(1);
  static const TreeViewDropPosition INTO_OR_BEFORE = const TreeViewDropPosition(2);
  static const TreeViewDropPosition INTO_OR_AFTER = const TreeViewDropPosition(3);
  String toString() {
    switch(index) {
      case 0: return 'TreeViewDropPosition.BEFORE';
      case 1: return 'TreeViewDropPosition.AFTER';
      case 2: return 'TreeViewDropPosition.INTO_OR_BEFORE';
      case 3: return 'TreeViewDropPosition.INTO_OR_AFTER';
      default: return 'new TreeViewDropPosition($index)';
    }
  }
}

class TreeViewGridLines extends GEnumBase {
  const TreeViewGridLines(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'TreeViewGridLines');

  static const TreeViewGridLines NONE = const TreeViewGridLines(0);
  static const TreeViewGridLines HORIZONTAL = const TreeViewGridLines(1);
  static const TreeViewGridLines VERTICAL = const TreeViewGridLines(2);
  static const TreeViewGridLines BOTH = const TreeViewGridLines(3);
  String toString() {
    switch(index) {
      case 0: return 'TreeViewGridLines.NONE';
      case 1: return 'TreeViewGridLines.HORIZONTAL';
      case 2: return 'TreeViewGridLines.VERTICAL';
      case 3: return 'TreeViewGridLines.BOTH';
      default: return 'new TreeViewGridLines($index)';
    }
  }
}

typedef void TreeViewMappingFunc(TreeView treeView, TreePath path);
typedef bool TreeViewRowSeparatorFunc(TreeModel model, TreeIter iter);
typedef bool TreeViewSearchEqualFunc(TreeModel model, int column, String key, TreeIter iter);
typedef void TreeViewSearchPositionFunc(TreeView treeView, Widget searchDialog);
class UIManager extends GObjectObject with Buildable {
  UIManager.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'UIManager');

  static const String ADD_TEAROFFS_PROPERTY = 'add-tearoffs';
  static const String UI_PROPERTY = 'ui';
  factory UIManager() => _staticInfo.callStatic('new', []);
  void addUi(int mergeId, String path, String name, String action, UIManagerItemType type, bool top) => _staticInfo.callMethodOnReceiver('add_ui', this, [mergeId, path, name, action, type, top]);
  int addUiFromFile(String filename) => _staticInfo.callMethodOnReceiver('add_ui_from_file', this, [filename]);
  int addUiFromResource(String resourcePath) => _staticInfo.callMethodOnReceiver('add_ui_from_resource', this, [resourcePath]);
  int addUiFromString(String buffer, int length) => _staticInfo.callMethodOnReceiver('add_ui_from_string', this, [buffer, length]);
  void ensureUpdate() => _staticInfo.callMethodOnReceiver('ensure_update', this, []);
  AccelGroup getAccelGroup() => _staticInfo.callMethodOnReceiver('get_accel_group', this, []);
  Action getAction(String path) => _staticInfo.callMethodOnReceiver('get_action', this, [path]);
  GLibList /* this will fail */ getActionGroups() => _staticInfo.callMethodOnReceiver('get_action_groups', this, []);
  bool get addTearoffs => _staticInfo.callMethodOnReceiver('get_add_tearoffs', this, []);
  SList /* this will fail */ getToplevels(UIManagerItemType types) => _staticInfo.callMethodOnReceiver('get_toplevels', this, [types]);
  String get ui => _staticInfo.callMethodOnReceiver('get_ui', this, []);
  Widget getWidget(String path) => _staticInfo.callMethodOnReceiver('get_widget', this, [path]);
  void insertActionGroup(ActionGroup actionGroup, int pos) => _staticInfo.callMethodOnReceiver('insert_action_group', this, [actionGroup, pos]);
  int newMergeId() => _staticInfo.callMethodOnReceiver('new_merge_id', this, []);
  void removeActionGroup(ActionGroup actionGroup) => _staticInfo.callMethodOnReceiver('remove_action_group', this, [actionGroup]);
  void removeUi(int mergeId) => _staticInfo.callMethodOnReceiver('remove_ui', this, [mergeId]);
  void set addTearoffs(bool addTearoffs) => _staticInfo.callMethodOnReceiver('set_add_tearoffs', this, [addTearoffs]);
  int _connectToActionsChanged(bool after, void func()) => signalConnect('actions-changed', func, after);
  Stream get onActionsChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActionsChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActionsChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActionsChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToAddWidget(bool after, void func(Widget widget)) => signalConnect('add-widget', func, after);
  Stream<Widget> get onAddWidget {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToAddWidget(false, (Widget widget) {
              controller.add(widget);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Widget> get afterAddWidget {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToAddWidget(true, (Widget widget) {
              controller.add(widget);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToConnectProxy(bool after, void func(Action action, Widget proxy)) => signalConnect('connect-proxy', func, after);
  Stream<UIManagerConnectProxyEvent> get onConnectProxy {
    int signalId;
    StreamController<UIManagerConnectProxyEvent> controller;
    controller = new StreamController<UIManagerConnectProxyEvent>(
      onListen: () {
          signalId = _connectToConnectProxy(false, (Action action, Widget proxy) {
              var result = new UIManagerConnectProxyEvent(action, proxy);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<UIManagerConnectProxyEvent> get afterConnectProxy {
    int signalId;
    StreamController<UIManagerConnectProxyEvent> controller;
    controller = new StreamController<UIManagerConnectProxyEvent>(
      onListen: () {
          signalId = _connectToConnectProxy(true, (Action action, Widget proxy) {
              var result = new UIManagerConnectProxyEvent(action, proxy);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDisconnectProxy(bool after, void func(Action action, Widget proxy)) => signalConnect('disconnect-proxy', func, after);
  Stream<UIManagerDisconnectProxyEvent> get onDisconnectProxy {
    int signalId;
    StreamController<UIManagerDisconnectProxyEvent> controller;
    controller = new StreamController<UIManagerDisconnectProxyEvent>(
      onListen: () {
          signalId = _connectToDisconnectProxy(false, (Action action, Widget proxy) {
              var result = new UIManagerDisconnectProxyEvent(action, proxy);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<UIManagerDisconnectProxyEvent> get afterDisconnectProxy {
    int signalId;
    StreamController<UIManagerDisconnectProxyEvent> controller;
    controller = new StreamController<UIManagerDisconnectProxyEvent>(
      onListen: () {
          signalId = _connectToDisconnectProxy(true, (Action action, Widget proxy) {
              var result = new UIManagerDisconnectProxyEvent(action, proxy);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPostActivate(bool after, void func(Action action)) => signalConnect('post-activate', func, after);
  Stream<Action> get onPostActivate {
    int signalId;
    StreamController<Action> controller;
    controller = new StreamController<Action>(
      onListen: () {
          signalId = _connectToPostActivate(false, (Action action) {
              controller.add(action);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Action> get afterPostActivate {
    int signalId;
    StreamController<Action> controller;
    controller = new StreamController<Action>(
      onListen: () {
          signalId = _connectToPostActivate(true, (Action action) {
              controller.add(action);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPreActivate(bool after, void func(Action action)) => signalConnect('pre-activate', func, after);
  Stream<Action> get onPreActivate {
    int signalId;
    StreamController<Action> controller;
    controller = new StreamController<Action>(
      onListen: () {
          signalId = _connectToPreActivate(false, (Action action) {
              controller.add(action);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Action> get afterPreActivate {
    int signalId;
    StreamController<Action> controller;
    controller = new StreamController<Action>(
      onListen: () {
          signalId = _connectToPreActivate(true, (Action action) {
              controller.add(action);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class UIManagerConnectProxyEvent {
  final Action action;
  final Widget proxy;

  UIManagerConnectProxyEvent(this.action, this.proxy);
}

class UIManagerDisconnectProxyEvent {
  final Action action;
  final Widget proxy;

  UIManagerDisconnectProxyEvent(this.action, this.proxy);
}

class UIManagerItemType extends GEnumBase {
  const UIManagerItemType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'UIManagerItemType');

  static const UIManagerItemType AUTO = const UIManagerItemType(0);
  bool get auto => (index & 0) == 0;
  static const UIManagerItemType MENUBAR = const UIManagerItemType(1);
  bool get menubar => (index & 1) == 1;
  static const UIManagerItemType MENU = const UIManagerItemType(2);
  bool get menu => (index & 2) == 2;
  static const UIManagerItemType TOOLBAR = const UIManagerItemType(4);
  bool get toolbar => (index & 4) == 4;
  static const UIManagerItemType PLACEHOLDER = const UIManagerItemType(8);
  bool get placeholder => (index & 8) == 8;
  static const UIManagerItemType POPUP = const UIManagerItemType(16);
  bool get popup => (index & 16) == 16;
  static const UIManagerItemType MENUITEM = const UIManagerItemType(32);
  bool get menuitem => (index & 32) == 32;
  static const UIManagerItemType TOOLITEM = const UIManagerItemType(64);
  bool get toolitem => (index & 64) == 64;
  static const UIManagerItemType SEPARATOR = const UIManagerItemType(128);
  bool get separator => (index & 128) == 128;
  static const UIManagerItemType ACCELERATOR = const UIManagerItemType(256);
  bool get accelerator => (index & 256) == 256;
  static const UIManagerItemType POPUP_WITH_ACCELS = const UIManagerItemType(512);
  bool get popupWithAccels => (index & 512) == 512;
  static _valueToString(int value) {
    switch(value) {
      case 1: return 'UIManagerItemType.MENUBAR';
      case 2: return 'UIManagerItemType.MENU';
      case 4: return 'UIManagerItemType.TOOLBAR';
      case 8: return 'UIManagerItemType.PLACEHOLDER';
      case 16: return 'UIManagerItemType.POPUP';
      case 32: return 'UIManagerItemType.MENUITEM';
      case 64: return 'UIManagerItemType.TOOLITEM';
      case 128: return 'UIManagerItemType.SEPARATOR';
      default: return 'new UIManagerItemType($value)';
    }
  }
  String toString() {
    if (index == 0) {
      return 'UIManagerItemType.AUTO';
    }
    List codes = [];
    for (var i=1; i <= 512; i <<= 1) {
      if (index & i != 0) codes.add(_valueToString(i));
    }
    return codes.join(' | ');
  }
  UIManagerItemType operator|(UIManagerItemType other) =>
    new UIManagerItemType(index | other.index);
  UIManagerItemType operator&(UIManagerItemType other) =>
    new UIManagerItemType(index & other.index);
}

class Unit extends GEnumBase {
  const Unit(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Unit');

  static const Unit NONE = const Unit(0);
  static const Unit POINTS = const Unit(1);
  static const Unit INCH = const Unit(2);
  static const Unit MM = const Unit(3);
  String toString() {
    switch(index) {
      case 0: return 'Unit.NONE';
      case 1: return 'Unit.POINTS';
      case 2: return 'Unit.INCH';
      case 3: return 'Unit.MM';
      default: return 'new Unit($index)';
    }
  }
}

class VBox extends Box with ImplementorIface, Buildable, Orientable {
  VBox.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'VBox');

  factory VBox(bool homogeneous, int spacing) => _staticInfo.callStatic('new', [homogeneous, spacing]);
}

class VButtonBox extends ButtonBox with ImplementorIface, Buildable, Orientable {
  VButtonBox.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'VButtonBox');

  factory VButtonBox() => _staticInfo.callStatic('new', []);
}

class VPaned extends Paned with ImplementorIface, Buildable, Orientable {
  VPaned.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'VPaned');

  factory VPaned() => _staticInfo.callStatic('new', []);
}

class VScale extends Scale with ImplementorIface, Buildable, Orientable {
  VScale.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'VScale');

  factory VScale(Adjustment adjustment) => _staticInfo.callStatic('new', [adjustment]);
  factory VScale.withRange(num min, num max, num step) => _staticInfo.callStatic('new_with_range', [min, max, step]);
}

class VScrollbar extends Scrollbar with ImplementorIface, Buildable, Orientable {
  VScrollbar.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'VScrollbar');

  factory VScrollbar(Adjustment adjustment) => _staticInfo.callStatic('new', [adjustment]);
}

class VSeparator extends Separator with ImplementorIface, Buildable, Orientable {
  VSeparator.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'VSeparator');

  factory VSeparator() => _staticInfo.callStatic('new', []);
}

class Viewport extends Bin with ImplementorIface, Buildable, Scrollable {
  Viewport.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Viewport');

  static const String SHADOW_TYPE_PROPERTY = 'shadow-type';
  factory Viewport(Adjustment hadjustment, Adjustment vadjustment) => _staticInfo.callStatic('new', [hadjustment, vadjustment]);
  gdk.Window getBinWindow() => _staticInfo.callMethodOnReceiver('get_bin_window', this, []);
  Adjustment getHadjustment() => _staticInfo.callMethodOnReceiver('get_hadjustment', this, []);
  ShadowType get shadowType => _staticInfo.callMethodOnReceiver('get_shadow_type', this, []);
  Adjustment getVadjustment() => _staticInfo.callMethodOnReceiver('get_vadjustment', this, []);
  gdk.Window getViewWindow() => _staticInfo.callMethodOnReceiver('get_view_window', this, []);
  void setHadjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_hadjustment', this, [adjustment]);
  void set shadowType(ShadowType type) => _staticInfo.callMethodOnReceiver('set_shadow_type', this, [type]);
  void setVadjustment(Adjustment adjustment) => _staticInfo.callMethodOnReceiver('set_vadjustment', this, [adjustment]);
}

class VolumeButton extends ScaleButton with ImplementorIface, Actionable, Activatable, Buildable, Orientable {
  VolumeButton.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'VolumeButton');

  bool get useSymbolic => _staticInfo.getGPropertyOnReceiver('use-symbolic', this);
  void set useSymbolic(bool value) => _staticInfo.setGPropertyOnReceiver('use-symbolic', this, value);
  static const String USE_SYMBOLIC_PROPERTY = 'use-symbolic';
  factory VolumeButton() => _staticInfo.callStatic('new', []);
}

class Widget extends InitiallyUnowned with ImplementorIface, Buildable {
  Widget.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Widget');

  static const String APP_PAINTABLE_PROPERTY = 'app-paintable';
  static const String CAN_DEFAULT_PROPERTY = 'can-default';
  static const String CAN_FOCUS_PROPERTY = 'can-focus';
  bool get compositeChild => _staticInfo.getGPropertyOnReceiver('composite-child', this);
  static const String COMPOSITE_CHILD_PROPERTY = 'composite-child';
  static const String DOUBLE_BUFFERED_PROPERTY = 'double-buffered';
  static const String EVENTS_PROPERTY = 'events';
  bool get expand => _staticInfo.getGPropertyOnReceiver('expand', this);
  void set expand(bool value) => _staticInfo.setGPropertyOnReceiver('expand', this, value);
  static const String EXPAND_PROPERTY = 'expand';
  static const String HALIGN_PROPERTY = 'halign';
  bool get hasDefault => _staticInfo.getGPropertyOnReceiver('has-default', this);
  void set hasDefault(bool value) => _staticInfo.setGPropertyOnReceiver('has-default', this, value);
  static const String HAS_DEFAULT_PROPERTY = 'has-default';
  bool get hasFocus => _staticInfo.getGPropertyOnReceiver('has-focus', this);
  void set hasFocus(bool value) => _staticInfo.setGPropertyOnReceiver('has-focus', this, value);
  static const String HAS_FOCUS_PROPERTY = 'has-focus';
  static const String HAS_TOOLTIP_PROPERTY = 'has-tooltip';
  int get heightRequest => _staticInfo.getGPropertyOnReceiver('height-request', this);
  void set heightRequest(int value) => _staticInfo.setGPropertyOnReceiver('height-request', this, value);
  static const String HEIGHT_REQUEST_PROPERTY = 'height-request';
  static const String HEXPAND_PROPERTY = 'hexpand';
  static const String HEXPAND_SET_PROPERTY = 'hexpand-set';
  bool get isFocus => _staticInfo.getGPropertyOnReceiver('is-focus', this);
  void set isFocus(bool value) => _staticInfo.setGPropertyOnReceiver('is-focus', this, value);
  static const String IS_FOCUS_PROPERTY = 'is-focus';
  int get margin => _staticInfo.getGPropertyOnReceiver('margin', this);
  void set margin(int value) => _staticInfo.setGPropertyOnReceiver('margin', this, value);
  static const String MARGIN_PROPERTY = 'margin';
  static const String MARGIN_BOTTOM_PROPERTY = 'margin-bottom';
  static const String MARGIN_END_PROPERTY = 'margin-end';
  static const String MARGIN_LEFT_PROPERTY = 'margin-left';
  static const String MARGIN_RIGHT_PROPERTY = 'margin-right';
  static const String MARGIN_START_PROPERTY = 'margin-start';
  static const String MARGIN_TOP_PROPERTY = 'margin-top';
  static const String NAME_PROPERTY = 'name';
  static const String NO_SHOW_ALL_PROPERTY = 'no-show-all';
  static const String OPACITY_PROPERTY = 'opacity';
  static const String PARENT_PROPERTY = 'parent';
  static const String RECEIVES_DEFAULT_PROPERTY = 'receives-default';
  static const String SCALE_FACTOR_PROPERTY = 'scale-factor';
  static const String SENSITIVE_PROPERTY = 'sensitive';
  static const String STYLE_PROPERTY = 'style';
  static const String TOOLTIP_MARKUP_PROPERTY = 'tooltip-markup';
  static const String TOOLTIP_TEXT_PROPERTY = 'tooltip-text';
  static const String VALIGN_PROPERTY = 'valign';
  static const String VEXPAND_PROPERTY = 'vexpand';
  static const String VEXPAND_SET_PROPERTY = 'vexpand-set';
  static const String VISIBLE_PROPERTY = 'visible';
  int get widthRequest => _staticInfo.getGPropertyOnReceiver('width-request', this);
  void set widthRequest(int value) => _staticInfo.setGPropertyOnReceiver('width-request', this, value);
  static const String WIDTH_REQUEST_PROPERTY = 'width-request';
  static const String WINDOW_PROPERTY = 'window';
  static TextDirection getDefaultDirection() => _staticInfo.callStatic('get_default_direction', []);
  static Style getDefaultStyle() => _staticInfo.callStatic('get_default_style', []);
  static void popCompositeChild() => _staticInfo.callStatic('pop_composite_child', []);
  static void pushCompositeChild() => _staticInfo.callStatic('push_composite_child', []);
  static void setDefaultDirection(TextDirection dir) => _staticInfo.callStatic('set_default_direction', [dir]);
  bool activate() => _staticInfo.callMethodOnReceiver('activate', this, []);
  void addAccelerator(String accelSignal, AccelGroup accelGroup, int accelKey, ModifierType accelMods, AccelFlags accelFlags) => _staticInfo.callMethodOnReceiver('add_accelerator', this, [accelSignal, accelGroup, accelKey, accelMods, accelFlags]);
  void addDeviceEvents(Device device, EventMask events) => _staticInfo.callMethodOnReceiver('add_device_events', this, [device, events]);
  void addEvents(int events) => _staticInfo.callMethodOnReceiver('add_events', this, [events]);
  void addMnemonicLabel(Widget label) => _staticInfo.callMethodOnReceiver('add_mnemonic_label', this, [label]);
  int addTickCallback(TickCallback callback) => _staticInfo.callMethodOnReceiver('add_tick_callback', this, [callback]);
  bool canActivateAccel(int signalId) => _staticInfo.callMethodOnReceiver('can_activate_accel', this, [signalId]);
  bool childFocus(DirectionType direction) => _staticInfo.callMethodOnReceiver('child_focus', this, [direction]);
  void childNotify(String childProperty) => _staticInfo.callMethodOnReceiver('child_notify', this, [childProperty]);
  void classPath() => _staticInfo.callMethodOnReceiver('class_path', this, []);
  bool computeExpand(Orientation orientation) => _staticInfo.callMethodOnReceiver('compute_expand', this, [orientation]);
  pango.Context createPangoContext() => _staticInfo.callMethodOnReceiver('create_pango_context', this, []);
  pango.Layout createPangoLayout(String text) => _staticInfo.callMethodOnReceiver('create_pango_layout', this, [text]);
  void destroy() => _staticInfo.callMethodOnReceiver('destroy', this, []);
  void destroyed(Widget widgetPointer) => _staticInfo.callMethodOnReceiver('destroyed', this, [widgetPointer]);
  bool deviceIsShadowed(Device device) => _staticInfo.callMethodOnReceiver('device_is_shadowed', this, [device]);
  DragContext dragBegin(TargetList targets, DragAction actions, int button, Event event) => _staticInfo.callMethodOnReceiver('drag_begin', this, [targets, actions, button, event]);
  DragContext dragBeginWithCoordinates(TargetList targets, DragAction actions, int button, Event event, int x, int y) => _staticInfo.callMethodOnReceiver('drag_begin_with_coordinates', this, [targets, actions, button, event, x, y]);
  bool dragCheckThreshold(int startX, int startY, int currentX, int currentY) => _staticInfo.callMethodOnReceiver('drag_check_threshold', this, [startX, startY, currentX, currentY]);
  void dragDestAddImageTargets() => _staticInfo.callMethodOnReceiver('drag_dest_add_image_targets', this, []);
  void dragDestAddTextTargets() => _staticInfo.callMethodOnReceiver('drag_dest_add_text_targets', this, []);
  void dragDestAddUriTargets() => _staticInfo.callMethodOnReceiver('drag_dest_add_uri_targets', this, []);
  Atom dragDestFindTarget(DragContext context, TargetList targetList) => _staticInfo.callMethodOnReceiver('drag_dest_find_target', this, [context, targetList]);
  TargetList dragDestGetTargetList() => _staticInfo.callMethodOnReceiver('drag_dest_get_target_list', this, []);
  bool dragDestGetTrackMotion() => _staticInfo.callMethodOnReceiver('drag_dest_get_track_motion', this, []);
  void dragDestSet(DestDefaults flags, List<TargetEntry> targets, DragAction actions) => _staticInfo.callMethodOnReceiver('drag_dest_set', this, [flags, targets, actions]);
  void dragDestSetProxy(gdk.Window proxyWindow, DragProtocol protocol, bool useCoordinates) => _staticInfo.callMethodOnReceiver('drag_dest_set_proxy', this, [proxyWindow, protocol, useCoordinates]);
  void dragDestSetTargetList(TargetList targetList) => _staticInfo.callMethodOnReceiver('drag_dest_set_target_list', this, [targetList]);
  void dragDestSetTrackMotion(bool trackMotion) => _staticInfo.callMethodOnReceiver('drag_dest_set_track_motion', this, [trackMotion]);
  void dragDestUnset() => _staticInfo.callMethodOnReceiver('drag_dest_unset', this, []);
  void dragGetData(DragContext context, Atom target, int time_) => _staticInfo.callMethodOnReceiver('drag_get_data', this, [context, target, time_]);
  void dragHighlight() => _staticInfo.callMethodOnReceiver('drag_highlight', this, []);
  void dragSourceAddImageTargets() => _staticInfo.callMethodOnReceiver('drag_source_add_image_targets', this, []);
  void dragSourceAddTextTargets() => _staticInfo.callMethodOnReceiver('drag_source_add_text_targets', this, []);
  void dragSourceAddUriTargets() => _staticInfo.callMethodOnReceiver('drag_source_add_uri_targets', this, []);
  TargetList dragSourceGetTargetList() => _staticInfo.callMethodOnReceiver('drag_source_get_target_list', this, []);
  void dragSourceSet(ModifierType startButtonMask, List<TargetEntry> targets, DragAction actions) => _staticInfo.callMethodOnReceiver('drag_source_set', this, [startButtonMask, targets, actions]);
  void dragSourceSetIconGicon(Icon icon) => _staticInfo.callMethodOnReceiver('drag_source_set_icon_gicon', this, [icon]);
  void dragSourceSetIconName(String iconName) => _staticInfo.callMethodOnReceiver('drag_source_set_icon_name', this, [iconName]);
  void dragSourceSetIconPixbuf(Pixbuf pixbuf) => _staticInfo.callMethodOnReceiver('drag_source_set_icon_pixbuf', this, [pixbuf]);
  void dragSourceSetIconStock(String stockId) => _staticInfo.callMethodOnReceiver('drag_source_set_icon_stock', this, [stockId]);
  void dragSourceSetTargetList(TargetList targetList) => _staticInfo.callMethodOnReceiver('drag_source_set_target_list', this, [targetList]);
  void dragSourceUnset() => _staticInfo.callMethodOnReceiver('drag_source_unset', this, []);
  void dragUnhighlight() => _staticInfo.callMethodOnReceiver('drag_unhighlight', this, []);
  void draw(Context cr) => _staticInfo.callMethodOnReceiver('draw', this, [cr]);
  void ensureStyle() => _staticInfo.callMethodOnReceiver('ensure_style', this, []);
  void errorBell() => _staticInfo.callMethodOnReceiver('error_bell', this, []);
  bool event(Event event) => _staticInfo.callMethodOnReceiver('event', this, [event]);
  void freezeChildNotify() => _staticInfo.callMethodOnReceiver('freeze_child_notify', this, []);
  AtkObject getAccessible() => _staticInfo.callMethodOnReceiver('get_accessible', this, []);
  gio.ActionGroup getActionGroup(String prefix) => _staticInfo.callMethodOnReceiver('get_action_group', this, [prefix]);
  int getAllocatedBaseline() => _staticInfo.callMethodOnReceiver('get_allocated_baseline', this, []);
  int getAllocatedHeight() => _staticInfo.callMethodOnReceiver('get_allocated_height', this, []);
  int getAllocatedWidth() => _staticInfo.callMethodOnReceiver('get_allocated_width', this, []);
  void getAllocation() => _staticInfo.callMethodOnReceiver('get_allocation', this, []);
  Widget getAncestor(int widgetType) => _staticInfo.callMethodOnReceiver('get_ancestor', this, [widgetType]);
  bool get appPaintable => _staticInfo.callMethodOnReceiver('get_app_paintable', this, []);
  bool get canDefault => _staticInfo.callMethodOnReceiver('get_can_default', this, []);
  bool get canFocus => _staticInfo.callMethodOnReceiver('get_can_focus', this, []);
  void getChildRequisition() => _staticInfo.callMethodOnReceiver('get_child_requisition', this, []);
  bool getChildVisible() => _staticInfo.callMethodOnReceiver('get_child_visible', this, []);
  void getClip() => _staticInfo.callMethodOnReceiver('get_clip', this, []);
  Clipboard getClipboard(Atom selection) => _staticInfo.callMethodOnReceiver('get_clipboard', this, [selection]);
  String getCompositeName() => _staticInfo.callMethodOnReceiver('get_composite_name', this, []);
  bool getDeviceEnabled(Device device) => _staticInfo.callMethodOnReceiver('get_device_enabled', this, [device]);
  EventMask getDeviceEvents(Device device) => _staticInfo.callMethodOnReceiver('get_device_events', this, [device]);
  TextDirection getDirection() => _staticInfo.callMethodOnReceiver('get_direction', this, []);
  Display getDisplay() => _staticInfo.callMethodOnReceiver('get_display', this, []);
  bool get doubleBuffered => _staticInfo.callMethodOnReceiver('get_double_buffered', this, []);
  int get _events => _staticInfo.callMethodOnReceiver('get_events', this, []);
  EventMask get events => new EventMask(_events);
  FontMap getFontMap() => _staticInfo.callMethodOnReceiver('get_font_map', this, []);
  FontOptions getFontOptions() => _staticInfo.callMethodOnReceiver('get_font_options', this, []);
  FrameClock getFrameClock() => _staticInfo.callMethodOnReceiver('get_frame_clock', this, []);
  Align get halign => _staticInfo.callMethodOnReceiver('get_halign', this, []);
  bool get hasTooltip => _staticInfo.callMethodOnReceiver('get_has_tooltip', this, []);
  bool getHasWindow() => _staticInfo.callMethodOnReceiver('get_has_window', this, []);
  bool get hexpand => _staticInfo.callMethodOnReceiver('get_hexpand', this, []);
  bool get hexpandSet => _staticInfo.callMethodOnReceiver('get_hexpand_set', this, []);
  bool getMapped() => _staticInfo.callMethodOnReceiver('get_mapped', this, []);
  int get marginBottom => _staticInfo.callMethodOnReceiver('get_margin_bottom', this, []);
  int get marginEnd => _staticInfo.callMethodOnReceiver('get_margin_end', this, []);
  int get marginLeft => _staticInfo.callMethodOnReceiver('get_margin_left', this, []);
  int get marginRight => _staticInfo.callMethodOnReceiver('get_margin_right', this, []);
  int get marginStart => _staticInfo.callMethodOnReceiver('get_margin_start', this, []);
  int get marginTop => _staticInfo.callMethodOnReceiver('get_margin_top', this, []);
  ModifierType getModifierMask(ModifierIntent intent) => _staticInfo.callMethodOnReceiver('get_modifier_mask', this, [intent]);
  RcStyle getModifierStyle() => _staticInfo.callMethodOnReceiver('get_modifier_style', this, []);
  String get name => _staticInfo.callMethodOnReceiver('get_name', this, []);
  bool get noShowAll => _staticInfo.callMethodOnReceiver('get_no_show_all', this, []);
  num get opacity => _staticInfo.callMethodOnReceiver('get_opacity', this, []);
  pango.Context getPangoContext() => _staticInfo.callMethodOnReceiver('get_pango_context', this, []);
  Widget get parent => _staticInfo.callMethodOnReceiver('get_parent', this, []);
  gdk.Window getParentWindow() => _staticInfo.callMethodOnReceiver('get_parent_window', this, []);
  WidgetPath getPath() => _staticInfo.callMethodOnReceiver('get_path', this, []);
  void getPointer() => _staticInfo.callMethodOnReceiver('get_pointer', this, []);
  void getPreferredHeight() => _staticInfo.callMethodOnReceiver('get_preferred_height', this, []);
  void getPreferredHeightAndBaselineForWidth(int width) => _staticInfo.callMethodOnReceiver('get_preferred_height_and_baseline_for_width', this, [width]);
  void getPreferredHeightForWidth(int width) => _staticInfo.callMethodOnReceiver('get_preferred_height_for_width', this, [width]);
  void getPreferredSize() => _staticInfo.callMethodOnReceiver('get_preferred_size', this, []);
  void getPreferredWidth() => _staticInfo.callMethodOnReceiver('get_preferred_width', this, []);
  void getPreferredWidthForHeight(int height) => _staticInfo.callMethodOnReceiver('get_preferred_width_for_height', this, [height]);
  bool getRealized() => _staticInfo.callMethodOnReceiver('get_realized', this, []);
  bool get receivesDefault => _staticInfo.callMethodOnReceiver('get_receives_default', this, []);
  SizeRequestMode getRequestMode() => _staticInfo.callMethodOnReceiver('get_request_mode', this, []);
  void getRequisition() => _staticInfo.callMethodOnReceiver('get_requisition', this, []);
  gdk.Window getRootWindow() => _staticInfo.callMethodOnReceiver('get_root_window', this, []);
  int get scaleFactor => _staticInfo.callMethodOnReceiver('get_scale_factor', this, []);
  Screen getScreen() => _staticInfo.callMethodOnReceiver('get_screen', this, []);
  bool get sensitive => _staticInfo.callMethodOnReceiver('get_sensitive', this, []);
  Settings getSettings() => _staticInfo.callMethodOnReceiver('get_settings', this, []);
  void getSizeRequest() => _staticInfo.callMethodOnReceiver('get_size_request', this, []);
  StateType getState() => _staticInfo.callMethodOnReceiver('get_state', this, []);
  StateFlags getStateFlags() => _staticInfo.callMethodOnReceiver('get_state_flags', this, []);
  Style get style => _staticInfo.callMethodOnReceiver('get_style', this, []);
  StyleContext getStyleContext() => _staticInfo.callMethodOnReceiver('get_style_context', this, []);
  bool getSupportMultidevice() => _staticInfo.callMethodOnReceiver('get_support_multidevice', this, []);
  GObjectObject getTemplateChild(int widgetType, String name) => _staticInfo.callMethodOnReceiver('get_template_child', this, [widgetType, name]);
  String get tooltipMarkup => _staticInfo.callMethodOnReceiver('get_tooltip_markup', this, []);
  String get tooltipText => _staticInfo.callMethodOnReceiver('get_tooltip_text', this, []);
  Window getTooltipWindow() => _staticInfo.callMethodOnReceiver('get_tooltip_window', this, []);
  Widget getToplevel() => _staticInfo.callMethodOnReceiver('get_toplevel', this, []);
  Align get valign => _staticInfo.callMethodOnReceiver('get_valign', this, []);
  Align getValignWithBaseline() => _staticInfo.callMethodOnReceiver('get_valign_with_baseline', this, []);
  bool get vexpand => _staticInfo.callMethodOnReceiver('get_vexpand', this, []);
  bool get vexpandSet => _staticInfo.callMethodOnReceiver('get_vexpand_set', this, []);
  bool get visible => _staticInfo.callMethodOnReceiver('get_visible', this, []);
  Visual getVisual() => _staticInfo.callMethodOnReceiver('get_visual', this, []);
  gdk.Window get window => _staticInfo.callMethodOnReceiver('get_window', this, []);
  void grabAdd() => _staticInfo.callMethodOnReceiver('grab_add', this, []);
  void grabDefault() => _staticInfo.callMethodOnReceiver('grab_default', this, []);
  void grabFocus() => _staticInfo.callMethodOnReceiver('grab_focus', this, []);
  void grabRemove() => _staticInfo.callMethodOnReceiver('grab_remove', this, []);
  bool hasDefault_() => _staticInfo.callMethodOnReceiver('has_default', this, []);
  bool hasFocus_() => _staticInfo.callMethodOnReceiver('has_focus', this, []);
  bool hasGrab() => _staticInfo.callMethodOnReceiver('has_grab', this, []);
  bool hasRcStyle() => _staticInfo.callMethodOnReceiver('has_rc_style', this, []);
  bool hasScreen() => _staticInfo.callMethodOnReceiver('has_screen', this, []);
  bool hasVisibleFocus() => _staticInfo.callMethodOnReceiver('has_visible_focus', this, []);
  void hide() => _staticInfo.callMethodOnReceiver('hide', this, []);
  bool hideOnDelete() => _staticInfo.callMethodOnReceiver('hide_on_delete', this, []);
  bool inDestruction() => _staticInfo.callMethodOnReceiver('in_destruction', this, []);
  void initTemplate() => _staticInfo.callMethodOnReceiver('init_template', this, []);
  void inputShapeCombineRegion(Region region) => _staticInfo.callMethodOnReceiver('input_shape_combine_region', this, [region]);
  void insertActionGroup(String name, gio.ActionGroup group) => _staticInfo.callMethodOnReceiver('insert_action_group', this, [name, group]);
  bool intersect(RectangleInt area, RectangleInt intersection) => _staticInfo.callMethodOnReceiver('intersect', this, [area, intersection]);
  bool isAncestor(Widget ancestor) => _staticInfo.callMethodOnReceiver('is_ancestor', this, [ancestor]);
  bool isComposited() => _staticInfo.callMethodOnReceiver('is_composited', this, []);
  bool isDrawable() => _staticInfo.callMethodOnReceiver('is_drawable', this, []);
  bool getIsFocus() => _staticInfo.callMethodOnReceiver('is_focus', this, []);
  bool isSensitive() => _staticInfo.callMethodOnReceiver('is_sensitive', this, []);
  bool isToplevel() => _staticInfo.callMethodOnReceiver('is_toplevel', this, []);
  bool isVisible() => _staticInfo.callMethodOnReceiver('is_visible', this, []);
  bool keynavFailed(DirectionType direction) => _staticInfo.callMethodOnReceiver('keynav_failed', this, [direction]);
  GLibList /* this will fail */ listAccelClosures() => _staticInfo.callMethodOnReceiver('list_accel_closures', this, []);
  List<String> listActionPrefixes() => _staticInfo.callMethodOnReceiver('list_action_prefixes', this, []);
  GLibList /* this will fail */ listMnemonicLabels() => _staticInfo.callMethodOnReceiver('list_mnemonic_labels', this, []);
  void map() => _staticInfo.callMethodOnReceiver('map', this, []);
  bool mnemonicActivate(bool groupCycling) => _staticInfo.callMethodOnReceiver('mnemonic_activate', this, [groupCycling]);
  void modifyBase(StateType state, Color color) => _staticInfo.callMethodOnReceiver('modify_base', this, [state, color]);
  void modifyBg(StateType state, Color color) => _staticInfo.callMethodOnReceiver('modify_bg', this, [state, color]);
  void modifyCursor(Color primary, Color secondary) => _staticInfo.callMethodOnReceiver('modify_cursor', this, [primary, secondary]);
  void modifyFg(StateType state, Color color) => _staticInfo.callMethodOnReceiver('modify_fg', this, [state, color]);
  void modifyFont(FontDescription fontDesc) => _staticInfo.callMethodOnReceiver('modify_font', this, [fontDesc]);
  void modifyStyle(RcStyle style) => _staticInfo.callMethodOnReceiver('modify_style', this, [style]);
  void modifyText(StateType state, Color color) => _staticInfo.callMethodOnReceiver('modify_text', this, [state, color]);
  void overrideBackgroundColor(StateFlags state, RGBA color) => _staticInfo.callMethodOnReceiver('override_background_color', this, [state, color]);
  void overrideColor(StateFlags state, RGBA color) => _staticInfo.callMethodOnReceiver('override_color', this, [state, color]);
  void overrideCursor(RGBA cursor, RGBA secondaryCursor) => _staticInfo.callMethodOnReceiver('override_cursor', this, [cursor, secondaryCursor]);
  void overrideFont(FontDescription fontDesc) => _staticInfo.callMethodOnReceiver('override_font', this, [fontDesc]);
  void overrideSymbolicColor(String name, RGBA color) => _staticInfo.callMethodOnReceiver('override_symbolic_color', this, [name, color]);
  void path() => _staticInfo.callMethodOnReceiver('path', this, []);
  void queueComputeExpand() => _staticInfo.callMethodOnReceiver('queue_compute_expand', this, []);
  void queueDraw() => _staticInfo.callMethodOnReceiver('queue_draw', this, []);
  void queueDrawArea(int x, int y, int width, int height) => _staticInfo.callMethodOnReceiver('queue_draw_area', this, [x, y, width, height]);
  void queueDrawRegion(Region region) => _staticInfo.callMethodOnReceiver('queue_draw_region', this, [region]);
  void queueResize() => _staticInfo.callMethodOnReceiver('queue_resize', this, []);
  void queueResizeNoRedraw() => _staticInfo.callMethodOnReceiver('queue_resize_no_redraw', this, []);
  void realize() => _staticInfo.callMethodOnReceiver('realize', this, []);
  Region regionIntersect(Region region) => _staticInfo.callMethodOnReceiver('region_intersect', this, [region]);
  void registerWindow(gdk.Window window) => _staticInfo.callMethodOnReceiver('register_window', this, [window]);
  bool removeAccelerator(AccelGroup accelGroup, int accelKey, ModifierType accelMods) => _staticInfo.callMethodOnReceiver('remove_accelerator', this, [accelGroup, accelKey, accelMods]);
  void removeMnemonicLabel(Widget label) => _staticInfo.callMethodOnReceiver('remove_mnemonic_label', this, [label]);
  void removeTickCallback(int id) => _staticInfo.callMethodOnReceiver('remove_tick_callback', this, [id]);
  Pixbuf renderIcon(String stockId, int size, String detail) => _staticInfo.callMethodOnReceiver('render_icon', this, [stockId, size, detail]);
  Pixbuf renderIconPixbuf(String stockId, int size) => _staticInfo.callMethodOnReceiver('render_icon_pixbuf', this, [stockId, size]);
  void reparent(Widget newParent) => _staticInfo.callMethodOnReceiver('reparent', this, [newParent]);
  void resetRcStyles() => _staticInfo.callMethodOnReceiver('reset_rc_styles', this, []);
  void resetStyle() => _staticInfo.callMethodOnReceiver('reset_style', this, []);
  int sendExpose(Event event) => _staticInfo.callMethodOnReceiver('send_expose', this, [event]);
  bool sendFocusChange(Event event) => _staticInfo.callMethodOnReceiver('send_focus_change', this, [event]);
  void setAccelPath(String accelPath, AccelGroup accelGroup) => _staticInfo.callMethodOnReceiver('set_accel_path', this, [accelPath, accelGroup]);
  void setAllocation(RectangleInt allocation) => _staticInfo.callMethodOnReceiver('set_allocation', this, [allocation]);
  void set appPaintable(bool appPaintable) => _staticInfo.callMethodOnReceiver('set_app_paintable', this, [appPaintable]);
  void set canDefault(bool canDefault) => _staticInfo.callMethodOnReceiver('set_can_default', this, [canDefault]);
  void set canFocus(bool canFocus) => _staticInfo.callMethodOnReceiver('set_can_focus', this, [canFocus]);
  void setChildVisible(bool isVisible) => _staticInfo.callMethodOnReceiver('set_child_visible', this, [isVisible]);
  void setClip(RectangleInt clip) => _staticInfo.callMethodOnReceiver('set_clip', this, [clip]);
  void setCompositeName(String name) => _staticInfo.callMethodOnReceiver('set_composite_name', this, [name]);
  void setDeviceEnabled(Device device, bool enabled) => _staticInfo.callMethodOnReceiver('set_device_enabled', this, [device, enabled]);
  void setDeviceEvents(Device device, EventMask events) => _staticInfo.callMethodOnReceiver('set_device_events', this, [device, events]);
  void setDirection(TextDirection dir) => _staticInfo.callMethodOnReceiver('set_direction', this, [dir]);
  void set doubleBuffered(bool doubleBuffered) => _staticInfo.callMethodOnReceiver('set_double_buffered', this, [doubleBuffered]);
  void set _events(int events) => _staticInfo.callMethodOnReceiver('set_events', this, [events]);
  void set events(EventMask mask) {
    _events = mask.index;
  }
    void setFontMap(FontMap fontMap) => _staticInfo.callMethodOnReceiver('set_font_map', this, [fontMap]);
    void setFontOptions(FontOptions options) => _staticInfo.callMethodOnReceiver('set_font_options', this, [options]);
  void set halign(Align align) => _staticInfo.callMethodOnReceiver('set_halign', this, [align]);
  void set hasTooltip(bool hasTooltip) => _staticInfo.callMethodOnReceiver('set_has_tooltip', this, [hasTooltip]);
  void setHasWindow(bool hasWindow) => _staticInfo.callMethodOnReceiver('set_has_window', this, [hasWindow]);
  void set hexpand(bool expand) => _staticInfo.callMethodOnReceiver('set_hexpand', this, [expand]);
  void set hexpandSet(bool set_) => _staticInfo.callMethodOnReceiver('set_hexpand_set', this, [set_]);
  void setMapped(bool mapped) => _staticInfo.callMethodOnReceiver('set_mapped', this, [mapped]);
  void set marginBottom(int margin) => _staticInfo.callMethodOnReceiver('set_margin_bottom', this, [margin]);
  void set marginEnd(int margin) => _staticInfo.callMethodOnReceiver('set_margin_end', this, [margin]);
  void set marginLeft(int margin) => _staticInfo.callMethodOnReceiver('set_margin_left', this, [margin]);
  void set marginRight(int margin) => _staticInfo.callMethodOnReceiver('set_margin_right', this, [margin]);
  void set marginStart(int margin) => _staticInfo.callMethodOnReceiver('set_margin_start', this, [margin]);
  void set marginTop(int margin) => _staticInfo.callMethodOnReceiver('set_margin_top', this, [margin]);
  void set name(String name) => _staticInfo.callMethodOnReceiver('set_name', this, [name]);
  void set noShowAll(bool noShowAll) => _staticInfo.callMethodOnReceiver('set_no_show_all', this, [noShowAll]);
  void set opacity(num opacity) => _staticInfo.callMethodOnReceiver('set_opacity', this, [opacity]);
  void set parent(Widget parent) => _staticInfo.callMethodOnReceiver('set_parent', this, [parent]);
  void setParentWindow(gdk.Window parentWindow) => _staticInfo.callMethodOnReceiver('set_parent_window', this, [parentWindow]);
  void setRealized(bool realized) => _staticInfo.callMethodOnReceiver('set_realized', this, [realized]);
  void set receivesDefault(bool receivesDefault) => _staticInfo.callMethodOnReceiver('set_receives_default', this, [receivesDefault]);
  void setRedrawOnAllocate(bool redrawOnAllocate) => _staticInfo.callMethodOnReceiver('set_redraw_on_allocate', this, [redrawOnAllocate]);
  void set sensitive(bool sensitive) => _staticInfo.callMethodOnReceiver('set_sensitive', this, [sensitive]);
  void setSizeRequest(int width, int height) => _staticInfo.callMethodOnReceiver('set_size_request', this, [width, height]);
  void setState(StateType state) => _staticInfo.callMethodOnReceiver('set_state', this, [state]);
  void setStateFlags(StateFlags flags, bool clear) => _staticInfo.callMethodOnReceiver('set_state_flags', this, [flags, clear]);
  void set style(Style style) => _staticInfo.callMethodOnReceiver('set_style', this, [style]);
  void setSupportMultidevice(bool supportMultidevice) => _staticInfo.callMethodOnReceiver('set_support_multidevice', this, [supportMultidevice]);
  void set tooltipMarkup(String markup) => _staticInfo.callMethodOnReceiver('set_tooltip_markup', this, [markup]);
  void set tooltipText(String text) => _staticInfo.callMethodOnReceiver('set_tooltip_text', this, [text]);
  void setTooltipWindow(Window customWindow) => _staticInfo.callMethodOnReceiver('set_tooltip_window', this, [customWindow]);
  void set valign(Align align) => _staticInfo.callMethodOnReceiver('set_valign', this, [align]);
  void set vexpand(bool expand) => _staticInfo.callMethodOnReceiver('set_vexpand', this, [expand]);
  void set vexpandSet(bool set_) => _staticInfo.callMethodOnReceiver('set_vexpand_set', this, [set_]);
  void set visible(bool visible) => _staticInfo.callMethodOnReceiver('set_visible', this, [visible]);
  void setVisual(Visual visual) => _staticInfo.callMethodOnReceiver('set_visual', this, [visual]);
  void setWindow(gdk.Window window) => _staticInfo.callMethodOnReceiver('set_window', this, [window]);
  void shapeCombineRegion(Region region) => _staticInfo.callMethodOnReceiver('shape_combine_region', this, [region]);
  void show() => _staticInfo.callMethodOnReceiver('show', this, []);
  void showAll() => _staticInfo.callMethodOnReceiver('show_all', this, []);
  void showNow() => _staticInfo.callMethodOnReceiver('show_now', this, []);
  void sizeAllocate(RectangleInt allocation) => _staticInfo.callMethodOnReceiver('size_allocate', this, [allocation]);
  void sizeAllocateWithBaseline(RectangleInt allocation, int baseline) => _staticInfo.callMethodOnReceiver('size_allocate_with_baseline', this, [allocation, baseline]);
  void sizeRequest() => _staticInfo.callMethodOnReceiver('size_request', this, []);
  void styleAttach() => _staticInfo.callMethodOnReceiver('style_attach', this, []);
  void styleGetProperty(String propertyName, Value value) => _staticInfo.callMethodOnReceiver('style_get_property', this, [propertyName, value]);
  void thawChildNotify() => _staticInfo.callMethodOnReceiver('thaw_child_notify', this, []);
  bool translateCoordinates(Widget destWidget, int srcX, int srcY) => _staticInfo.callMethodOnReceiver('translate_coordinates', this, [destWidget, srcX, srcY]);
  void triggerTooltipQuery() => _staticInfo.callMethodOnReceiver('trigger_tooltip_query', this, []);
  void unmap() => _staticInfo.callMethodOnReceiver('unmap', this, []);
  void unparent() => _staticInfo.callMethodOnReceiver('unparent', this, []);
  void unrealize() => _staticInfo.callMethodOnReceiver('unrealize', this, []);
  void unregisterWindow(gdk.Window window) => _staticInfo.callMethodOnReceiver('unregister_window', this, [window]);
  void unsetStateFlags(StateFlags flags) => _staticInfo.callMethodOnReceiver('unset_state_flags', this, [flags]);
  int _connectToAccelClosuresChanged(bool after, void func()) => signalConnect('accel-closures-changed', func, after);
  Stream get onAccelClosuresChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToAccelClosuresChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterAccelClosuresChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToAccelClosuresChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToButtonPressEvent(bool after, bool func(EventButton event)) => signalConnect('button-press-event', func, after);
  Stream<WidgetButtonPressEventEvent> get onButtonPressEvent {
    int signalId;
    StreamController<WidgetButtonPressEventEvent> controller;
    controller = new StreamController<WidgetButtonPressEventEvent>(
      onListen: () {
          signalId = _connectToButtonPressEvent(false, (EventButton event) {
              var result = new WidgetButtonPressEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetButtonPressEventEvent> get afterButtonPressEvent {
    int signalId;
    StreamController<WidgetButtonPressEventEvent> controller;
    controller = new StreamController<WidgetButtonPressEventEvent>(
      onListen: () {
          signalId = _connectToButtonPressEvent(true, (EventButton event) {
              var result = new WidgetButtonPressEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToButtonReleaseEvent(bool after, bool func(EventButton event)) => signalConnect('button-release-event', func, after);
  Stream<WidgetButtonReleaseEventEvent> get onButtonReleaseEvent {
    int signalId;
    StreamController<WidgetButtonReleaseEventEvent> controller;
    controller = new StreamController<WidgetButtonReleaseEventEvent>(
      onListen: () {
          signalId = _connectToButtonReleaseEvent(false, (EventButton event) {
              var result = new WidgetButtonReleaseEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetButtonReleaseEventEvent> get afterButtonReleaseEvent {
    int signalId;
    StreamController<WidgetButtonReleaseEventEvent> controller;
    controller = new StreamController<WidgetButtonReleaseEventEvent>(
      onListen: () {
          signalId = _connectToButtonReleaseEvent(true, (EventButton event) {
              var result = new WidgetButtonReleaseEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCanActivateAccel(bool after, bool func(int signalId)) => signalConnect('can-activate-accel', func, after);
  Stream<WidgetCanActivateAccelEvent> get onCanActivateAccel {
    int signalId;
    StreamController<WidgetCanActivateAccelEvent> controller;
    controller = new StreamController<WidgetCanActivateAccelEvent>(
      onListen: () {
          signalId = _connectToCanActivateAccel(false, (int signalId) {
              var result = new WidgetCanActivateAccelEvent(signalId);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetCanActivateAccelEvent> get afterCanActivateAccel {
    int signalId;
    StreamController<WidgetCanActivateAccelEvent> controller;
    controller = new StreamController<WidgetCanActivateAccelEvent>(
      onListen: () {
          signalId = _connectToCanActivateAccel(true, (int signalId) {
              var result = new WidgetCanActivateAccelEvent(signalId);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToChildNotify(bool after, void func(ParamSpec childProperty)) => signalConnect('child-notify', func, after);
  Stream<ParamSpec> get onChildNotify {
    int signalId;
    StreamController<ParamSpec> controller;
    controller = new StreamController<ParamSpec>(
      onListen: () {
          signalId = _connectToChildNotify(false, (ParamSpec childProperty) {
              controller.add(childProperty);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<ParamSpec> get afterChildNotify {
    int signalId;
    StreamController<ParamSpec> controller;
    controller = new StreamController<ParamSpec>(
      onListen: () {
          signalId = _connectToChildNotify(true, (ParamSpec childProperty) {
              controller.add(childProperty);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToCompositedChanged(bool after, void func()) => signalConnect('composited-changed', func, after);
  Stream get onCompositedChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCompositedChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterCompositedChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToCompositedChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToConfigureEvent(bool after, bool func(EventConfigure event)) => signalConnect('configure-event', func, after);
  Stream<WidgetConfigureEventEvent> get onConfigureEvent {
    int signalId;
    StreamController<WidgetConfigureEventEvent> controller;
    controller = new StreamController<WidgetConfigureEventEvent>(
      onListen: () {
          signalId = _connectToConfigureEvent(false, (EventConfigure event) {
              var result = new WidgetConfigureEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetConfigureEventEvent> get afterConfigureEvent {
    int signalId;
    StreamController<WidgetConfigureEventEvent> controller;
    controller = new StreamController<WidgetConfigureEventEvent>(
      onListen: () {
          signalId = _connectToConfigureEvent(true, (EventConfigure event) {
              var result = new WidgetConfigureEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDamageEvent(bool after, bool func(EventExpose event)) => signalConnect('damage-event', func, after);
  Stream<WidgetDamageEventEvent> get onDamageEvent {
    int signalId;
    StreamController<WidgetDamageEventEvent> controller;
    controller = new StreamController<WidgetDamageEventEvent>(
      onListen: () {
          signalId = _connectToDamageEvent(false, (EventExpose event) {
              var result = new WidgetDamageEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetDamageEventEvent> get afterDamageEvent {
    int signalId;
    StreamController<WidgetDamageEventEvent> controller;
    controller = new StreamController<WidgetDamageEventEvent>(
      onListen: () {
          signalId = _connectToDamageEvent(true, (EventExpose event) {
              var result = new WidgetDamageEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDeleteEvent(bool after, bool func(Event event)) => signalConnect('delete-event', func, after);
  Stream<WidgetDeleteEventEvent> get onDeleteEvent {
    int signalId;
    StreamController<WidgetDeleteEventEvent> controller;
    controller = new StreamController<WidgetDeleteEventEvent>(
      onListen: () {
          signalId = _connectToDeleteEvent(false, (Event event) {
              var result = new WidgetDeleteEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetDeleteEventEvent> get afterDeleteEvent {
    int signalId;
    StreamController<WidgetDeleteEventEvent> controller;
    controller = new StreamController<WidgetDeleteEventEvent>(
      onListen: () {
          signalId = _connectToDeleteEvent(true, (Event event) {
              var result = new WidgetDeleteEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDestroy(bool after, void func()) => signalConnect('destroy', func, after);
  Stream get onDestroy {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDestroy(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterDestroy {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToDestroy(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDestroyEvent(bool after, bool func(Event event)) => signalConnect('destroy-event', func, after);
  Stream<WidgetDestroyEventEvent> get onDestroyEvent {
    int signalId;
    StreamController<WidgetDestroyEventEvent> controller;
    controller = new StreamController<WidgetDestroyEventEvent>(
      onListen: () {
          signalId = _connectToDestroyEvent(false, (Event event) {
              var result = new WidgetDestroyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetDestroyEventEvent> get afterDestroyEvent {
    int signalId;
    StreamController<WidgetDestroyEventEvent> controller;
    controller = new StreamController<WidgetDestroyEventEvent>(
      onListen: () {
          signalId = _connectToDestroyEvent(true, (Event event) {
              var result = new WidgetDestroyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDirectionChanged(bool after, void func(TextDirection previousDirection)) => signalConnect('direction-changed', func, after);
  Stream<TextDirection> get onDirectionChanged {
    int signalId;
    StreamController<TextDirection> controller;
    controller = new StreamController<TextDirection>(
      onListen: () {
          signalId = _connectToDirectionChanged(false, (TextDirection previousDirection) {
              controller.add(previousDirection);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<TextDirection> get afterDirectionChanged {
    int signalId;
    StreamController<TextDirection> controller;
    controller = new StreamController<TextDirection>(
      onListen: () {
          signalId = _connectToDirectionChanged(true, (TextDirection previousDirection) {
              controller.add(previousDirection);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDragBegin(bool after, void func(DragContext context)) => signalConnect('drag-begin', func, after);
  Stream<DragContext> get onDragBegin {
    int signalId;
    StreamController<DragContext> controller;
    controller = new StreamController<DragContext>(
      onListen: () {
          signalId = _connectToDragBegin(false, (DragContext context) {
              controller.add(context);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<DragContext> get afterDragBegin {
    int signalId;
    StreamController<DragContext> controller;
    controller = new StreamController<DragContext>(
      onListen: () {
          signalId = _connectToDragBegin(true, (DragContext context) {
              controller.add(context);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDragDataDelete(bool after, void func(DragContext context)) => signalConnect('drag-data-delete', func, after);
  Stream<DragContext> get onDragDataDelete {
    int signalId;
    StreamController<DragContext> controller;
    controller = new StreamController<DragContext>(
      onListen: () {
          signalId = _connectToDragDataDelete(false, (DragContext context) {
              controller.add(context);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<DragContext> get afterDragDataDelete {
    int signalId;
    StreamController<DragContext> controller;
    controller = new StreamController<DragContext>(
      onListen: () {
          signalId = _connectToDragDataDelete(true, (DragContext context) {
              controller.add(context);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDragDataGet(bool after, void func(DragContext context, SelectionData data, int info, int time)) => signalConnect('drag-data-get', func, after);
  Stream<WidgetDragDataGetEvent> get onDragDataGet {
    int signalId;
    StreamController<WidgetDragDataGetEvent> controller;
    controller = new StreamController<WidgetDragDataGetEvent>(
      onListen: () {
          signalId = _connectToDragDataGet(false, (DragContext context, SelectionData data, int info, int time) {
              var result = new WidgetDragDataGetEvent(context, data, info, time);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetDragDataGetEvent> get afterDragDataGet {
    int signalId;
    StreamController<WidgetDragDataGetEvent> controller;
    controller = new StreamController<WidgetDragDataGetEvent>(
      onListen: () {
          signalId = _connectToDragDataGet(true, (DragContext context, SelectionData data, int info, int time) {
              var result = new WidgetDragDataGetEvent(context, data, info, time);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDragDataReceived(bool after, void func(DragContext context, int x, int y, SelectionData data, int info, int time)) => signalConnect('drag-data-received', func, after);
  Stream<WidgetDragDataReceivedEvent> get onDragDataReceived {
    int signalId;
    StreamController<WidgetDragDataReceivedEvent> controller;
    controller = new StreamController<WidgetDragDataReceivedEvent>(
      onListen: () {
          signalId = _connectToDragDataReceived(false, (DragContext context, int x, int y, SelectionData data, int info, int time) {
              var result = new WidgetDragDataReceivedEvent(context, x, y, data, info, time);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetDragDataReceivedEvent> get afterDragDataReceived {
    int signalId;
    StreamController<WidgetDragDataReceivedEvent> controller;
    controller = new StreamController<WidgetDragDataReceivedEvent>(
      onListen: () {
          signalId = _connectToDragDataReceived(true, (DragContext context, int x, int y, SelectionData data, int info, int time) {
              var result = new WidgetDragDataReceivedEvent(context, x, y, data, info, time);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDragDrop(bool after, bool func(DragContext context, int x, int y, int time)) => signalConnect('drag-drop', func, after);
  Stream<WidgetDragDropEvent> get onDragDrop {
    int signalId;
    StreamController<WidgetDragDropEvent> controller;
    controller = new StreamController<WidgetDragDropEvent>(
      onListen: () {
          signalId = _connectToDragDrop(false, (DragContext context, int x, int y, int time) {
              var result = new WidgetDragDropEvent(context, x, y, time);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetDragDropEvent> get afterDragDrop {
    int signalId;
    StreamController<WidgetDragDropEvent> controller;
    controller = new StreamController<WidgetDragDropEvent>(
      onListen: () {
          signalId = _connectToDragDrop(true, (DragContext context, int x, int y, int time) {
              var result = new WidgetDragDropEvent(context, x, y, time);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDragEnd(bool after, void func(DragContext context)) => signalConnect('drag-end', func, after);
  Stream<DragContext> get onDragEnd {
    int signalId;
    StreamController<DragContext> controller;
    controller = new StreamController<DragContext>(
      onListen: () {
          signalId = _connectToDragEnd(false, (DragContext context) {
              controller.add(context);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<DragContext> get afterDragEnd {
    int signalId;
    StreamController<DragContext> controller;
    controller = new StreamController<DragContext>(
      onListen: () {
          signalId = _connectToDragEnd(true, (DragContext context) {
              controller.add(context);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDragFailed(bool after, bool func(DragContext context, DragResult result_)) => signalConnect('drag-failed', func, after);
  Stream<WidgetDragFailedEvent> get onDragFailed {
    int signalId;
    StreamController<WidgetDragFailedEvent> controller;
    controller = new StreamController<WidgetDragFailedEvent>(
      onListen: () {
          signalId = _connectToDragFailed(false, (DragContext context, DragResult result_) {
              var result = new WidgetDragFailedEvent(context, result_);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetDragFailedEvent> get afterDragFailed {
    int signalId;
    StreamController<WidgetDragFailedEvent> controller;
    controller = new StreamController<WidgetDragFailedEvent>(
      onListen: () {
          signalId = _connectToDragFailed(true, (DragContext context, DragResult result_) {
              var result = new WidgetDragFailedEvent(context, result_);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDragLeave(bool after, void func(DragContext context, int time)) => signalConnect('drag-leave', func, after);
  Stream<WidgetDragLeaveEvent> get onDragLeave {
    int signalId;
    StreamController<WidgetDragLeaveEvent> controller;
    controller = new StreamController<WidgetDragLeaveEvent>(
      onListen: () {
          signalId = _connectToDragLeave(false, (DragContext context, int time) {
              var result = new WidgetDragLeaveEvent(context, time);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetDragLeaveEvent> get afterDragLeave {
    int signalId;
    StreamController<WidgetDragLeaveEvent> controller;
    controller = new StreamController<WidgetDragLeaveEvent>(
      onListen: () {
          signalId = _connectToDragLeave(true, (DragContext context, int time) {
              var result = new WidgetDragLeaveEvent(context, time);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDragMotion(bool after, bool func(DragContext context, int x, int y, int time)) => signalConnect('drag-motion', func, after);
  Stream<WidgetDragMotionEvent> get onDragMotion {
    int signalId;
    StreamController<WidgetDragMotionEvent> controller;
    controller = new StreamController<WidgetDragMotionEvent>(
      onListen: () {
          signalId = _connectToDragMotion(false, (DragContext context, int x, int y, int time) {
              var result = new WidgetDragMotionEvent(context, x, y, time);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetDragMotionEvent> get afterDragMotion {
    int signalId;
    StreamController<WidgetDragMotionEvent> controller;
    controller = new StreamController<WidgetDragMotionEvent>(
      onListen: () {
          signalId = _connectToDragMotion(true, (DragContext context, int x, int y, int time) {
              var result = new WidgetDragMotionEvent(context, x, y, time);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToDraw(bool after, bool func(Context cr)) => signalConnect('draw', func, after);
  Stream<WidgetDrawEvent> get onDraw {
    int signalId;
    StreamController<WidgetDrawEvent> controller;
    controller = new StreamController<WidgetDrawEvent>(
      onListen: () {
          signalId = _connectToDraw(false, (Context cr) {
              var result = new WidgetDrawEvent(cr);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetDrawEvent> get afterDraw {
    int signalId;
    StreamController<WidgetDrawEvent> controller;
    controller = new StreamController<WidgetDrawEvent>(
      onListen: () {
          signalId = _connectToDraw(true, (Context cr) {
              var result = new WidgetDrawEvent(cr);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToEnterNotifyEvent(bool after, bool func(EventCrossing event)) => signalConnect('enter-notify-event', func, after);
  Stream<WidgetEnterNotifyEventEvent> get onEnterNotifyEvent {
    int signalId;
    StreamController<WidgetEnterNotifyEventEvent> controller;
    controller = new StreamController<WidgetEnterNotifyEventEvent>(
      onListen: () {
          signalId = _connectToEnterNotifyEvent(false, (EventCrossing event) {
              var result = new WidgetEnterNotifyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetEnterNotifyEventEvent> get afterEnterNotifyEvent {
    int signalId;
    StreamController<WidgetEnterNotifyEventEvent> controller;
    controller = new StreamController<WidgetEnterNotifyEventEvent>(
      onListen: () {
          signalId = _connectToEnterNotifyEvent(true, (EventCrossing event) {
              var result = new WidgetEnterNotifyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToEvent(bool after, bool func(Event event)) => signalConnect('event', func, after);
  Stream<WidgetEventEvent> get onEvent {
    int signalId;
    StreamController<WidgetEventEvent> controller;
    controller = new StreamController<WidgetEventEvent>(
      onListen: () {
          signalId = _connectToEvent(false, (Event event) {
              var result = new WidgetEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetEventEvent> get afterEvent {
    int signalId;
    StreamController<WidgetEventEvent> controller;
    controller = new StreamController<WidgetEventEvent>(
      onListen: () {
          signalId = _connectToEvent(true, (Event event) {
              var result = new WidgetEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToEventAfter(bool after, void func(Event event)) => signalConnect('event-after', func, after);
  Stream<Event> get onEventAfter {
    int signalId;
    StreamController<Event> controller;
    controller = new StreamController<Event>(
      onListen: () {
          signalId = _connectToEventAfter(false, (Event event) {
              controller.add(event);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Event> get afterEventAfter {
    int signalId;
    StreamController<Event> controller;
    controller = new StreamController<Event>(
      onListen: () {
          signalId = _connectToEventAfter(true, (Event event) {
              controller.add(event);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToFocus(bool after, bool func(DirectionType direction)) => signalConnect('focus', func, after);
  Stream<WidgetFocusEvent> get onFocus {
    int signalId;
    StreamController<WidgetFocusEvent> controller;
    controller = new StreamController<WidgetFocusEvent>(
      onListen: () {
          signalId = _connectToFocus(false, (DirectionType direction) {
              var result = new WidgetFocusEvent(direction);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetFocusEvent> get afterFocus {
    int signalId;
    StreamController<WidgetFocusEvent> controller;
    controller = new StreamController<WidgetFocusEvent>(
      onListen: () {
          signalId = _connectToFocus(true, (DirectionType direction) {
              var result = new WidgetFocusEvent(direction);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToFocusInEvent(bool after, bool func(EventFocus event)) => signalConnect('focus-in-event', func, after);
  Stream<WidgetFocusInEventEvent> get onFocusInEvent {
    int signalId;
    StreamController<WidgetFocusInEventEvent> controller;
    controller = new StreamController<WidgetFocusInEventEvent>(
      onListen: () {
          signalId = _connectToFocusInEvent(false, (EventFocus event) {
              var result = new WidgetFocusInEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetFocusInEventEvent> get afterFocusInEvent {
    int signalId;
    StreamController<WidgetFocusInEventEvent> controller;
    controller = new StreamController<WidgetFocusInEventEvent>(
      onListen: () {
          signalId = _connectToFocusInEvent(true, (EventFocus event) {
              var result = new WidgetFocusInEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToFocusOutEvent(bool after, bool func(EventFocus event)) => signalConnect('focus-out-event', func, after);
  Stream<WidgetFocusOutEventEvent> get onFocusOutEvent {
    int signalId;
    StreamController<WidgetFocusOutEventEvent> controller;
    controller = new StreamController<WidgetFocusOutEventEvent>(
      onListen: () {
          signalId = _connectToFocusOutEvent(false, (EventFocus event) {
              var result = new WidgetFocusOutEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetFocusOutEventEvent> get afterFocusOutEvent {
    int signalId;
    StreamController<WidgetFocusOutEventEvent> controller;
    controller = new StreamController<WidgetFocusOutEventEvent>(
      onListen: () {
          signalId = _connectToFocusOutEvent(true, (EventFocus event) {
              var result = new WidgetFocusOutEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToGrabBrokenEvent(bool after, bool func(EventGrabBroken event)) => signalConnect('grab-broken-event', func, after);
  Stream<WidgetGrabBrokenEventEvent> get onGrabBrokenEvent {
    int signalId;
    StreamController<WidgetGrabBrokenEventEvent> controller;
    controller = new StreamController<WidgetGrabBrokenEventEvent>(
      onListen: () {
          signalId = _connectToGrabBrokenEvent(false, (EventGrabBroken event) {
              var result = new WidgetGrabBrokenEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetGrabBrokenEventEvent> get afterGrabBrokenEvent {
    int signalId;
    StreamController<WidgetGrabBrokenEventEvent> controller;
    controller = new StreamController<WidgetGrabBrokenEventEvent>(
      onListen: () {
          signalId = _connectToGrabBrokenEvent(true, (EventGrabBroken event) {
              var result = new WidgetGrabBrokenEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToGrabFocus(bool after, void func()) => signalConnect('grab-focus', func, after);
  Stream get onGrabFocus {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToGrabFocus(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterGrabFocus {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToGrabFocus(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToGrabNotify(bool after, void func(bool wasGrabbed)) => signalConnect('grab-notify', func, after);
  Stream<bool> get onGrabNotify {
    int signalId;
    StreamController<bool> controller;
    controller = new StreamController<bool>(
      onListen: () {
          signalId = _connectToGrabNotify(false, (bool wasGrabbed) {
              controller.add(wasGrabbed);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<bool> get afterGrabNotify {
    int signalId;
    StreamController<bool> controller;
    controller = new StreamController<bool>(
      onListen: () {
          signalId = _connectToGrabNotify(true, (bool wasGrabbed) {
              controller.add(wasGrabbed);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToHide(bool after, void func()) => signalConnect('hide', func, after);
  Stream get onHide {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToHide(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterHide {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToHide(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToHierarchyChanged(bool after, void func(Widget previousToplevel)) => signalConnect('hierarchy-changed', func, after);
  Stream<Widget> get onHierarchyChanged {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToHierarchyChanged(false, (Widget previousToplevel) {
              controller.add(previousToplevel);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Widget> get afterHierarchyChanged {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToHierarchyChanged(true, (Widget previousToplevel) {
              controller.add(previousToplevel);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToKeyPressEvent(bool after, bool func(EventKey event)) => signalConnect('key-press-event', func, after);
  Stream<WidgetKeyPressEventEvent> get onKeyPressEvent {
    int signalId;
    StreamController<WidgetKeyPressEventEvent> controller;
    controller = new StreamController<WidgetKeyPressEventEvent>(
      onListen: () {
          signalId = _connectToKeyPressEvent(false, (EventKey event) {
              var result = new WidgetKeyPressEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetKeyPressEventEvent> get afterKeyPressEvent {
    int signalId;
    StreamController<WidgetKeyPressEventEvent> controller;
    controller = new StreamController<WidgetKeyPressEventEvent>(
      onListen: () {
          signalId = _connectToKeyPressEvent(true, (EventKey event) {
              var result = new WidgetKeyPressEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToKeyReleaseEvent(bool after, bool func(EventKey event)) => signalConnect('key-release-event', func, after);
  Stream<WidgetKeyReleaseEventEvent> get onKeyReleaseEvent {
    int signalId;
    StreamController<WidgetKeyReleaseEventEvent> controller;
    controller = new StreamController<WidgetKeyReleaseEventEvent>(
      onListen: () {
          signalId = _connectToKeyReleaseEvent(false, (EventKey event) {
              var result = new WidgetKeyReleaseEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetKeyReleaseEventEvent> get afterKeyReleaseEvent {
    int signalId;
    StreamController<WidgetKeyReleaseEventEvent> controller;
    controller = new StreamController<WidgetKeyReleaseEventEvent>(
      onListen: () {
          signalId = _connectToKeyReleaseEvent(true, (EventKey event) {
              var result = new WidgetKeyReleaseEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToKeynavFailed(bool after, bool func(DirectionType direction)) => signalConnect('keynav-failed', func, after);
  Stream<WidgetKeynavFailedEvent> get onKeynavFailed {
    int signalId;
    StreamController<WidgetKeynavFailedEvent> controller;
    controller = new StreamController<WidgetKeynavFailedEvent>(
      onListen: () {
          signalId = _connectToKeynavFailed(false, (DirectionType direction) {
              var result = new WidgetKeynavFailedEvent(direction);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetKeynavFailedEvent> get afterKeynavFailed {
    int signalId;
    StreamController<WidgetKeynavFailedEvent> controller;
    controller = new StreamController<WidgetKeynavFailedEvent>(
      onListen: () {
          signalId = _connectToKeynavFailed(true, (DirectionType direction) {
              var result = new WidgetKeynavFailedEvent(direction);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToLeaveNotifyEvent(bool after, bool func(EventCrossing event)) => signalConnect('leave-notify-event', func, after);
  Stream<WidgetLeaveNotifyEventEvent> get onLeaveNotifyEvent {
    int signalId;
    StreamController<WidgetLeaveNotifyEventEvent> controller;
    controller = new StreamController<WidgetLeaveNotifyEventEvent>(
      onListen: () {
          signalId = _connectToLeaveNotifyEvent(false, (EventCrossing event) {
              var result = new WidgetLeaveNotifyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetLeaveNotifyEventEvent> get afterLeaveNotifyEvent {
    int signalId;
    StreamController<WidgetLeaveNotifyEventEvent> controller;
    controller = new StreamController<WidgetLeaveNotifyEventEvent>(
      onListen: () {
          signalId = _connectToLeaveNotifyEvent(true, (EventCrossing event) {
              var result = new WidgetLeaveNotifyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMap(bool after, void func()) => signalConnect('map', func, after);
  Stream get onMap {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToMap(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterMap {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToMap(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMapEvent(bool after, bool func(EventAny event)) => signalConnect('map-event', func, after);
  Stream<WidgetMapEventEvent> get onMapEvent {
    int signalId;
    StreamController<WidgetMapEventEvent> controller;
    controller = new StreamController<WidgetMapEventEvent>(
      onListen: () {
          signalId = _connectToMapEvent(false, (EventAny event) {
              var result = new WidgetMapEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetMapEventEvent> get afterMapEvent {
    int signalId;
    StreamController<WidgetMapEventEvent> controller;
    controller = new StreamController<WidgetMapEventEvent>(
      onListen: () {
          signalId = _connectToMapEvent(true, (EventAny event) {
              var result = new WidgetMapEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMnemonicActivate(bool after, bool func(bool arg1)) => signalConnect('mnemonic-activate', func, after);
  Stream<WidgetMnemonicActivateEvent> get onMnemonicActivate {
    int signalId;
    StreamController<WidgetMnemonicActivateEvent> controller;
    controller = new StreamController<WidgetMnemonicActivateEvent>(
      onListen: () {
          signalId = _connectToMnemonicActivate(false, (bool arg1) {
              var result = new WidgetMnemonicActivateEvent(arg1);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetMnemonicActivateEvent> get afterMnemonicActivate {
    int signalId;
    StreamController<WidgetMnemonicActivateEvent> controller;
    controller = new StreamController<WidgetMnemonicActivateEvent>(
      onListen: () {
          signalId = _connectToMnemonicActivate(true, (bool arg1) {
              var result = new WidgetMnemonicActivateEvent(arg1);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMotionNotifyEvent(bool after, bool func(EventMotion event)) => signalConnect('motion-notify-event', func, after);
  Stream<WidgetMotionNotifyEventEvent> get onMotionNotifyEvent {
    int signalId;
    StreamController<WidgetMotionNotifyEventEvent> controller;
    controller = new StreamController<WidgetMotionNotifyEventEvent>(
      onListen: () {
          signalId = _connectToMotionNotifyEvent(false, (EventMotion event) {
              var result = new WidgetMotionNotifyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetMotionNotifyEventEvent> get afterMotionNotifyEvent {
    int signalId;
    StreamController<WidgetMotionNotifyEventEvent> controller;
    controller = new StreamController<WidgetMotionNotifyEventEvent>(
      onListen: () {
          signalId = _connectToMotionNotifyEvent(true, (EventMotion event) {
              var result = new WidgetMotionNotifyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToMoveFocus(bool after, void func(DirectionType direction)) => signalConnect('move-focus', func, after);
  Stream<DirectionType> get onMoveFocus {
    int signalId;
    StreamController<DirectionType> controller;
    controller = new StreamController<DirectionType>(
      onListen: () {
          signalId = _connectToMoveFocus(false, (DirectionType direction) {
              controller.add(direction);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<DirectionType> get afterMoveFocus {
    int signalId;
    StreamController<DirectionType> controller;
    controller = new StreamController<DirectionType>(
      onListen: () {
          signalId = _connectToMoveFocus(true, (DirectionType direction) {
              controller.add(direction);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToParentSet(bool after, void func(Widget oldParent)) => signalConnect('parent-set', func, after);
  Stream<Widget> get onParentSet {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToParentSet(false, (Widget oldParent) {
              controller.add(oldParent);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Widget> get afterParentSet {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToParentSet(true, (Widget oldParent) {
              controller.add(oldParent);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPopupMenu(bool after, bool func()) => signalConnect('popup-menu', func, after);
  Stream<WidgetPopupMenuEvent> get onPopupMenu {
    int signalId;
    StreamController<WidgetPopupMenuEvent> controller;
    controller = new StreamController<WidgetPopupMenuEvent>(
      onListen: () {
          signalId = _connectToPopupMenu(false, () {
              var result = new WidgetPopupMenuEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetPopupMenuEvent> get afterPopupMenu {
    int signalId;
    StreamController<WidgetPopupMenuEvent> controller;
    controller = new StreamController<WidgetPopupMenuEvent>(
      onListen: () {
          signalId = _connectToPopupMenu(true, () {
              var result = new WidgetPopupMenuEvent();
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToPropertyNotifyEvent(bool after, bool func(EventProperty event)) => signalConnect('property-notify-event', func, after);
  Stream<WidgetPropertyNotifyEventEvent> get onPropertyNotifyEvent {
    int signalId;
    StreamController<WidgetPropertyNotifyEventEvent> controller;
    controller = new StreamController<WidgetPropertyNotifyEventEvent>(
      onListen: () {
          signalId = _connectToPropertyNotifyEvent(false, (EventProperty event) {
              var result = new WidgetPropertyNotifyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetPropertyNotifyEventEvent> get afterPropertyNotifyEvent {
    int signalId;
    StreamController<WidgetPropertyNotifyEventEvent> controller;
    controller = new StreamController<WidgetPropertyNotifyEventEvent>(
      onListen: () {
          signalId = _connectToPropertyNotifyEvent(true, (EventProperty event) {
              var result = new WidgetPropertyNotifyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToProximityInEvent(bool after, bool func(EventProximity event)) => signalConnect('proximity-in-event', func, after);
  Stream<WidgetProximityInEventEvent> get onProximityInEvent {
    int signalId;
    StreamController<WidgetProximityInEventEvent> controller;
    controller = new StreamController<WidgetProximityInEventEvent>(
      onListen: () {
          signalId = _connectToProximityInEvent(false, (EventProximity event) {
              var result = new WidgetProximityInEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetProximityInEventEvent> get afterProximityInEvent {
    int signalId;
    StreamController<WidgetProximityInEventEvent> controller;
    controller = new StreamController<WidgetProximityInEventEvent>(
      onListen: () {
          signalId = _connectToProximityInEvent(true, (EventProximity event) {
              var result = new WidgetProximityInEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToProximityOutEvent(bool after, bool func(EventProximity event)) => signalConnect('proximity-out-event', func, after);
  Stream<WidgetProximityOutEventEvent> get onProximityOutEvent {
    int signalId;
    StreamController<WidgetProximityOutEventEvent> controller;
    controller = new StreamController<WidgetProximityOutEventEvent>(
      onListen: () {
          signalId = _connectToProximityOutEvent(false, (EventProximity event) {
              var result = new WidgetProximityOutEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetProximityOutEventEvent> get afterProximityOutEvent {
    int signalId;
    StreamController<WidgetProximityOutEventEvent> controller;
    controller = new StreamController<WidgetProximityOutEventEvent>(
      onListen: () {
          signalId = _connectToProximityOutEvent(true, (EventProximity event) {
              var result = new WidgetProximityOutEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToQueryTooltip(bool after, bool func(int x, int y, bool keyboardMode, Tooltip tooltip)) => signalConnect('query-tooltip', func, after);
  Stream<WidgetQueryTooltipEvent> get onQueryTooltip {
    int signalId;
    StreamController<WidgetQueryTooltipEvent> controller;
    controller = new StreamController<WidgetQueryTooltipEvent>(
      onListen: () {
          signalId = _connectToQueryTooltip(false, (int x, int y, bool keyboardMode, Tooltip tooltip) {
              var result = new WidgetQueryTooltipEvent(x, y, keyboardMode, tooltip);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetQueryTooltipEvent> get afterQueryTooltip {
    int signalId;
    StreamController<WidgetQueryTooltipEvent> controller;
    controller = new StreamController<WidgetQueryTooltipEvent>(
      onListen: () {
          signalId = _connectToQueryTooltip(true, (int x, int y, bool keyboardMode, Tooltip tooltip) {
              var result = new WidgetQueryTooltipEvent(x, y, keyboardMode, tooltip);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToRealize(bool after, void func()) => signalConnect('realize', func, after);
  Stream get onRealize {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToRealize(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterRealize {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToRealize(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToScreenChanged(bool after, void func(Screen previousScreen)) => signalConnect('screen-changed', func, after);
  Stream<Screen> get onScreenChanged {
    int signalId;
    StreamController<Screen> controller;
    controller = new StreamController<Screen>(
      onListen: () {
          signalId = _connectToScreenChanged(false, (Screen previousScreen) {
              controller.add(previousScreen);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Screen> get afterScreenChanged {
    int signalId;
    StreamController<Screen> controller;
    controller = new StreamController<Screen>(
      onListen: () {
          signalId = _connectToScreenChanged(true, (Screen previousScreen) {
              controller.add(previousScreen);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToScrollEvent(bool after, bool func(EventScroll event)) => signalConnect('scroll-event', func, after);
  Stream<WidgetScrollEventEvent> get onScrollEvent {
    int signalId;
    StreamController<WidgetScrollEventEvent> controller;
    controller = new StreamController<WidgetScrollEventEvent>(
      onListen: () {
          signalId = _connectToScrollEvent(false, (EventScroll event) {
              var result = new WidgetScrollEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetScrollEventEvent> get afterScrollEvent {
    int signalId;
    StreamController<WidgetScrollEventEvent> controller;
    controller = new StreamController<WidgetScrollEventEvent>(
      onListen: () {
          signalId = _connectToScrollEvent(true, (EventScroll event) {
              var result = new WidgetScrollEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectionClearEvent(bool after, bool func(EventSelection event)) => signalConnect('selection-clear-event', func, after);
  Stream<WidgetSelectionClearEventEvent> get onSelectionClearEvent {
    int signalId;
    StreamController<WidgetSelectionClearEventEvent> controller;
    controller = new StreamController<WidgetSelectionClearEventEvent>(
      onListen: () {
          signalId = _connectToSelectionClearEvent(false, (EventSelection event) {
              var result = new WidgetSelectionClearEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetSelectionClearEventEvent> get afterSelectionClearEvent {
    int signalId;
    StreamController<WidgetSelectionClearEventEvent> controller;
    controller = new StreamController<WidgetSelectionClearEventEvent>(
      onListen: () {
          signalId = _connectToSelectionClearEvent(true, (EventSelection event) {
              var result = new WidgetSelectionClearEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectionGet(bool after, void func(SelectionData data, int info, int time)) => signalConnect('selection-get', func, after);
  Stream<WidgetSelectionGetEvent> get onSelectionGet {
    int signalId;
    StreamController<WidgetSelectionGetEvent> controller;
    controller = new StreamController<WidgetSelectionGetEvent>(
      onListen: () {
          signalId = _connectToSelectionGet(false, (SelectionData data, int info, int time) {
              var result = new WidgetSelectionGetEvent(data, info, time);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetSelectionGetEvent> get afterSelectionGet {
    int signalId;
    StreamController<WidgetSelectionGetEvent> controller;
    controller = new StreamController<WidgetSelectionGetEvent>(
      onListen: () {
          signalId = _connectToSelectionGet(true, (SelectionData data, int info, int time) {
              var result = new WidgetSelectionGetEvent(data, info, time);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectionNotifyEvent(bool after, bool func(EventSelection event)) => signalConnect('selection-notify-event', func, after);
  Stream<WidgetSelectionNotifyEventEvent> get onSelectionNotifyEvent {
    int signalId;
    StreamController<WidgetSelectionNotifyEventEvent> controller;
    controller = new StreamController<WidgetSelectionNotifyEventEvent>(
      onListen: () {
          signalId = _connectToSelectionNotifyEvent(false, (EventSelection event) {
              var result = new WidgetSelectionNotifyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetSelectionNotifyEventEvent> get afterSelectionNotifyEvent {
    int signalId;
    StreamController<WidgetSelectionNotifyEventEvent> controller;
    controller = new StreamController<WidgetSelectionNotifyEventEvent>(
      onListen: () {
          signalId = _connectToSelectionNotifyEvent(true, (EventSelection event) {
              var result = new WidgetSelectionNotifyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectionReceived(bool after, void func(SelectionData data, int time)) => signalConnect('selection-received', func, after);
  Stream<WidgetSelectionReceivedEvent> get onSelectionReceived {
    int signalId;
    StreamController<WidgetSelectionReceivedEvent> controller;
    controller = new StreamController<WidgetSelectionReceivedEvent>(
      onListen: () {
          signalId = _connectToSelectionReceived(false, (SelectionData data, int time) {
              var result = new WidgetSelectionReceivedEvent(data, time);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetSelectionReceivedEvent> get afterSelectionReceived {
    int signalId;
    StreamController<WidgetSelectionReceivedEvent> controller;
    controller = new StreamController<WidgetSelectionReceivedEvent>(
      onListen: () {
          signalId = _connectToSelectionReceived(true, (SelectionData data, int time) {
              var result = new WidgetSelectionReceivedEvent(data, time);
              controller.add(result);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSelectionRequestEvent(bool after, bool func(EventSelection event)) => signalConnect('selection-request-event', func, after);
  Stream<WidgetSelectionRequestEventEvent> get onSelectionRequestEvent {
    int signalId;
    StreamController<WidgetSelectionRequestEventEvent> controller;
    controller = new StreamController<WidgetSelectionRequestEventEvent>(
      onListen: () {
          signalId = _connectToSelectionRequestEvent(false, (EventSelection event) {
              var result = new WidgetSelectionRequestEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetSelectionRequestEventEvent> get afterSelectionRequestEvent {
    int signalId;
    StreamController<WidgetSelectionRequestEventEvent> controller;
    controller = new StreamController<WidgetSelectionRequestEventEvent>(
      onListen: () {
          signalId = _connectToSelectionRequestEvent(true, (EventSelection event) {
              var result = new WidgetSelectionRequestEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToShow(bool after, void func()) => signalConnect('show', func, after);
  Stream get onShow {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToShow(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterShow {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToShow(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToShowHelp(bool after, bool func(WidgetHelpType helpType)) => signalConnect('show-help', func, after);
  Stream<WidgetShowHelpEvent> get onShowHelp {
    int signalId;
    StreamController<WidgetShowHelpEvent> controller;
    controller = new StreamController<WidgetShowHelpEvent>(
      onListen: () {
          signalId = _connectToShowHelp(false, (WidgetHelpType helpType) {
              var result = new WidgetShowHelpEvent(helpType);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetShowHelpEvent> get afterShowHelp {
    int signalId;
    StreamController<WidgetShowHelpEvent> controller;
    controller = new StreamController<WidgetShowHelpEvent>(
      onListen: () {
          signalId = _connectToShowHelp(true, (WidgetHelpType helpType) {
              var result = new WidgetShowHelpEvent(helpType);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSizeAllocate(bool after, void func(RectangleInt allocation)) => signalConnect('size-allocate', func, after);
  Stream<RectangleInt> get onSizeAllocate {
    int signalId;
    StreamController<RectangleInt> controller;
    controller = new StreamController<RectangleInt>(
      onListen: () {
          signalId = _connectToSizeAllocate(false, (RectangleInt allocation) {
              controller.add(allocation);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<RectangleInt> get afterSizeAllocate {
    int signalId;
    StreamController<RectangleInt> controller;
    controller = new StreamController<RectangleInt>(
      onListen: () {
          signalId = _connectToSizeAllocate(true, (RectangleInt allocation) {
              controller.add(allocation);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToStateChanged(bool after, void func(StateType state)) => signalConnect('state-changed', func, after);
  Stream<StateType> get onStateChanged {
    int signalId;
    StreamController<StateType> controller;
    controller = new StreamController<StateType>(
      onListen: () {
          signalId = _connectToStateChanged(false, (StateType state) {
              controller.add(state);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<StateType> get afterStateChanged {
    int signalId;
    StreamController<StateType> controller;
    controller = new StreamController<StateType>(
      onListen: () {
          signalId = _connectToStateChanged(true, (StateType state) {
              controller.add(state);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToStateFlagsChanged(bool after, void func(StateFlags flags)) => signalConnect('state-flags-changed', func, after);
  Stream<StateFlags> get onStateFlagsChanged {
    int signalId;
    StreamController<StateFlags> controller;
    controller = new StreamController<StateFlags>(
      onListen: () {
          signalId = _connectToStateFlagsChanged(false, (StateFlags flags) {
              controller.add(flags);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<StateFlags> get afterStateFlagsChanged {
    int signalId;
    StreamController<StateFlags> controller;
    controller = new StreamController<StateFlags>(
      onListen: () {
          signalId = _connectToStateFlagsChanged(true, (StateFlags flags) {
              controller.add(flags);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToStyleSet(bool after, void func(Style previousStyle)) => signalConnect('style-set', func, after);
  Stream<Style> get onStyleSet {
    int signalId;
    StreamController<Style> controller;
    controller = new StreamController<Style>(
      onListen: () {
          signalId = _connectToStyleSet(false, (Style previousStyle) {
              controller.add(previousStyle);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Style> get afterStyleSet {
    int signalId;
    StreamController<Style> controller;
    controller = new StreamController<Style>(
      onListen: () {
          signalId = _connectToStyleSet(true, (Style previousStyle) {
              controller.add(previousStyle);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToStyleUpdated(bool after, void func()) => signalConnect('style-updated', func, after);
  Stream get onStyleUpdated {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToStyleUpdated(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterStyleUpdated {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToStyleUpdated(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToTouchEvent(bool after, bool func(Event object)) => signalConnect('touch-event', func, after);
  Stream<WidgetTouchEventEvent> get onTouchEvent {
    int signalId;
    StreamController<WidgetTouchEventEvent> controller;
    controller = new StreamController<WidgetTouchEventEvent>(
      onListen: () {
          signalId = _connectToTouchEvent(false, (Event object) {
              var result = new WidgetTouchEventEvent(object);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetTouchEventEvent> get afterTouchEvent {
    int signalId;
    StreamController<WidgetTouchEventEvent> controller;
    controller = new StreamController<WidgetTouchEventEvent>(
      onListen: () {
          signalId = _connectToTouchEvent(true, (Event object) {
              var result = new WidgetTouchEventEvent(object);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToUnmap(bool after, void func()) => signalConnect('unmap', func, after);
  Stream get onUnmap {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUnmap(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterUnmap {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUnmap(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToUnmapEvent(bool after, bool func(EventAny event)) => signalConnect('unmap-event', func, after);
  Stream<WidgetUnmapEventEvent> get onUnmapEvent {
    int signalId;
    StreamController<WidgetUnmapEventEvent> controller;
    controller = new StreamController<WidgetUnmapEventEvent>(
      onListen: () {
          signalId = _connectToUnmapEvent(false, (EventAny event) {
              var result = new WidgetUnmapEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetUnmapEventEvent> get afterUnmapEvent {
    int signalId;
    StreamController<WidgetUnmapEventEvent> controller;
    controller = new StreamController<WidgetUnmapEventEvent>(
      onListen: () {
          signalId = _connectToUnmapEvent(true, (EventAny event) {
              var result = new WidgetUnmapEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToUnrealize(bool after, void func()) => signalConnect('unrealize', func, after);
  Stream get onUnrealize {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUnrealize(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterUnrealize {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToUnrealize(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToVisibilityNotifyEvent(bool after, bool func(EventVisibility event)) => signalConnect('visibility-notify-event', func, after);
  Stream<WidgetVisibilityNotifyEventEvent> get onVisibilityNotifyEvent {
    int signalId;
    StreamController<WidgetVisibilityNotifyEventEvent> controller;
    controller = new StreamController<WidgetVisibilityNotifyEventEvent>(
      onListen: () {
          signalId = _connectToVisibilityNotifyEvent(false, (EventVisibility event) {
              var result = new WidgetVisibilityNotifyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetVisibilityNotifyEventEvent> get afterVisibilityNotifyEvent {
    int signalId;
    StreamController<WidgetVisibilityNotifyEventEvent> controller;
    controller = new StreamController<WidgetVisibilityNotifyEventEvent>(
      onListen: () {
          signalId = _connectToVisibilityNotifyEvent(true, (EventVisibility event) {
              var result = new WidgetVisibilityNotifyEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToWindowStateEvent(bool after, bool func(EventWindowState event)) => signalConnect('window-state-event', func, after);
  Stream<WidgetWindowStateEventEvent> get onWindowStateEvent {
    int signalId;
    StreamController<WidgetWindowStateEventEvent> controller;
    controller = new StreamController<WidgetWindowStateEventEvent>(
      onListen: () {
          signalId = _connectToWindowStateEvent(false, (EventWindowState event) {
              var result = new WidgetWindowStateEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WidgetWindowStateEventEvent> get afterWindowStateEvent {
    int signalId;
    StreamController<WidgetWindowStateEventEvent> controller;
    controller = new StreamController<WidgetWindowStateEventEvent>(
      onListen: () {
          signalId = _connectToWindowStateEvent(true, (EventWindowState event) {
              var result = new WidgetWindowStateEventEvent(event);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class WidgetButtonPressEventEvent {
  final EventButton event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetButtonPressEventEvent(this.event);
}

class WidgetButtonReleaseEventEvent {
  final EventButton event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetButtonReleaseEventEvent(this.event);
}

class WidgetCanActivateAccelEvent {
  final int signalId;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetCanActivateAccelEvent(this.signalId);
}

class WidgetConfigureEventEvent {
  final EventConfigure event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetConfigureEventEvent(this.event);
}

class WidgetDamageEventEvent {
  final EventExpose event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetDamageEventEvent(this.event);
}

class WidgetDeleteEventEvent {
  final Event event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetDeleteEventEvent(this.event);
}

class WidgetDestroyEventEvent {
  final Event event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetDestroyEventEvent(this.event);
}

class WidgetDragDataGetEvent {
  final DragContext context;
  final SelectionData data;
  final int info;
  final int time;

  WidgetDragDataGetEvent(this.context, this.data, this.info, this.time);
}

class WidgetDragDataReceivedEvent {
  final DragContext context;
  final int x;
  final int y;
  final SelectionData data;
  final int info;
  final int time;

  WidgetDragDataReceivedEvent(this.context, this.x, this.y, this.data, this.info, this.time);
}

class WidgetDragDropEvent {
  final DragContext context;
  final int x;
  final int y;
  final int time;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetDragDropEvent(this.context, this.x, this.y, this.time);
}

class WidgetDragFailedEvent {
  final DragContext context;
  final DragResult result_;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetDragFailedEvent(this.context, this.result_);
}

class WidgetDragLeaveEvent {
  final DragContext context;
  final int time;

  WidgetDragLeaveEvent(this.context, this.time);
}

class WidgetDragMotionEvent {
  final DragContext context;
  final int x;
  final int y;
  final int time;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetDragMotionEvent(this.context, this.x, this.y, this.time);
}

class WidgetDrawEvent {
  final Context cr;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetDrawEvent(this.cr);
}

class WidgetEnterNotifyEventEvent {
  final EventCrossing event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetEnterNotifyEventEvent(this.event);
}

class WidgetEventEvent {
  final Event event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetEventEvent(this.event);
}

class WidgetFocusEvent {
  final DirectionType direction;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetFocusEvent(this.direction);
}

class WidgetFocusInEventEvent {
  final EventFocus event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetFocusInEventEvent(this.event);
}

class WidgetFocusOutEventEvent {
  final EventFocus event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetFocusOutEventEvent(this.event);
}

class WidgetGrabBrokenEventEvent {
  final EventGrabBroken event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetGrabBrokenEventEvent(this.event);
}

class WidgetKeyPressEventEvent {
  final EventKey event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetKeyPressEventEvent(this.event);
}

class WidgetKeyReleaseEventEvent {
  final EventKey event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetKeyReleaseEventEvent(this.event);
}

class WidgetKeynavFailedEvent {
  final DirectionType direction;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetKeynavFailedEvent(this.direction);
}

class WidgetLeaveNotifyEventEvent {
  final EventCrossing event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetLeaveNotifyEventEvent(this.event);
}

class WidgetMapEventEvent {
  final EventAny event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetMapEventEvent(this.event);
}

class WidgetMnemonicActivateEvent {
  final bool arg1;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetMnemonicActivateEvent(this.arg1);
}

class WidgetMotionNotifyEventEvent {
  final EventMotion event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetMotionNotifyEventEvent(this.event);
}

class WidgetPopupMenuEvent {
  
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetPopupMenuEvent();
}

class WidgetPropertyNotifyEventEvent {
  final EventProperty event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetPropertyNotifyEventEvent(this.event);
}

class WidgetProximityInEventEvent {
  final EventProximity event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetProximityInEventEvent(this.event);
}

class WidgetProximityOutEventEvent {
  final EventProximity event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetProximityOutEventEvent(this.event);
}

class WidgetQueryTooltipEvent {
  final int x;
  final int y;
  final bool keyboardMode;
  final Tooltip tooltip;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetQueryTooltipEvent(this.x, this.y, this.keyboardMode, this.tooltip);
}

class WidgetScrollEventEvent {
  final EventScroll event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetScrollEventEvent(this.event);
}

class WidgetSelectionClearEventEvent {
  final EventSelection event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetSelectionClearEventEvent(this.event);
}

class WidgetSelectionGetEvent {
  final SelectionData data;
  final int info;
  final int time;

  WidgetSelectionGetEvent(this.data, this.info, this.time);
}

class WidgetSelectionNotifyEventEvent {
  final EventSelection event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetSelectionNotifyEventEvent(this.event);
}

class WidgetSelectionReceivedEvent {
  final SelectionData data;
  final int time;

  WidgetSelectionReceivedEvent(this.data, this.time);
}

class WidgetSelectionRequestEventEvent {
  final EventSelection event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetSelectionRequestEventEvent(this.event);
}

class WidgetShowHelpEvent {
  final WidgetHelpType helpType;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetShowHelpEvent(this.helpType);
}

class WidgetTouchEventEvent {
  final Event object;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetTouchEventEvent(this.object);
}

class WidgetUnmapEventEvent {
  final EventAny event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetUnmapEventEvent(this.event);
}

class WidgetVisibilityNotifyEventEvent {
  final EventVisibility event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetVisibilityNotifyEventEvent(this.event);
}

class WidgetWindowStateEventEvent {
  final EventWindowState event;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WidgetWindowStateEventEvent(this.event);
}

class WidgetAccessible extends Accessible with Component {
  WidgetAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'WidgetAccessible');

}

class WidgetClassPrivate extends GObjectBase {
  WidgetClassPrivate.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'WidgetClassPrivate');

}

class WidgetHelpType extends GEnumBase {
  const WidgetHelpType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'WidgetHelpType');

  static const WidgetHelpType TOOLTIP = const WidgetHelpType(0);
  static const WidgetHelpType WHATS_THIS = const WidgetHelpType(1);
  String toString() {
    switch(index) {
      case 0: return 'WidgetHelpType.TOOLTIP';
      case 1: return 'WidgetHelpType.WHATS_THIS';
      default: return 'new WidgetHelpType($index)';
    }
  }
}

class WidgetPath extends GObjectBase {
  WidgetPath.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'WidgetPath');

  factory WidgetPath() => _staticInfo.callStatic('new', []);
  int appendForWidget(Widget widget) => _staticInfo.callMethodOnReceiver('append_for_widget', this, [widget]);
  int appendType(int type) => _staticInfo.callMethodOnReceiver('append_type', this, [type]);
  int appendWithSiblings(WidgetPath siblings, int siblingIndex) => _staticInfo.callMethodOnReceiver('append_with_siblings', this, [siblings, siblingIndex]);
  WidgetPath copy() => _staticInfo.callMethodOnReceiver('copy', this, []);
  void free() => _staticInfo.callMethodOnReceiver('free', this, []);
  int getObjectType() => _staticInfo.callMethodOnReceiver('get_object_type', this, []);
  bool hasParent(int type) => _staticInfo.callMethodOnReceiver('has_parent', this, [type]);
  bool isType(int type) => _staticInfo.callMethodOnReceiver('is_type', this, [type]);
  void iterAddClass(int pos, String name) => _staticInfo.callMethodOnReceiver('iter_add_class', this, [pos, name]);
  void iterAddQclass(int pos, int qname) => _staticInfo.callMethodOnReceiver('iter_add_qclass', this, [pos, qname]);
  void iterAddRegion(int pos, String name, RegionFlags flags) => _staticInfo.callMethodOnReceiver('iter_add_region', this, [pos, name, flags]);
  void iterClearClasses(int pos) => _staticInfo.callMethodOnReceiver('iter_clear_classes', this, [pos]);
  void iterClearRegions(int pos) => _staticInfo.callMethodOnReceiver('iter_clear_regions', this, [pos]);
  String iterGetName(int pos) => _staticInfo.callMethodOnReceiver('iter_get_name', this, [pos]);
  int iterGetObjectType(int pos) => _staticInfo.callMethodOnReceiver('iter_get_object_type', this, [pos]);
  int iterGetSiblingIndex(int pos) => _staticInfo.callMethodOnReceiver('iter_get_sibling_index', this, [pos]);
  WidgetPath iterGetSiblings(int pos) => _staticInfo.callMethodOnReceiver('iter_get_siblings', this, [pos]);
  StateFlags iterGetState(int pos) => _staticInfo.callMethodOnReceiver('iter_get_state', this, [pos]);
  bool iterHasClass(int pos, String name) => _staticInfo.callMethodOnReceiver('iter_has_class', this, [pos, name]);
  bool iterHasName(int pos, String name) => _staticInfo.callMethodOnReceiver('iter_has_name', this, [pos, name]);
  bool iterHasQclass(int pos, int qname) => _staticInfo.callMethodOnReceiver('iter_has_qclass', this, [pos, qname]);
  bool iterHasQname(int pos, int qname) => _staticInfo.callMethodOnReceiver('iter_has_qname', this, [pos, qname]);
  bool iterHasQregion(int pos, int qname) => _staticInfo.callMethodOnReceiver('iter_has_qregion', this, [pos, qname]);
  bool iterHasRegion(int pos, String name) => _staticInfo.callMethodOnReceiver('iter_has_region', this, [pos, name]);
  SList /* this will fail */ iterListClasses(int pos) => _staticInfo.callMethodOnReceiver('iter_list_classes', this, [pos]);
  SList /* this will fail */ iterListRegions(int pos) => _staticInfo.callMethodOnReceiver('iter_list_regions', this, [pos]);
  void iterRemoveClass(int pos, String name) => _staticInfo.callMethodOnReceiver('iter_remove_class', this, [pos, name]);
  void iterRemoveRegion(int pos, String name) => _staticInfo.callMethodOnReceiver('iter_remove_region', this, [pos, name]);
  void iterSetName(int pos, String name) => _staticInfo.callMethodOnReceiver('iter_set_name', this, [pos, name]);
  void iterSetObjectType(int pos, int type) => _staticInfo.callMethodOnReceiver('iter_set_object_type', this, [pos, type]);
  void iterSetState(int pos, StateFlags state) => _staticInfo.callMethodOnReceiver('iter_set_state', this, [pos, state]);
  int length() => _staticInfo.callMethodOnReceiver('length', this, []);
  void prependType(int type) => _staticInfo.callMethodOnReceiver('prepend_type', this, [type]);
  WidgetPath ref() => _staticInfo.callMethodOnReceiver('ref', this, []);
  String toString() => _staticInfo.callMethodOnReceiver('to_string', this, []);
  void unref() => _staticInfo.callMethodOnReceiver('unref', this, []);
}

class Window extends Bin with ImplementorIface, Buildable {
  Window.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'Window');

  static const String ACCEPT_FOCUS_PROPERTY = 'accept-focus';
  static const String APPLICATION_PROPERTY = 'application';
  static const String ATTACHED_TO_PROPERTY = 'attached-to';
  static const String DECORATED_PROPERTY = 'decorated';
  int get defaultHeight => _staticInfo.getGPropertyOnReceiver('default-height', this);
  void set defaultHeight(int value) => _staticInfo.setGPropertyOnReceiver('default-height', this, value);
  static const String DEFAULT_HEIGHT_PROPERTY = 'default-height';
  int get defaultWidth => _staticInfo.getGPropertyOnReceiver('default-width', this);
  void set defaultWidth(int value) => _staticInfo.setGPropertyOnReceiver('default-width', this, value);
  static const String DEFAULT_WIDTH_PROPERTY = 'default-width';
  static const String DELETABLE_PROPERTY = 'deletable';
  static const String DESTROY_WITH_PARENT_PROPERTY = 'destroy-with-parent';
  static const String FOCUS_ON_MAP_PROPERTY = 'focus-on-map';
  static const String FOCUS_VISIBLE_PROPERTY = 'focus-visible';
  static const String GRAVITY_PROPERTY = 'gravity';
  static const String HAS_RESIZE_GRIP_PROPERTY = 'has-resize-grip';
  bool get hasToplevelFocus => _staticInfo.getGPropertyOnReceiver('has-toplevel-focus', this);
  static const String HAS_TOPLEVEL_FOCUS_PROPERTY = 'has-toplevel-focus';
  static const String HIDE_TITLEBAR_WHEN_MAXIMIZED_PROPERTY = 'hide-titlebar-when-maximized';
  static const String ICON_PROPERTY = 'icon';
  static const String ICON_NAME_PROPERTY = 'icon-name';
  bool get isActive => _staticInfo.getGPropertyOnReceiver('is-active', this);
  static const String IS_ACTIVE_PROPERTY = 'is-active';
  bool get isMaximized => _staticInfo.getGPropertyOnReceiver('is-maximized', this);
  static const String IS_MAXIMIZED_PROPERTY = 'is-maximized';
  static const String MNEMONICS_VISIBLE_PROPERTY = 'mnemonics-visible';
  static const String MODAL_PROPERTY = 'modal';
  static const String RESIZABLE_PROPERTY = 'resizable';
  bool get resizeGripVisible => _staticInfo.getGPropertyOnReceiver('resize-grip-visible', this);
  static const String RESIZE_GRIP_VISIBLE_PROPERTY = 'resize-grip-visible';
  static const String ROLE_PROPERTY = 'role';
  static const String SCREEN_PROPERTY = 'screen';
  static const String SKIP_PAGER_HINT_PROPERTY = 'skip-pager-hint';
  static const String SKIP_TASKBAR_HINT_PROPERTY = 'skip-taskbar-hint';
  static const String STARTUP_ID_PROPERTY = 'startup-id';
  static const String TITLE_PROPERTY = 'title';
  static const String TRANSIENT_FOR_PROPERTY = 'transient-for';
  WindowType get type => _staticInfo.getGPropertyOnReceiver('type', this);
  void set type(WindowType value) => _staticInfo.setGPropertyOnReceiver('type', this, value);
  static const String TYPE_PROPERTY = 'type';
  static const String TYPE_HINT_PROPERTY = 'type-hint';
  static const String URGENCY_HINT_PROPERTY = 'urgency-hint';
  WindowPosition get windowPosition => _staticInfo.getGPropertyOnReceiver('window-position', this);
  void set windowPosition(WindowPosition value) => _staticInfo.setGPropertyOnReceiver('window-position', this, value);
  static const String WINDOW_POSITION_PROPERTY = 'window-position';
  factory Window(WindowType type) => _staticInfo.callStatic('new', [type]);
  static GLibList /* this will fail */ getDefaultIconList() => _staticInfo.callStatic('get_default_icon_list', []);
  static String getDefaultIconName() => _staticInfo.callStatic('get_default_icon_name', []);
  static GLibList /* this will fail */ listToplevels() => _staticInfo.callStatic('list_toplevels', []);
  static void setAutoStartupNotification(bool setting) => _staticInfo.callStatic('set_auto_startup_notification', [setting]);
  static void setDefaultIcon(Pixbuf icon) => _staticInfo.callStatic('set_default_icon', [icon]);
  static bool setDefaultIconFromFile(String filename) => _staticInfo.callStatic('set_default_icon_from_file', [filename]);
  static void setDefaultIconList(GLibList list /* this will fail */) => _staticInfo.callStatic('set_default_icon_list', [list]);
  static void setDefaultIconName(String name) => _staticInfo.callStatic('set_default_icon_name', [name]);
  static void setInteractiveDebugging(bool enable) => _staticInfo.callStatic('set_interactive_debugging', [enable]);
  bool activateDefault() => _staticInfo.callMethodOnReceiver('activate_default', this, []);
  bool activateFocus() => _staticInfo.callMethodOnReceiver('activate_focus', this, []);
  bool activateKey(EventKey event) => _staticInfo.callMethodOnReceiver('activate_key', this, [event]);
  void addAccelGroup(AccelGroup accelGroup) => _staticInfo.callMethodOnReceiver('add_accel_group', this, [accelGroup]);
  void addMnemonic(int keyval, Widget target) => _staticInfo.callMethodOnReceiver('add_mnemonic', this, [keyval, target]);
  void beginMoveDrag(int button, int rootX, int rootY, int timestamp) => _staticInfo.callMethodOnReceiver('begin_move_drag', this, [button, rootX, rootY, timestamp]);
  void beginResizeDrag(WindowEdge edge, int button, int rootX, int rootY, int timestamp) => _staticInfo.callMethodOnReceiver('begin_resize_drag', this, [edge, button, rootX, rootY, timestamp]);
  void close() => _staticInfo.callMethodOnReceiver('close', this, []);
  void deiconify() => _staticInfo.callMethodOnReceiver('deiconify', this, []);
  void fullscreen() => _staticInfo.callMethodOnReceiver('fullscreen', this, []);
  void fullscreenOnMonitor(Screen screen, int monitor) => _staticInfo.callMethodOnReceiver('fullscreen_on_monitor', this, [screen, monitor]);
  bool get acceptFocus => _staticInfo.callMethodOnReceiver('get_accept_focus', this, []);
  Application get application => _staticInfo.callMethodOnReceiver('get_application', this, []);
  Widget get attachedTo => _staticInfo.callMethodOnReceiver('get_attached_to', this, []);
  bool get decorated => _staticInfo.callMethodOnReceiver('get_decorated', this, []);
  void getDefaultSize() => _staticInfo.callMethodOnReceiver('get_default_size', this, []);
  Widget getDefaultWidget() => _staticInfo.callMethodOnReceiver('get_default_widget', this, []);
  bool get deletable => _staticInfo.callMethodOnReceiver('get_deletable', this, []);
  bool get destroyWithParent => _staticInfo.callMethodOnReceiver('get_destroy_with_parent', this, []);
  Widget getFocus() => _staticInfo.callMethodOnReceiver('get_focus', this, []);
  bool get focusOnMap => _staticInfo.callMethodOnReceiver('get_focus_on_map', this, []);
  bool get focusVisible => _staticInfo.callMethodOnReceiver('get_focus_visible', this, []);
  Gravity get gravity => _staticInfo.callMethodOnReceiver('get_gravity', this, []);
  WindowGroup getGroup() => _staticInfo.callMethodOnReceiver('get_group', this, []);
  bool get hasResizeGrip => _staticInfo.callMethodOnReceiver('get_has_resize_grip', this, []);
  bool get hideTitlebarWhenMaximized => _staticInfo.callMethodOnReceiver('get_hide_titlebar_when_maximized', this, []);
  Pixbuf get icon => _staticInfo.callMethodOnReceiver('get_icon', this, []);
  GLibList /* this will fail */ getIconList() => _staticInfo.callMethodOnReceiver('get_icon_list', this, []);
  String get iconName => _staticInfo.callMethodOnReceiver('get_icon_name', this, []);
  ModifierType getMnemonicModifier() => _staticInfo.callMethodOnReceiver('get_mnemonic_modifier', this, []);
  bool get mnemonicsVisible => _staticInfo.callMethodOnReceiver('get_mnemonics_visible', this, []);
  bool get modal => _staticInfo.callMethodOnReceiver('get_modal', this, []);
  num getOpacity() => _staticInfo.callMethodOnReceiver('get_opacity', this, []);
  void getPosition() => _staticInfo.callMethodOnReceiver('get_position', this, []);
  bool get resizable => _staticInfo.callMethodOnReceiver('get_resizable', this, []);
  bool getResizeGripArea() => _staticInfo.callMethodOnReceiver('get_resize_grip_area', this, []);
  String get role => _staticInfo.callMethodOnReceiver('get_role', this, []);
  Screen get screen => _staticInfo.callMethodOnReceiver('get_screen', this, []);
  void getSize() => _staticInfo.callMethodOnReceiver('get_size', this, []);
  bool get skipPagerHint => _staticInfo.callMethodOnReceiver('get_skip_pager_hint', this, []);
  bool get skipTaskbarHint => _staticInfo.callMethodOnReceiver('get_skip_taskbar_hint', this, []);
  String get title => _staticInfo.callMethodOnReceiver('get_title', this, []);
  Widget getTitlebar() => _staticInfo.callMethodOnReceiver('get_titlebar', this, []);
  Window get transientFor => _staticInfo.callMethodOnReceiver('get_transient_for', this, []);
  WindowTypeHint get typeHint => _staticInfo.callMethodOnReceiver('get_type_hint', this, []);
  bool get urgencyHint => _staticInfo.callMethodOnReceiver('get_urgency_hint', this, []);
  WindowType getWindowType() => _staticInfo.callMethodOnReceiver('get_window_type', this, []);
  bool hasGroup() => _staticInfo.callMethodOnReceiver('has_group', this, []);
  bool hasToplevelFocus_() => _staticInfo.callMethodOnReceiver('has_toplevel_focus', this, []);
  void iconify() => _staticInfo.callMethodOnReceiver('iconify', this, []);
  bool getIsActive() => _staticInfo.callMethodOnReceiver('is_active', this, []);
  bool getIsMaximized() => _staticInfo.callMethodOnReceiver('is_maximized', this, []);
  void maximize() => _staticInfo.callMethodOnReceiver('maximize', this, []);
  bool windowMnemonicActivate(int keyval, ModifierType modifier) => _staticInfo.callMethodOnReceiver('mnemonic_activate', this, [keyval, modifier]);
  void move(int x, int y) => _staticInfo.callMethodOnReceiver('move', this, [x, y]);
  bool parseGeometry(String geometry) => _staticInfo.callMethodOnReceiver('parse_geometry', this, [geometry]);
  void present() => _staticInfo.callMethodOnReceiver('present', this, []);
  void presentWithTime(int timestamp) => _staticInfo.callMethodOnReceiver('present_with_time', this, [timestamp]);
  bool propagateKeyEvent(EventKey event) => _staticInfo.callMethodOnReceiver('propagate_key_event', this, [event]);
  void removeAccelGroup(AccelGroup accelGroup) => _staticInfo.callMethodOnReceiver('remove_accel_group', this, [accelGroup]);
  void removeMnemonic(int keyval, Widget target) => _staticInfo.callMethodOnReceiver('remove_mnemonic', this, [keyval, target]);
  void reshowWithInitialSize() => _staticInfo.callMethodOnReceiver('reshow_with_initial_size', this, []);
  void resize(int width, int height) => _staticInfo.callMethodOnReceiver('resize', this, [width, height]);
  bool resizeGripIsVisible() => _staticInfo.callMethodOnReceiver('resize_grip_is_visible', this, []);
  void resizeToGeometry(int width, int height) => _staticInfo.callMethodOnReceiver('resize_to_geometry', this, [width, height]);
  void set acceptFocus(bool setting) => _staticInfo.callMethodOnReceiver('set_accept_focus', this, [setting]);
  void set application(Application application) => _staticInfo.callMethodOnReceiver('set_application', this, [application]);
  void set attachedTo(Widget attachWidget) => _staticInfo.callMethodOnReceiver('set_attached_to', this, [attachWidget]);
  void set decorated(bool setting) => _staticInfo.callMethodOnReceiver('set_decorated', this, [setting]);
  void setDefault(Widget defaultWidget) => _staticInfo.callMethodOnReceiver('set_default', this, [defaultWidget]);
  void setDefaultGeometry(int width, int height) => _staticInfo.callMethodOnReceiver('set_default_geometry', this, [width, height]);
  void setDefaultSize(int width, int height) => _staticInfo.callMethodOnReceiver('set_default_size', this, [width, height]);
  void set deletable(bool setting) => _staticInfo.callMethodOnReceiver('set_deletable', this, [setting]);
  void set destroyWithParent(bool setting) => _staticInfo.callMethodOnReceiver('set_destroy_with_parent', this, [setting]);
  void setFocus(Widget focus) => _staticInfo.callMethodOnReceiver('set_focus', this, [focus]);
  void set focusOnMap(bool setting) => _staticInfo.callMethodOnReceiver('set_focus_on_map', this, [setting]);
  void set focusVisible(bool setting) => _staticInfo.callMethodOnReceiver('set_focus_visible', this, [setting]);
  void setGeometryHints(Widget geometryWidget, Geometry geometry, WindowHints geomMask) => _staticInfo.callMethodOnReceiver('set_geometry_hints', this, [geometryWidget, geometry, geomMask]);
  void set gravity(Gravity gravity) => _staticInfo.callMethodOnReceiver('set_gravity', this, [gravity]);
  void set hasResizeGrip(bool value) => _staticInfo.callMethodOnReceiver('set_has_resize_grip', this, [value]);
  void setHasUserRefCount(bool setting) => _staticInfo.callMethodOnReceiver('set_has_user_ref_count', this, [setting]);
  void set hideTitlebarWhenMaximized(bool setting) => _staticInfo.callMethodOnReceiver('set_hide_titlebar_when_maximized', this, [setting]);
  void set icon(Pixbuf icon) => _staticInfo.callMethodOnReceiver('set_icon', this, [icon]);
  bool setIconFromFile(String filename) => _staticInfo.callMethodOnReceiver('set_icon_from_file', this, [filename]);
  void setIconList(GLibList list /* this will fail */) => _staticInfo.callMethodOnReceiver('set_icon_list', this, [list]);
  void set iconName(String name) => _staticInfo.callMethodOnReceiver('set_icon_name', this, [name]);
  void setKeepAbove(bool setting) => _staticInfo.callMethodOnReceiver('set_keep_above', this, [setting]);
  void setKeepBelow(bool setting) => _staticInfo.callMethodOnReceiver('set_keep_below', this, [setting]);
  void setMnemonicModifier(ModifierType modifier) => _staticInfo.callMethodOnReceiver('set_mnemonic_modifier', this, [modifier]);
  void set mnemonicsVisible(bool setting) => _staticInfo.callMethodOnReceiver('set_mnemonics_visible', this, [setting]);
  void set modal(bool modal) => _staticInfo.callMethodOnReceiver('set_modal', this, [modal]);
  void setOpacity(num opacity) => _staticInfo.callMethodOnReceiver('set_opacity', this, [opacity]);
  void setPosition(WindowPosition position) => _staticInfo.callMethodOnReceiver('set_position', this, [position]);
  void set resizable(bool resizable) => _staticInfo.callMethodOnReceiver('set_resizable', this, [resizable]);
  void set role(String role) => _staticInfo.callMethodOnReceiver('set_role', this, [role]);
  void set screen(Screen screen) => _staticInfo.callMethodOnReceiver('set_screen', this, [screen]);
  void set skipPagerHint(bool setting) => _staticInfo.callMethodOnReceiver('set_skip_pager_hint', this, [setting]);
  void set skipTaskbarHint(bool setting) => _staticInfo.callMethodOnReceiver('set_skip_taskbar_hint', this, [setting]);
  void set startupId(String startupId) => _staticInfo.callMethodOnReceiver('set_startup_id', this, [startupId]);
  void set title(String title) => _staticInfo.callMethodOnReceiver('set_title', this, [title]);
  void setTitlebar(Widget titlebar) => _staticInfo.callMethodOnReceiver('set_titlebar', this, [titlebar]);
  void set transientFor(Window parent) => _staticInfo.callMethodOnReceiver('set_transient_for', this, [parent]);
  void set typeHint(WindowTypeHint hint) => _staticInfo.callMethodOnReceiver('set_type_hint', this, [hint]);
  void set urgencyHint(bool setting) => _staticInfo.callMethodOnReceiver('set_urgency_hint', this, [setting]);
  void setWmclass(String wmclassName, String wmclassClass) => _staticInfo.callMethodOnReceiver('set_wmclass', this, [wmclassName, wmclassClass]);
  void stick() => _staticInfo.callMethodOnReceiver('stick', this, []);
  void unfullscreen() => _staticInfo.callMethodOnReceiver('unfullscreen', this, []);
  void unmaximize() => _staticInfo.callMethodOnReceiver('unmaximize', this, []);
  void unstick() => _staticInfo.callMethodOnReceiver('unstick', this, []);
  int _connectToActivateDefault(bool after, void func()) => signalConnect('activate-default', func, after);
  Stream get onActivateDefault {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivateDefault(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivateDefault {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivateDefault(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToActivateFocus(bool after, void func()) => signalConnect('activate-focus', func, after);
  Stream get onActivateFocus {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivateFocus(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterActivateFocus {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToActivateFocus(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToEnableDebugging(bool after, bool func(bool toggle)) => signalConnect('enable-debugging', func, after);
  Stream<WindowEnableDebuggingEvent> get onEnableDebugging {
    int signalId;
    StreamController<WindowEnableDebuggingEvent> controller;
    controller = new StreamController<WindowEnableDebuggingEvent>(
      onListen: () {
          signalId = _connectToEnableDebugging(false, (bool toggle) {
              var result = new WindowEnableDebuggingEvent(toggle);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<WindowEnableDebuggingEvent> get afterEnableDebugging {
    int signalId;
    StreamController<WindowEnableDebuggingEvent> controller;
    controller = new StreamController<WindowEnableDebuggingEvent>(
      onListen: () {
          signalId = _connectToEnableDebugging(true, (bool toggle) {
              var result = new WindowEnableDebuggingEvent(toggle);
              controller.add(result);
              return result._cancelPropagation;
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToKeysChanged(bool after, void func()) => signalConnect('keys-changed', func, after);
  Stream get onKeysChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToKeysChanged(false, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream get afterKeysChanged {
    int signalId;
    StreamController controller;
    controller = new StreamController(
      onListen: () {
          signalId = _connectToKeysChanged(true, () {
              controller.add(null);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  int _connectToSetFocus(bool after, void func(Widget object)) => signalConnect('set-focus', func, after);
  Stream<Widget> get onSetFocus {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToSetFocus(false, (Widget object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
  Stream<Widget> get afterSetFocus {
    int signalId;
    StreamController<Widget> controller;
    controller = new StreamController<Widget>(
      onListen: () {
          signalId = _connectToSetFocus(true, (Widget object) {
              controller.add(object);
          });
      },
      onCancel: () {
          signalDisconnect(signalId);
      },
      sync: true);
    return controller.stream;
  }
}

class WindowEnableDebuggingEvent {
  final bool toggle;
  bool _cancelPropagation = false;
  void cancelPropagation() {
    _cancelPropagation = true;
  }
  WindowEnableDebuggingEvent(this.toggle);
}

class WindowAccessible extends ContainerAccessible with Component, atk.Window {
  WindowAccessible.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'WindowAccessible');

}

class WindowGeometryInfo extends GObjectBase {
  WindowGeometryInfo.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'WindowGeometryInfo');

}

class WindowGroup extends GObjectObject {
  WindowGroup.fromNative() : super.fromNative();
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'WindowGroup');

  factory WindowGroup() => _staticInfo.callStatic('new', []);
  void addWindow(Window window) => _staticInfo.callMethodOnReceiver('add_window', this, [window]);
  Widget getCurrentDeviceGrab(Device device) => _staticInfo.callMethodOnReceiver('get_current_device_grab', this, [device]);
  Widget getCurrentGrab() => _staticInfo.callMethodOnReceiver('get_current_grab', this, []);
  GLibList /* this will fail */ listWindows() => _staticInfo.callMethodOnReceiver('list_windows', this, []);
  void removeWindow(Window window) => _staticInfo.callMethodOnReceiver('remove_window', this, [window]);
}

class WindowPosition extends GEnumBase {
  const WindowPosition(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'WindowPosition');

  static const WindowPosition NONE = const WindowPosition(0);
  static const WindowPosition CENTER = const WindowPosition(1);
  static const WindowPosition MOUSE = const WindowPosition(2);
  static const WindowPosition CENTER_ALWAYS = const WindowPosition(3);
  static const WindowPosition CENTER_ON_PARENT = const WindowPosition(4);
  String toString() {
    switch(index) {
      case 0: return 'WindowPosition.NONE';
      case 1: return 'WindowPosition.CENTER';
      case 2: return 'WindowPosition.MOUSE';
      case 3: return 'WindowPosition.CENTER_ALWAYS';
      case 4: return 'WindowPosition.CENTER_ON_PARENT';
      default: return 'new WindowPosition($index)';
    }
  }
}

class WindowType extends GEnumBase {
  const WindowType(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'WindowType');

  static const WindowType TOPLEVEL = const WindowType(0);
  static const WindowType POPUP = const WindowType(1);
  String toString() {
    switch(index) {
      case 0: return 'WindowType.TOPLEVEL';
      case 1: return 'WindowType.POPUP';
      default: return 'new WindowType($index)';
    }
  }
}

class WrapMode extends GEnumBase {
  const WrapMode(int value) : super(value);
  static final GIObjectInfo _staticInfo = new GIObjectInfo('Gtk', 'WrapMode');

  static const WrapMode NONE = const WrapMode(0);
  static const WrapMode CHAR = const WrapMode(1);
  static const WrapMode WORD = const WrapMode(2);
  static const WrapMode WORD_CHAR = const WrapMode(3);
  String toString() {
    switch(index) {
      case 0: return 'WrapMode.NONE';
      case 1: return 'WrapMode.CHAR';
      case 2: return 'WrapMode.WORD';
      case 3: return 'WrapMode.WORD_CHAR';
      default: return 'new WrapMode($index)';
    }
  }
}

bool accelGroupsActivate(GObjectObject object, int accelKey, ModifierType accelMods) => callStaticGlobal('Gtk', 'accel_groups_activate', [object, accelKey, accelMods]);

SList /* this will fail */ accelGroupsFromObject(GObjectObject object) => callStaticGlobal('Gtk', 'accel_groups_from_object', [object]);

ModifierType acceleratorGetDefaultModMask() => callStaticGlobal('Gtk', 'accelerator_get_default_mod_mask', []);

String acceleratorGetLabel(int acceleratorKey, ModifierType acceleratorMods) => callStaticGlobal('Gtk', 'accelerator_get_label', [acceleratorKey, acceleratorMods]);

String acceleratorGetLabelWithKeycode(Display display, int acceleratorKey, int keycode, ModifierType acceleratorMods) => callStaticGlobal('Gtk', 'accelerator_get_label_with_keycode', [display, acceleratorKey, keycode, acceleratorMods]);

String acceleratorName(int acceleratorKey, ModifierType acceleratorMods) => callStaticGlobal('Gtk', 'accelerator_name', [acceleratorKey, acceleratorMods]);

String acceleratorNameWithKeycode(Display display, int acceleratorKey, int keycode, ModifierType acceleratorMods) => callStaticGlobal('Gtk', 'accelerator_name_with_keycode', [display, acceleratorKey, keycode, acceleratorMods]);

List acceleratorParse(String accelerator) => callStaticGlobal('Gtk', 'accelerator_parse', [accelerator]);

List acceleratorParseWithKeycode(String accelerator) => callStaticGlobal('Gtk', 'accelerator_parse_with_keycode', [accelerator]);

void acceleratorSetDefaultModMask(ModifierType defaultModMask) => callStaticGlobal('Gtk', 'accelerator_set_default_mod_mask', [defaultModMask]);

bool acceleratorValid(int keyval, ModifierType modifiers) => callStaticGlobal('Gtk', 'accelerator_valid', [keyval, modifiers]);

bool alternativeDialogButtonOrder(Screen screen) => callStaticGlobal('Gtk', 'alternative_dialog_button_order', [screen]);

TokenType bindingEntryAddSignalFromString(BindingSet bindingSet, String signalDesc) => callStaticGlobal('Gtk', 'binding_entry_add_signal_from_string', [bindingSet, signalDesc]);

void bindingEntryAddSignall(BindingSet bindingSet, int keyval, ModifierType modifiers, String signalName, SList bindingArgs /* this will fail */) => callStaticGlobal('Gtk', 'binding_entry_add_signall', [bindingSet, keyval, modifiers, signalName, bindingArgs]);

void bindingEntryRemove(BindingSet bindingSet, int keyval, ModifierType modifiers) => callStaticGlobal('Gtk', 'binding_entry_remove', [bindingSet, keyval, modifiers]);

void bindingEntrySkip(BindingSet bindingSet, int keyval, ModifierType modifiers) => callStaticGlobal('Gtk', 'binding_entry_skip', [bindingSet, keyval, modifiers]);

BindingSet bindingSetFind(String setName) => callStaticGlobal('Gtk', 'binding_set_find', [setName]);

bool bindingsActivate(GObjectObject object, int keyval, ModifierType modifiers) => callStaticGlobal('Gtk', 'bindings_activate', [object, keyval, modifiers]);

bool bindingsActivateEvent(GObjectObject object, EventKey event) => callStaticGlobal('Gtk', 'bindings_activate_event', [object, event]);

int builderErrorQuark() => callStaticGlobal('Gtk', 'builder_error_quark', []);

bool cairoShouldDrawWindow(Context cr, gdk.Window window) => callStaticGlobal('Gtk', 'cairo_should_draw_window', [cr, window]);

void cairoTransformToWindow(Context cr, Widget widget, gdk.Window window) => callStaticGlobal('Gtk', 'cairo_transform_to_window', [cr, widget, window]);

String checkVersion(int requiredMajor, int requiredMinor, int requiredMicro) => callStaticGlobal('Gtk', 'check_version', [requiredMajor, requiredMinor, requiredMicro]);

int cssProviderErrorQuark() => callStaticGlobal('Gtk', 'css_provider_error_quark', []);

void deviceGrabAdd(Widget widget, Device device, bool blockOthers) => callStaticGlobal('Gtk', 'device_grab_add', [widget, device, blockOthers]);

void deviceGrabRemove(Widget widget, Device device) => callStaticGlobal('Gtk', 'device_grab_remove', [widget, device]);

void disableSetlocale() => callStaticGlobal('Gtk', 'disable_setlocale', []);

int distributeNaturalAllocation(int extraSpace, int nRequestedSizes, RequestedSize sizes) => callStaticGlobal('Gtk', 'distribute_natural_allocation', [extraSpace, nRequestedSizes, sizes]);

void dragCancel(DragContext context) => callStaticGlobal('Gtk', 'drag_cancel', [context]);

void dragFinish(DragContext context, bool success, bool del, int time_) => callStaticGlobal('Gtk', 'drag_finish', [context, success, del, time_]);

Widget dragGetSourceWidget(DragContext context) => callStaticGlobal('Gtk', 'drag_get_source_widget', [context]);

void dragSetIconDefault(DragContext context) => callStaticGlobal('Gtk', 'drag_set_icon_default', [context]);

void dragSetIconGicon(DragContext context, Icon icon, int hotX, int hotY) => callStaticGlobal('Gtk', 'drag_set_icon_gicon', [context, icon, hotX, hotY]);

void dragSetIconName(DragContext context, String iconName, int hotX, int hotY) => callStaticGlobal('Gtk', 'drag_set_icon_name', [context, iconName, hotX, hotY]);

void dragSetIconPixbuf(DragContext context, Pixbuf pixbuf, int hotX, int hotY) => callStaticGlobal('Gtk', 'drag_set_icon_pixbuf', [context, pixbuf, hotX, hotY]);

void dragSetIconStock(DragContext context, String stockId, int hotX, int hotY) => callStaticGlobal('Gtk', 'drag_set_icon_stock', [context, stockId, hotX, hotY]);

void dragSetIconSurface(DragContext context, Surface surface) => callStaticGlobal('Gtk', 'drag_set_icon_surface', [context, surface]);

void dragSetIconWidget(DragContext context, Widget widget, int hotX, int hotY) => callStaticGlobal('Gtk', 'drag_set_icon_widget', [context, widget, hotX, hotY]);

void drawInsertionCursor(Widget widget, Context cr, RectangleInt location, bool isPrimary, TextDirection direction, bool drawArrow) => callStaticGlobal('Gtk', 'draw_insertion_cursor', [widget, cr, location, isPrimary, direction, drawArrow]);

bool eventsPending() => callStaticGlobal('Gtk', 'events_pending', []);

bool false_() => callStaticGlobal('Gtk', 'false', []);

int fileChooserErrorQuark() => callStaticGlobal('Gtk', 'file_chooser_error_quark', []);

int getBinaryAge() => callStaticGlobal('Gtk', 'get_binary_age', []);

Event getCurrentEvent() => callStaticGlobal('Gtk', 'get_current_event', []);

Device getCurrentEventDevice() => callStaticGlobal('Gtk', 'get_current_event_device', []);

List getCurrentEventState() => callStaticGlobal('Gtk', 'get_current_event_state', []);

int getCurrentEventTime() => callStaticGlobal('Gtk', 'get_current_event_time', []);

int getDebugFlags() => callStaticGlobal('Gtk', 'get_debug_flags', []);

Language getDefaultLanguage() => callStaticGlobal('Gtk', 'get_default_language', []);

Widget getEventWidget(Event event) => callStaticGlobal('Gtk', 'get_event_widget', [event]);

int getInterfaceAge() => callStaticGlobal('Gtk', 'get_interface_age', []);

TextDirection getLocaleDirection() => callStaticGlobal('Gtk', 'get_locale_direction', []);

int getMajorVersion() => callStaticGlobal('Gtk', 'get_major_version', []);

int getMicroVersion() => callStaticGlobal('Gtk', 'get_micro_version', []);

int getMinorVersion() => callStaticGlobal('Gtk', 'get_minor_version', []);

OptionGroup getOptionGroup(bool openDefaultDisplay) => callStaticGlobal('Gtk', 'get_option_group', [openDefaultDisplay]);

Widget grabGetCurrent() => callStaticGlobal('Gtk', 'grab_get_current', []);

int iconSizeFromName(String name) => callStaticGlobal('Gtk', 'icon_size_from_name', [name]);

String iconSizeGetName(int size) => callStaticGlobal('Gtk', 'icon_size_get_name', [size]);

List iconSizeLookup(int size) => callStaticGlobal('Gtk', 'icon_size_lookup', [size]);

List iconSizeLookupForSettings(Settings settings, int size) => callStaticGlobal('Gtk', 'icon_size_lookup_for_settings', [settings, size]);

int iconSizeRegister(String name, int width, int height) => callStaticGlobal('Gtk', 'icon_size_register', [name, width, height]);

void iconSizeRegisterAlias(String alias, int target) => callStaticGlobal('Gtk', 'icon_size_register_alias', [alias, target]);

int iconThemeErrorQuark() => callStaticGlobal('Gtk', 'icon_theme_error_quark', []);

List init(List<String> argv) => callStaticGlobal('Gtk', 'init', [argv]);

List initCheck(List<String> argv) => callStaticGlobal('Gtk', 'init_check', [argv]);

List initWithArgs(List<String> argv, String parameterString, List<OptionEntry> entries, String translationDomain) => callStaticGlobal('Gtk', 'init_with_args', [argv, parameterString, entries, translationDomain]);

void keySnooperRemove(int snooperHandlerId) => callStaticGlobal('Gtk', 'key_snooper_remove', [snooperHandlerId]);

void main() => callStaticGlobal('Gtk', 'main', []);

void mainDoEvent(Event event) => callStaticGlobal('Gtk', 'main_do_event', [event]);

bool mainIteration() => callStaticGlobal('Gtk', 'main_iteration', []);

bool mainIterationDo(bool blocking) => callStaticGlobal('Gtk', 'main_iteration_do', [blocking]);

int mainLevel() => callStaticGlobal('Gtk', 'main_level', []);

void mainQuit() => callStaticGlobal('Gtk', 'main_quit', []);

void paintArrow(Style style, Context cr, StateType stateType, ShadowType shadowType, Widget widget, String detail, ArrowType arrowType, bool fill, int x, int y, int width, int height) => callStaticGlobal('Gtk', 'paint_arrow', [style, cr, stateType, shadowType, widget, detail, arrowType, fill, x, y, width, height]);

void paintBox(Style style, Context cr, StateType stateType, ShadowType shadowType, Widget widget, String detail, int x, int y, int width, int height) => callStaticGlobal('Gtk', 'paint_box', [style, cr, stateType, shadowType, widget, detail, x, y, width, height]);

void paintBoxGap(Style style, Context cr, StateType stateType, ShadowType shadowType, Widget widget, String detail, int x, int y, int width, int height, PositionType gapSide, int gapX, int gapWidth) => callStaticGlobal('Gtk', 'paint_box_gap', [style, cr, stateType, shadowType, widget, detail, x, y, width, height, gapSide, gapX, gapWidth]);

void paintCheck(Style style, Context cr, StateType stateType, ShadowType shadowType, Widget widget, String detail, int x, int y, int width, int height) => callStaticGlobal('Gtk', 'paint_check', [style, cr, stateType, shadowType, widget, detail, x, y, width, height]);

void paintDiamond(Style style, Context cr, StateType stateType, ShadowType shadowType, Widget widget, String detail, int x, int y, int width, int height) => callStaticGlobal('Gtk', 'paint_diamond', [style, cr, stateType, shadowType, widget, detail, x, y, width, height]);

void paintExpander(Style style, Context cr, StateType stateType, Widget widget, String detail, int x, int y, ExpanderStyle expanderStyle) => callStaticGlobal('Gtk', 'paint_expander', [style, cr, stateType, widget, detail, x, y, expanderStyle]);

void paintExtension(Style style, Context cr, StateType stateType, ShadowType shadowType, Widget widget, String detail, int x, int y, int width, int height, PositionType gapSide) => callStaticGlobal('Gtk', 'paint_extension', [style, cr, stateType, shadowType, widget, detail, x, y, width, height, gapSide]);

void paintFlatBox(Style style, Context cr, StateType stateType, ShadowType shadowType, Widget widget, String detail, int x, int y, int width, int height) => callStaticGlobal('Gtk', 'paint_flat_box', [style, cr, stateType, shadowType, widget, detail, x, y, width, height]);

void paintFocus(Style style, Context cr, StateType stateType, Widget widget, String detail, int x, int y, int width, int height) => callStaticGlobal('Gtk', 'paint_focus', [style, cr, stateType, widget, detail, x, y, width, height]);

void paintHandle(Style style, Context cr, StateType stateType, ShadowType shadowType, Widget widget, String detail, int x, int y, int width, int height, Orientation orientation) => callStaticGlobal('Gtk', 'paint_handle', [style, cr, stateType, shadowType, widget, detail, x, y, width, height, orientation]);

void paintHline(Style style, Context cr, StateType stateType, Widget widget, String detail, int x1, int x2, int y) => callStaticGlobal('Gtk', 'paint_hline', [style, cr, stateType, widget, detail, x1, x2, y]);

void paintLayout(Style style, Context cr, StateType stateType, bool useText, Widget widget, String detail, int x, int y, pango.Layout layout) => callStaticGlobal('Gtk', 'paint_layout', [style, cr, stateType, useText, widget, detail, x, y, layout]);

void paintOption(Style style, Context cr, StateType stateType, ShadowType shadowType, Widget widget, String detail, int x, int y, int width, int height) => callStaticGlobal('Gtk', 'paint_option', [style, cr, stateType, shadowType, widget, detail, x, y, width, height]);

void paintResizeGrip(Style style, Context cr, StateType stateType, Widget widget, String detail, WindowEdge edge, int x, int y, int width, int height) => callStaticGlobal('Gtk', 'paint_resize_grip', [style, cr, stateType, widget, detail, edge, x, y, width, height]);

void paintShadow(Style style, Context cr, StateType stateType, ShadowType shadowType, Widget widget, String detail, int x, int y, int width, int height) => callStaticGlobal('Gtk', 'paint_shadow', [style, cr, stateType, shadowType, widget, detail, x, y, width, height]);

void paintShadowGap(Style style, Context cr, StateType stateType, ShadowType shadowType, Widget widget, String detail, int x, int y, int width, int height, PositionType gapSide, int gapX, int gapWidth) => callStaticGlobal('Gtk', 'paint_shadow_gap', [style, cr, stateType, shadowType, widget, detail, x, y, width, height, gapSide, gapX, gapWidth]);

void paintSlider(Style style, Context cr, StateType stateType, ShadowType shadowType, Widget widget, String detail, int x, int y, int width, int height, Orientation orientation) => callStaticGlobal('Gtk', 'paint_slider', [style, cr, stateType, shadowType, widget, detail, x, y, width, height, orientation]);

void paintSpinner(Style style, Context cr, StateType stateType, Widget widget, String detail, int step, int x, int y, int width, int height) => callStaticGlobal('Gtk', 'paint_spinner', [style, cr, stateType, widget, detail, step, x, y, width, height]);

void paintTab(Style style, Context cr, StateType stateType, ShadowType shadowType, Widget widget, String detail, int x, int y, int width, int height) => callStaticGlobal('Gtk', 'paint_tab', [style, cr, stateType, shadowType, widget, detail, x, y, width, height]);

void paintVline(Style style, Context cr, StateType stateType, Widget widget, String detail, int y1_, int y2_, int x) => callStaticGlobal('Gtk', 'paint_vline', [style, cr, stateType, widget, detail, y1_, y2_, x]);

String paperSizeGetDefault() => callStaticGlobal('Gtk', 'paper_size_get_default', []);

GLibList /* this will fail */ paperSizeGetPaperSizes(bool includeCustom) => callStaticGlobal('Gtk', 'paper_size_get_paper_sizes', [includeCustom]);

List parseArgs(List<String> argv) => callStaticGlobal('Gtk', 'parse_args', [argv]);

int printErrorQuark() => callStaticGlobal('Gtk', 'print_error_quark', []);

PageSetup printRunPageSetupDialog(Window parent, PageSetup pageSetup, PrintSettings settings) => callStaticGlobal('Gtk', 'print_run_page_setup_dialog', [parent, pageSetup, settings]);

void printRunPageSetupDialogAsync(Window parent, PageSetup pageSetup, PrintSettings settings, PageSetupDoneFunc doneCb) => callStaticGlobal('Gtk', 'print_run_page_setup_dialog_async', [parent, pageSetup, settings, doneCb]);

void propagateEvent(Widget widget, Event event) => callStaticGlobal('Gtk', 'propagate_event', [widget, event]);

void rcAddDefaultFile(String filename) => callStaticGlobal('Gtk', 'rc_add_default_file', [filename]);

String rcFindModuleInPath(String moduleFile) => callStaticGlobal('Gtk', 'rc_find_module_in_path', [moduleFile]);

String rcFindPixmapInPath(Settings settings, Scanner scanner, String pixmapFile) => callStaticGlobal('Gtk', 'rc_find_pixmap_in_path', [settings, scanner, pixmapFile]);

List<String> rcGetDefaultFiles() => callStaticGlobal('Gtk', 'rc_get_default_files', []);

String rcGetImModuleFile() => callStaticGlobal('Gtk', 'rc_get_im_module_file', []);

String rcGetImModulePath() => callStaticGlobal('Gtk', 'rc_get_im_module_path', []);

String rcGetModuleDir() => callStaticGlobal('Gtk', 'rc_get_module_dir', []);

Style rcGetStyle(Widget widget) => callStaticGlobal('Gtk', 'rc_get_style', [widget]);

Style rcGetStyleByPaths(Settings settings, String widgetPath, String classPath, int type) => callStaticGlobal('Gtk', 'rc_get_style_by_paths', [settings, widgetPath, classPath, type]);

String rcGetThemeDir() => callStaticGlobal('Gtk', 'rc_get_theme_dir', []);

void rcParse(String filename) => callStaticGlobal('Gtk', 'rc_parse', [filename]);

List rcParseColor(Scanner scanner) => callStaticGlobal('Gtk', 'rc_parse_color', [scanner]);

List rcParseColorFull(Scanner scanner, RcStyle style) => callStaticGlobal('Gtk', 'rc_parse_color_full', [scanner, style]);

int rcParsePriority(Scanner scanner, PathPriorityType priority) => callStaticGlobal('Gtk', 'rc_parse_priority', [scanner, priority]);

List rcParseState(Scanner scanner) => callStaticGlobal('Gtk', 'rc_parse_state', [scanner]);

void rcParseString(String rcString) => callStaticGlobal('Gtk', 'rc_parse_string', [rcString]);

bool rcPropertyParseBorder(ParamSpec pspec, GLibString gstring, Value propertyValue) => callStaticGlobal('Gtk', 'rc_property_parse_border', [pspec, gstring, propertyValue]);

bool rcPropertyParseColor(ParamSpec pspec, GLibString gstring, Value propertyValue) => callStaticGlobal('Gtk', 'rc_property_parse_color', [pspec, gstring, propertyValue]);

bool rcPropertyParseEnum(ParamSpec pspec, GLibString gstring, Value propertyValue) => callStaticGlobal('Gtk', 'rc_property_parse_enum', [pspec, gstring, propertyValue]);

bool rcPropertyParseFlags(ParamSpec pspec, GLibString gstring, Value propertyValue) => callStaticGlobal('Gtk', 'rc_property_parse_flags', [pspec, gstring, propertyValue]);

bool rcPropertyParseRequisition(ParamSpec pspec, GLibString gstring, Value propertyValue) => callStaticGlobal('Gtk', 'rc_property_parse_requisition', [pspec, gstring, propertyValue]);

bool rcReparseAll() => callStaticGlobal('Gtk', 'rc_reparse_all', []);

bool rcReparseAllForSettings(Settings settings, bool forceLoad) => callStaticGlobal('Gtk', 'rc_reparse_all_for_settings', [settings, forceLoad]);

void rcResetStyles(Settings settings) => callStaticGlobal('Gtk', 'rc_reset_styles', [settings]);

void rcSetDefaultFiles(List<String> filenames) => callStaticGlobal('Gtk', 'rc_set_default_files', [filenames]);

int recentChooserErrorQuark() => callStaticGlobal('Gtk', 'recent_chooser_error_quark', []);

int recentManagerErrorQuark() => callStaticGlobal('Gtk', 'recent_manager_error_quark', []);

void renderActivity(StyleContext context, Context cr, num x, num y, num width, num height) => callStaticGlobal('Gtk', 'render_activity', [context, cr, x, y, width, height]);

void renderArrow(StyleContext context, Context cr, num angle, num x, num y, num size) => callStaticGlobal('Gtk', 'render_arrow', [context, cr, angle, x, y, size]);

void renderBackground(StyleContext context, Context cr, num x, num y, num width, num height) => callStaticGlobal('Gtk', 'render_background', [context, cr, x, y, width, height]);

void renderCheck(StyleContext context, Context cr, num x, num y, num width, num height) => callStaticGlobal('Gtk', 'render_check', [context, cr, x, y, width, height]);

void renderExpander(StyleContext context, Context cr, num x, num y, num width, num height) => callStaticGlobal('Gtk', 'render_expander', [context, cr, x, y, width, height]);

void renderExtension(StyleContext context, Context cr, num x, num y, num width, num height, PositionType gapSide) => callStaticGlobal('Gtk', 'render_extension', [context, cr, x, y, width, height, gapSide]);

void renderFocus(StyleContext context, Context cr, num x, num y, num width, num height) => callStaticGlobal('Gtk', 'render_focus', [context, cr, x, y, width, height]);

void renderFrame(StyleContext context, Context cr, num x, num y, num width, num height) => callStaticGlobal('Gtk', 'render_frame', [context, cr, x, y, width, height]);

void renderFrameGap(StyleContext context, Context cr, num x, num y, num width, num height, PositionType gapSide, num xy0Gap, num xy1Gap) => callStaticGlobal('Gtk', 'render_frame_gap', [context, cr, x, y, width, height, gapSide, xy0Gap, xy1Gap]);

void renderHandle(StyleContext context, Context cr, num x, num y, num width, num height) => callStaticGlobal('Gtk', 'render_handle', [context, cr, x, y, width, height]);

void renderIcon(StyleContext context, Context cr, Pixbuf pixbuf, num x, num y) => callStaticGlobal('Gtk', 'render_icon', [context, cr, pixbuf, x, y]);

Pixbuf renderIconPixbuf(StyleContext context, IconSource source, int size) => callStaticGlobal('Gtk', 'render_icon_pixbuf', [context, source, size]);

void renderIconSurface(StyleContext context, Context cr, Surface surface, num x, num y) => callStaticGlobal('Gtk', 'render_icon_surface', [context, cr, surface, x, y]);

void renderInsertionCursor(StyleContext context, Context cr, num x, num y, pango.Layout layout, int index, Direction direction) => callStaticGlobal('Gtk', 'render_insertion_cursor', [context, cr, x, y, layout, index, direction]);

void renderLayout(StyleContext context, Context cr, num x, num y, pango.Layout layout) => callStaticGlobal('Gtk', 'render_layout', [context, cr, x, y, layout]);

void renderLine(StyleContext context, Context cr, num x0, num y0, num x1, num y1) => callStaticGlobal('Gtk', 'render_line', [context, cr, x0, y0, x1, y1]);

void renderOption(StyleContext context, Context cr, num x, num y, num width, num height) => callStaticGlobal('Gtk', 'render_option', [context, cr, x, y, width, height]);

void renderSlider(StyleContext context, Context cr, num x, num y, num width, num height, Orientation orientation) => callStaticGlobal('Gtk', 'render_slider', [context, cr, x, y, width, height, orientation]);

List rgbToHsv(num r, num g, num b) => callStaticGlobal('Gtk', 'rgb_to_hsv', [r, g, b]);

void selectionAddTarget(Widget widget, Atom selection, Atom target, int info) => callStaticGlobal('Gtk', 'selection_add_target', [widget, selection, target, info]);

void selectionAddTargets(Widget widget, Atom selection, List<TargetEntry> targets) => callStaticGlobal('Gtk', 'selection_add_targets', [widget, selection, targets]);

void selectionClearTargets(Widget widget, Atom selection) => callStaticGlobal('Gtk', 'selection_clear_targets', [widget, selection]);

bool selectionConvert(Widget widget, Atom selection, Atom target, int time_) => callStaticGlobal('Gtk', 'selection_convert', [widget, selection, target, time_]);

bool selectionOwnerSet(Widget widget, Atom selection, int time_) => callStaticGlobal('Gtk', 'selection_owner_set', [widget, selection, time_]);

bool selectionOwnerSetForDisplay(Display display, Widget widget, Atom selection, int time_) => callStaticGlobal('Gtk', 'selection_owner_set_for_display', [display, widget, selection, time_]);

void selectionRemoveAll(Widget widget) => callStaticGlobal('Gtk', 'selection_remove_all', [widget]);

void setDebugFlags(int flags) => callStaticGlobal('Gtk', 'set_debug_flags', [flags]);

void showUri(Screen screen, String uri, int timestamp) => callStaticGlobal('Gtk', 'show_uri', [screen, uri, timestamp]);

void stockAdd(List<StockItem> items) => callStaticGlobal('Gtk', 'stock_add', [items]);

void stockAddStatic(List<StockItem> items) => callStaticGlobal('Gtk', 'stock_add_static', [items]);

SList /* this will fail */ stockListIds() => callStaticGlobal('Gtk', 'stock_list_ids', []);

List stockLookup(String stockId) => callStaticGlobal('Gtk', 'stock_lookup', [stockId]);

void stockSetTranslateFunc(String domain, TranslateFunc func) => callStaticGlobal('Gtk', 'stock_set_translate_func', [domain, func]);

void targetTableFree(List<TargetEntry> targets) => callStaticGlobal('Gtk', 'target_table_free', [targets]);

List targetTableNewFromList(TargetList list) => callStaticGlobal('Gtk', 'target_table_new_from_list', [list]);

bool targetsIncludeImage(List<Atom> targets, bool writable) => callStaticGlobal('Gtk', 'targets_include_image', [targets, writable]);

bool targetsIncludeRichText(List<Atom> targets, TextBuffer buffer) => callStaticGlobal('Gtk', 'targets_include_rich_text', [targets, buffer]);

bool targetsIncludeText(List<Atom> targets) => callStaticGlobal('Gtk', 'targets_include_text', [targets]);

bool targetsIncludeUri(List<Atom> targets) => callStaticGlobal('Gtk', 'targets_include_uri', [targets]);

Widget testCreateSimpleWindow(String windowTitle, String dialogText) => callStaticGlobal('Gtk', 'test_create_simple_window', [windowTitle, dialogText]);

Widget testFindLabel(Widget widget, String labelCairoPattern) => callStaticGlobal('Gtk', 'test_find_label', [widget, labelCairoPattern]);

Widget testFindSibling(Widget baseWidget, int widgetType) => callStaticGlobal('Gtk', 'test_find_sibling', [baseWidget, widgetType]);

Widget testFindWidget(Widget widget, String labelCairoPattern, int widgetType) => callStaticGlobal('Gtk', 'test_find_widget', [widget, labelCairoPattern, widgetType]);

List testListAllTypes() => callStaticGlobal('Gtk', 'test_list_all_types', []);

void testRegisterAllTypes() => callStaticGlobal('Gtk', 'test_register_all_types', []);

num testSliderGetValue(Widget widget) => callStaticGlobal('Gtk', 'test_slider_get_value', [widget]);

void testSliderSetPerc(Widget widget, num percentage) => callStaticGlobal('Gtk', 'test_slider_set_perc', [widget, percentage]);

bool testSpinButtonClick(SpinButton spinner, int button, bool upwards) => callStaticGlobal('Gtk', 'test_spin_button_click', [spinner, button, upwards]);

String testTextGet(Widget widget) => callStaticGlobal('Gtk', 'test_text_get', [widget]);

void testTextSet(Widget widget, String string) => callStaticGlobal('Gtk', 'test_text_set', [widget, string]);

bool testWidgetClick(Widget widget, int button, ModifierType modifiers) => callStaticGlobal('Gtk', 'test_widget_click', [widget, button, modifiers]);

bool testWidgetSendKey(Widget widget, int keyval, ModifierType modifiers) => callStaticGlobal('Gtk', 'test_widget_send_key', [widget, keyval, modifiers]);

void testWidgetWaitForDraw(Widget widget) => callStaticGlobal('Gtk', 'test_widget_wait_for_draw', [widget]);

List treeGetRowDragData(SelectionData selectionData) => callStaticGlobal('Gtk', 'tree_get_row_drag_data', [selectionData]);

void treeRowReferenceDeleted(GObjectObject proxy, TreePath path) => callStaticGlobal('Gtk', 'tree_row_reference_deleted', [proxy, path]);

void treeRowReferenceInserted(GObjectObject proxy, TreePath path) => callStaticGlobal('Gtk', 'tree_row_reference_inserted', [proxy, path]);

bool treeSetRowDragData(SelectionData selectionData, TreeModel treeModel, TreePath path) => callStaticGlobal('Gtk', 'tree_set_row_drag_data', [selectionData, treeModel, path]);

bool true_() => callStaticGlobal('Gtk', 'true', []);

bool _initLibraryStarted = false;

void initLibrary() {
  if (_initLibraryStarted) return;
  _initLibraryStarted = true;
  xlib.initLibrary();
  gdk.initLibrary();
  atk.initLibrary();
  registerInterceptorTypeForNamedType("Gtk", "AboutDialog",AboutDialog);
  registerInterceptorTypeForNamedType("Gtk", "AccelFlags",AccelFlags);
  registerInterceptorTypeForNamedType("Gtk", "AccelGroup",AccelGroup);
  registerInterceptorTypeForNamedType("Gtk", "AccelGroupEntry",AccelGroupEntry);
  registerInterceptorTypeForNamedType("Gtk", "AccelKey",AccelKey);
  registerInterceptorTypeForNamedType("Gtk", "AccelLabel",AccelLabel);
  registerInterceptorTypeForNamedType("Gtk", "AccelMap",AccelMap);
  registerInterceptorTypeForNamedType("Gtk", "Accessible",Accessible);
  registerInterceptorTypeForNamedType("Gtk", "Action",Action);
  registerInterceptorTypeForNamedType("Gtk", "ActionBar",ActionBar);
  registerInterceptorTypeForNamedType("Gtk", "ActionBarPrivate",ActionBarPrivate);
  registerInterceptorTypeForNamedType("Gtk", "ActionEntry",ActionEntry);
  registerInterceptorTypeForNamedType("Gtk", "ActionGroup",ActionGroup);
  registerInterceptorTypeForNamedType("Gtk", "Adjustment",Adjustment);
  registerInterceptorTypeForNamedType("Gtk", "Align",Align);
  registerInterceptorTypeForNamedType("Gtk", "Alignment",Alignment);
  registerInterceptorTypeForNamedType("Gtk", "AppChooserButton",AppChooserButton);
  registerInterceptorTypeForNamedType("Gtk", "AppChooserDialog",AppChooserDialog);
  registerInterceptorTypeForNamedType("Gtk", "AppChooserWidget",AppChooserWidget);
  registerInterceptorTypeForNamedType("Gtk", "Application",Application);
  registerInterceptorTypeForNamedType("Gtk", "ApplicationInhibitFlags",ApplicationInhibitFlags);
  registerInterceptorTypeForNamedType("Gtk", "ApplicationWindow",ApplicationWindow);
  registerInterceptorTypeForNamedType("Gtk", "Arrow",Arrow);
  registerInterceptorTypeForNamedType("Gtk", "ArrowAccessible",ArrowAccessible);
  registerInterceptorTypeForNamedType("Gtk", "ArrowPlacement",ArrowPlacement);
  registerInterceptorTypeForNamedType("Gtk", "ArrowType",ArrowType);
  registerInterceptorTypeForNamedType("Gtk", "AspectFrame",AspectFrame);
  registerInterceptorTypeForNamedType("Gtk", "Assistant",Assistant);
  registerInterceptorTypeForNamedType("Gtk", "AssistantPageType",AssistantPageType);
  registerInterceptorTypeForNamedType("Gtk", "AttachOptions",AttachOptions);
  registerInterceptorTypeForNamedType("Gtk", "BaselinePosition",BaselinePosition);
  registerInterceptorTypeForNamedType("Gtk", "Bin",Bin);
  registerInterceptorTypeForNamedType("Gtk", "BindingArg",BindingArg);
  registerInterceptorTypeForNamedType("Gtk", "BindingEntry",BindingEntry);
  registerInterceptorTypeForNamedType("Gtk", "BindingSet",BindingSet);
  registerInterceptorTypeForNamedType("Gtk", "BindingSignal",BindingSignal);
  registerInterceptorTypeForNamedType("Gtk", "BooleanCellAccessible",BooleanCellAccessible);
  registerInterceptorTypeForNamedType("Gtk", "Border",Border);
  registerInterceptorTypeForNamedType("Gtk", "BorderStyle",BorderStyle);
  registerInterceptorTypeForNamedType("Gtk", "Box",Box);
  registerInterceptorTypeForNamedType("Gtk", "Builder",Builder);
  registerInterceptorTypeForNamedType("Gtk", "BuilderError",BuilderErrorCode);
  registerInterceptorTypeForNamedType("Gtk", "Button",Button);
  registerInterceptorTypeForNamedType("Gtk", "ButtonAccessible",ButtonAccessible);
  registerInterceptorTypeForNamedType("Gtk", "ButtonBox",ButtonBox);
  registerInterceptorTypeForNamedType("Gtk", "ButtonBoxStyle",ButtonBoxStyle);
  registerInterceptorTypeForNamedType("Gtk", "ButtonRole",ButtonRole);
  registerInterceptorTypeForNamedType("Gtk", "ButtonsType",ButtonsType);
  registerInterceptorTypeForNamedType("Gtk", "Calendar",Calendar);
  registerInterceptorTypeForNamedType("Gtk", "CalendarDisplayOptions",CalendarDisplayOptions);
  registerInterceptorTypeForNamedType("Gtk", "CellAccessible",CellAccessible);
  registerInterceptorTypeForNamedType("Gtk", "CellArea",CellArea);
  registerInterceptorTypeForNamedType("Gtk", "CellAreaBox",CellAreaBox);
  registerInterceptorTypeForNamedType("Gtk", "CellAreaContext",CellAreaContext);
  registerInterceptorTypeForNamedType("Gtk", "CellRenderer",CellRenderer);
  registerInterceptorTypeForNamedType("Gtk", "CellRendererAccel",CellRendererAccel);
  registerInterceptorTypeForNamedType("Gtk", "CellRendererAccelMode",CellRendererAccelMode);
  registerInterceptorTypeForNamedType("Gtk", "CellRendererClassPrivate",CellRendererClassPrivate);
  registerInterceptorTypeForNamedType("Gtk", "CellRendererCombo",CellRendererCombo);
  registerInterceptorTypeForNamedType("Gtk", "CellRendererMode",CellRendererMode);
  registerInterceptorTypeForNamedType("Gtk", "CellRendererPixbuf",CellRendererPixbuf);
  registerInterceptorTypeForNamedType("Gtk", "CellRendererProgress",CellRendererProgress);
  registerInterceptorTypeForNamedType("Gtk", "CellRendererSpin",CellRendererSpin);
  registerInterceptorTypeForNamedType("Gtk", "CellRendererSpinner",CellRendererSpinner);
  registerInterceptorTypeForNamedType("Gtk", "CellRendererState",CellRendererState);
  registerInterceptorTypeForNamedType("Gtk", "CellRendererText",CellRendererText);
  registerInterceptorTypeForNamedType("Gtk", "CellRendererToggle",CellRendererToggle);
  registerInterceptorTypeForNamedType("Gtk", "CellView",CellView);
  registerInterceptorTypeForNamedType("Gtk", "CheckButton",CheckButton);
  registerInterceptorTypeForNamedType("Gtk", "CheckMenuItem",CheckMenuItem);
  registerInterceptorTypeForNamedType("Gtk", "CheckMenuItemAccessible",CheckMenuItemAccessible);
  registerInterceptorTypeForNamedType("Gtk", "Clipboard",Clipboard);
  registerInterceptorTypeForNamedType("Gtk", "ColorButton",ColorButton);
  registerInterceptorTypeForNamedType("Gtk", "ColorChooserDialog",ColorChooserDialog);
  registerInterceptorTypeForNamedType("Gtk", "ColorChooserWidget",ColorChooserWidget);
  registerInterceptorTypeForNamedType("Gtk", "ColorSelection",ColorSelection);
  registerInterceptorTypeForNamedType("Gtk", "ColorSelectionDialog",ColorSelectionDialog);
  registerInterceptorTypeForNamedType("Gtk", "ComboBox",ComboBox);
  registerInterceptorTypeForNamedType("Gtk", "ComboBoxAccessible",ComboBoxAccessible);
  registerInterceptorTypeForNamedType("Gtk", "ComboBoxText",ComboBoxText);
  registerInterceptorTypeForNamedType("Gtk", "Container",Container);
  registerInterceptorTypeForNamedType("Gtk", "ContainerAccessible",ContainerAccessible);
  registerInterceptorTypeForNamedType("Gtk", "ContainerCellAccessible",ContainerCellAccessible);
  registerInterceptorTypeForNamedType("Gtk", "CornerType",CornerType);
  registerInterceptorTypeForNamedType("Gtk", "CssProvider",CssProvider);
  registerInterceptorTypeForNamedType("Gtk", "CssProviderError",CssProviderErrorCode);
  registerInterceptorTypeForNamedType("Gtk", "CssSection",CssSection);
  registerInterceptorTypeForNamedType("Gtk", "CssSectionType",CssSectionType);
  registerInterceptorTypeForNamedType("Gtk", "DebugFlag",DebugFlag);
  registerInterceptorTypeForNamedType("Gtk", "DeleteType",DeleteType);
  registerInterceptorTypeForNamedType("Gtk", "DestDefaults",DestDefaults);
  registerInterceptorTypeForNamedType("Gtk", "Dialog",Dialog);
  registerInterceptorTypeForNamedType("Gtk", "DialogFlags",DialogFlags);
  registerInterceptorTypeForNamedType("Gtk", "DirectionType",DirectionType);
  registerInterceptorTypeForNamedType("Gtk", "DragResult",DragResult);
  registerInterceptorTypeForNamedType("Gtk", "DrawingArea",DrawingArea);
  registerInterceptorTypeForNamedType("Gtk", "Entry",Entry);
  registerInterceptorTypeForNamedType("Gtk", "EntryAccessible",EntryAccessible);
  registerInterceptorTypeForNamedType("Gtk", "EntryBuffer",EntryBuffer);
  registerInterceptorTypeForNamedType("Gtk", "EntryCompletion",EntryCompletion);
  registerInterceptorTypeForNamedType("Gtk", "EntryIconAccessible",EntryIconAccessible);
  registerInterceptorTypeForNamedType("Gtk", "EntryIconPosition",EntryIconPosition);
  registerInterceptorTypeForNamedType("Gtk", "EventBox",EventBox);
  registerInterceptorTypeForNamedType("Gtk", "EventController",EventController);
  registerInterceptorTypeForNamedType("Gtk", "EventSequenceState",EventSequenceState);
  registerInterceptorTypeForNamedType("Gtk", "Expander",Expander);
  registerInterceptorTypeForNamedType("Gtk", "ExpanderAccessible",ExpanderAccessible);
  registerInterceptorTypeForNamedType("Gtk", "ExpanderStyle",ExpanderStyle);
  registerInterceptorTypeForNamedType("Gtk", "FileChooserAction",FileChooserAction);
  registerInterceptorTypeForNamedType("Gtk", "FileChooserButton",FileChooserButton);
  registerInterceptorTypeForNamedType("Gtk", "FileChooserConfirmation",FileChooserConfirmation);
  registerInterceptorTypeForNamedType("Gtk", "FileChooserDialog",FileChooserDialog);
  registerInterceptorTypeForNamedType("Gtk", "FileChooserError",FileChooserErrorCode);
  registerInterceptorTypeForNamedType("Gtk", "FileChooserWidget",FileChooserWidget);
  registerInterceptorTypeForNamedType("Gtk", "FileFilter",FileFilter);
  registerInterceptorTypeForNamedType("Gtk", "FileFilterFlags",FileFilterFlags);
  registerInterceptorTypeForNamedType("Gtk", "FileFilterInfo",FileFilterInfo);
  registerInterceptorTypeForNamedType("Gtk", "Fixed",Fixed);
  registerInterceptorTypeForNamedType("Gtk", "FixedChild",FixedChild);
  registerInterceptorTypeForNamedType("Gtk", "FlowBox",FlowBox);
  registerInterceptorTypeForNamedType("Gtk", "FlowBoxAccessible",FlowBoxAccessible);
  registerInterceptorTypeForNamedType("Gtk", "FlowBoxChild",FlowBoxChild);
  registerInterceptorTypeForNamedType("Gtk", "FlowBoxChildAccessible",FlowBoxChildAccessible);
  registerInterceptorTypeForNamedType("Gtk", "FontButton",FontButton);
  registerInterceptorTypeForNamedType("Gtk", "FontChooserDialog",FontChooserDialog);
  registerInterceptorTypeForNamedType("Gtk", "FontChooserWidget",FontChooserWidget);
  registerInterceptorTypeForNamedType("Gtk", "FontSelection",FontSelection);
  registerInterceptorTypeForNamedType("Gtk", "FontSelectionDialog",FontSelectionDialog);
  registerInterceptorTypeForNamedType("Gtk", "Frame",Frame);
  registerInterceptorTypeForNamedType("Gtk", "FrameAccessible",FrameAccessible);
  registerInterceptorTypeForNamedType("Gtk", "GLArea",GLArea);
  registerInterceptorTypeForNamedType("Gtk", "Gesture",Gesture);
  registerInterceptorTypeForNamedType("Gtk", "GestureDrag",GestureDrag);
  registerInterceptorTypeForNamedType("Gtk", "GestureLongPress",GestureLongPress);
  registerInterceptorTypeForNamedType("Gtk", "GestureMultiPress",GestureMultiPress);
  registerInterceptorTypeForNamedType("Gtk", "GesturePan",GesturePan);
  registerInterceptorTypeForNamedType("Gtk", "GestureRotate",GestureRotate);
  registerInterceptorTypeForNamedType("Gtk", "GestureSingle",GestureSingle);
  registerInterceptorTypeForNamedType("Gtk", "GestureSwipe",GestureSwipe);
  registerInterceptorTypeForNamedType("Gtk", "GestureZoom",GestureZoom);
  registerInterceptorTypeForNamedType("Gtk", "Gradient",Gradient);
  registerInterceptorTypeForNamedType("Gtk", "Grid",Grid);
  registerInterceptorTypeForNamedType("Gtk", "HBox",HBox);
  registerInterceptorTypeForNamedType("Gtk", "HButtonBox",HButtonBox);
  registerInterceptorTypeForNamedType("Gtk", "HPaned",HPaned);
  registerInterceptorTypeForNamedType("Gtk", "HSV",HSV);
  registerInterceptorTypeForNamedType("Gtk", "HScale",HScale);
  registerInterceptorTypeForNamedType("Gtk", "HScrollbar",HScrollbar);
  registerInterceptorTypeForNamedType("Gtk", "HSeparator",HSeparator);
  registerInterceptorTypeForNamedType("Gtk", "HandleBox",HandleBox);
  registerInterceptorTypeForNamedType("Gtk", "HeaderBar",HeaderBar);
  registerInterceptorTypeForNamedType("Gtk", "HeaderBarPrivate",HeaderBarPrivate);
  registerInterceptorTypeForNamedType("Gtk", "IMContext",IMContext);
  registerInterceptorTypeForNamedType("Gtk", "IMContextInfo",IMContextInfo);
  registerInterceptorTypeForNamedType("Gtk", "IMContextSimple",IMContextSimple);
  registerInterceptorTypeForNamedType("Gtk", "IMMulticontext",IMMulticontext);
  registerInterceptorTypeForNamedType("Gtk", "IMPreeditStyle",IMPreeditStyle);
  registerInterceptorTypeForNamedType("Gtk", "IMStatusStyle",IMStatusStyle);
  registerInterceptorTypeForNamedType("Gtk", "IconFactory",IconFactory);
  registerInterceptorTypeForNamedType("Gtk", "IconInfo",IconInfo);
  registerInterceptorTypeForNamedType("Gtk", "IconLookupFlags",IconLookupFlags);
  registerInterceptorTypeForNamedType("Gtk", "IconSet",IconSet);
  registerInterceptorTypeForNamedType("Gtk", "IconSize",IconSize);
  registerInterceptorTypeForNamedType("Gtk", "IconSource",IconSource);
  registerInterceptorTypeForNamedType("Gtk", "IconTheme",IconTheme);
  registerInterceptorTypeForNamedType("Gtk", "IconThemeError",IconThemeErrorCode);
  registerInterceptorTypeForNamedType("Gtk", "IconView",IconView);
  registerInterceptorTypeForNamedType("Gtk", "IconViewAccessible",IconViewAccessible);
  registerInterceptorTypeForNamedType("Gtk", "IconViewDropPosition",IconViewDropPosition);
  registerInterceptorTypeForNamedType("Gtk", "Image",Image);
  registerInterceptorTypeForNamedType("Gtk", "ImageAccessible",ImageAccessible);
  registerInterceptorTypeForNamedType("Gtk", "ImageCellAccessible",ImageCellAccessible);
  registerInterceptorTypeForNamedType("Gtk", "ImageMenuItem",ImageMenuItem);
  registerInterceptorTypeForNamedType("Gtk", "ImageType",ImageType);
  registerInterceptorTypeForNamedType("Gtk", "InfoBar",InfoBar);
  registerInterceptorTypeForNamedType("Gtk", "InputHints",InputHints);
  registerInterceptorTypeForNamedType("Gtk", "InputPurpose",InputPurpose);
  registerInterceptorTypeForNamedType("Gtk", "Invisible",Invisible);
  registerInterceptorTypeForNamedType("Gtk", "JunctionSides",JunctionSides);
  registerInterceptorTypeForNamedType("Gtk", "Justification",Justification);
  registerInterceptorTypeForNamedType("Gtk", "Label",Label);
  registerInterceptorTypeForNamedType("Gtk", "LabelAccessible",LabelAccessible);
  registerInterceptorTypeForNamedType("Gtk", "LabelSelectionInfo",LabelSelectionInfo);
  registerInterceptorTypeForNamedType("Gtk", "Layout",Layout);
  registerInterceptorTypeForNamedType("Gtk", "LevelBar",LevelBar);
  registerInterceptorTypeForNamedType("Gtk", "LevelBarAccessible",LevelBarAccessible);
  registerInterceptorTypeForNamedType("Gtk", "LevelBarMode",LevelBarMode);
  registerInterceptorTypeForNamedType("Gtk", "License",License);
  registerInterceptorTypeForNamedType("Gtk", "LinkButton",LinkButton);
  registerInterceptorTypeForNamedType("Gtk", "LinkButtonAccessible",LinkButtonAccessible);
  registerInterceptorTypeForNamedType("Gtk", "ListBox",ListBox);
  registerInterceptorTypeForNamedType("Gtk", "ListBoxAccessible",ListBoxAccessible);
  registerInterceptorTypeForNamedType("Gtk", "ListBoxRow",ListBoxRow);
  registerInterceptorTypeForNamedType("Gtk", "ListBoxRowAccessible",ListBoxRowAccessible);
  registerInterceptorTypeForNamedType("Gtk", "ListStore",ListStore);
  registerInterceptorTypeForNamedType("Gtk", "LockButton",LockButton);
  registerInterceptorTypeForNamedType("Gtk", "LockButtonAccessible",LockButtonAccessible);
  registerInterceptorTypeForNamedType("Gtk", "Menu",Menu);
  registerInterceptorTypeForNamedType("Gtk", "MenuAccessible",MenuAccessible);
  registerInterceptorTypeForNamedType("Gtk", "MenuBar",MenuBar);
  registerInterceptorTypeForNamedType("Gtk", "MenuButton",MenuButton);
  registerInterceptorTypeForNamedType("Gtk", "MenuButtonAccessible",MenuButtonAccessible);
  registerInterceptorTypeForNamedType("Gtk", "MenuDirectionType",MenuDirectionType);
  registerInterceptorTypeForNamedType("Gtk", "MenuItem",MenuItem);
  registerInterceptorTypeForNamedType("Gtk", "MenuItemAccessible",MenuItemAccessible);
  registerInterceptorTypeForNamedType("Gtk", "MenuShell",MenuShell);
  registerInterceptorTypeForNamedType("Gtk", "MenuShellAccessible",MenuShellAccessible);
  registerInterceptorTypeForNamedType("Gtk", "MenuToolButton",MenuToolButton);
  registerInterceptorTypeForNamedType("Gtk", "MessageDialog",MessageDialog);
  registerInterceptorTypeForNamedType("Gtk", "MessageType",MessageType);
  registerInterceptorTypeForNamedType("Gtk", "Misc",Misc);
  registerInterceptorTypeForNamedType("Gtk", "ModelButton",ModelButton);
  registerInterceptorTypeForNamedType("Gtk", "MountOperation",MountOperation);
  registerInterceptorTypeForNamedType("Gtk", "MovementStep",MovementStep);
  registerInterceptorTypeForNamedType("Gtk", "Notebook",Notebook);
  registerInterceptorTypeForNamedType("Gtk", "NotebookAccessible",NotebookAccessible);
  registerInterceptorTypeForNamedType("Gtk", "NotebookPageAccessible",NotebookPageAccessible);
  registerInterceptorTypeForNamedType("Gtk", "NotebookTab",NotebookTab);
  registerInterceptorTypeForNamedType("Gtk", "NumberUpLayout",NumberUpLayout);
  registerInterceptorTypeForNamedType("Gtk", "NumerableIcon",NumerableIcon);
  registerInterceptorTypeForNamedType("Gtk", "OffscreenWindow",OffscreenWindow);
  registerInterceptorTypeForNamedType("Gtk", "Orientation",Orientation);
  registerInterceptorTypeForNamedType("Gtk", "Overlay",Overlay);
  registerInterceptorTypeForNamedType("Gtk", "PackDirection",PackDirection);
  registerInterceptorTypeForNamedType("Gtk", "PackType",PackType);
  registerInterceptorTypeForNamedType("Gtk", "PageOrientation",PageOrientation);
  registerInterceptorTypeForNamedType("Gtk", "PageRange",PageRange);
  registerInterceptorTypeForNamedType("Gtk", "PageSet",PageSet);
  registerInterceptorTypeForNamedType("Gtk", "PageSetup",PageSetup);
  registerInterceptorTypeForNamedType("Gtk", "PanDirection",PanDirection);
  registerInterceptorTypeForNamedType("Gtk", "Paned",Paned);
  registerInterceptorTypeForNamedType("Gtk", "PanedAccessible",PanedAccessible);
  registerInterceptorTypeForNamedType("Gtk", "PaperSize",PaperSize);
  registerInterceptorTypeForNamedType("Gtk", "PathPriorityType",PathPriorityType);
  registerInterceptorTypeForNamedType("Gtk", "PathType",PathType);
  registerInterceptorTypeForNamedType("Gtk", "PlacesOpenFlags",PlacesOpenFlags);
  registerInterceptorTypeForNamedType("Gtk", "PlacesSidebar",PlacesSidebar);
  registerInterceptorTypeForNamedType("Gtk", "Plug",Plug);
  registerInterceptorTypeForNamedType("Gtk", "PolicyType",PolicyType);
  registerInterceptorTypeForNamedType("Gtk", "Popover",Popover);
  registerInterceptorTypeForNamedType("Gtk", "PopoverAccessible",PopoverAccessible);
  registerInterceptorTypeForNamedType("Gtk", "PopoverMenu",PopoverMenu);
  registerInterceptorTypeForNamedType("Gtk", "PositionType",PositionType);
  registerInterceptorTypeForNamedType("Gtk", "PrintContext",PrintContext);
  registerInterceptorTypeForNamedType("Gtk", "PrintDuplex",PrintDuplex);
  registerInterceptorTypeForNamedType("Gtk", "PrintError",PrintErrorCode);
  registerInterceptorTypeForNamedType("Gtk", "PrintOperation",PrintOperation);
  registerInterceptorTypeForNamedType("Gtk", "PrintOperationAction",PrintOperationAction);
  registerInterceptorTypeForNamedType("Gtk", "PrintOperationResult",PrintOperationResult);
  registerInterceptorTypeForNamedType("Gtk", "PrintPages",PrintPages);
  registerInterceptorTypeForNamedType("Gtk", "PrintQuality",PrintQuality);
  registerInterceptorTypeForNamedType("Gtk", "PrintSettings",PrintSettings);
  registerInterceptorTypeForNamedType("Gtk", "PrintStatus",PrintStatus);
  registerInterceptorTypeForNamedType("Gtk", "ProgressBar",ProgressBar);
  registerInterceptorTypeForNamedType("Gtk", "ProgressBarAccessible",ProgressBarAccessible);
  registerInterceptorTypeForNamedType("Gtk", "PropagationPhase",PropagationPhase);
  registerInterceptorTypeForNamedType("Gtk", "RadioAction",RadioAction);
  registerInterceptorTypeForNamedType("Gtk", "RadioActionEntry",RadioActionEntry);
  registerInterceptorTypeForNamedType("Gtk", "RadioButton",RadioButton);
  registerInterceptorTypeForNamedType("Gtk", "RadioButtonAccessible",RadioButtonAccessible);
  registerInterceptorTypeForNamedType("Gtk", "RadioMenuItem",RadioMenuItem);
  registerInterceptorTypeForNamedType("Gtk", "RadioMenuItemAccessible",RadioMenuItemAccessible);
  registerInterceptorTypeForNamedType("Gtk", "RadioToolButton",RadioToolButton);
  registerInterceptorTypeForNamedType("Gtk", "Range",Range);
  registerInterceptorTypeForNamedType("Gtk", "RangeAccessible",RangeAccessible);
  registerInterceptorTypeForNamedType("Gtk", "RcContext",RcContext);
  registerInterceptorTypeForNamedType("Gtk", "RcFlags",RcFlags);
  registerInterceptorTypeForNamedType("Gtk", "RcProperty",RcProperty);
  registerInterceptorTypeForNamedType("Gtk", "RcStyle",RcStyle);
  registerInterceptorTypeForNamedType("Gtk", "RcTokenType",RcTokenType);
  registerInterceptorTypeForNamedType("Gtk", "RecentAction",RecentAction);
  registerInterceptorTypeForNamedType("Gtk", "RecentChooserDialog",RecentChooserDialog);
  registerInterceptorTypeForNamedType("Gtk", "RecentChooserError",RecentChooserErrorCode);
  registerInterceptorTypeForNamedType("Gtk", "RecentChooserMenu",RecentChooserMenu);
  registerInterceptorTypeForNamedType("Gtk", "RecentChooserWidget",RecentChooserWidget);
  registerInterceptorTypeForNamedType("Gtk", "RecentData",RecentData);
  registerInterceptorTypeForNamedType("Gtk", "RecentFilter",RecentFilter);
  registerInterceptorTypeForNamedType("Gtk", "RecentFilterFlags",RecentFilterFlags);
  registerInterceptorTypeForNamedType("Gtk", "RecentFilterInfo",RecentFilterInfo);
  registerInterceptorTypeForNamedType("Gtk", "RecentInfo",RecentInfo);
  registerInterceptorTypeForNamedType("Gtk", "RecentManager",RecentManager);
  registerInterceptorTypeForNamedType("Gtk", "RecentManagerError",RecentManagerErrorCode);
  registerInterceptorTypeForNamedType("Gtk", "RecentSortType",RecentSortType);
  registerInterceptorTypeForNamedType("Gtk", "RegionFlags",RegionFlags);
  registerInterceptorTypeForNamedType("Gtk", "ReliefStyle",ReliefStyle);
  registerInterceptorTypeForNamedType("Gtk", "RendererCellAccessible",RendererCellAccessible);
  registerInterceptorTypeForNamedType("Gtk", "RequestedSize",RequestedSize);
  registerInterceptorTypeForNamedType("Gtk", "Requisition",Requisition);
  registerInterceptorTypeForNamedType("Gtk", "ResizeMode",ResizeMode);
  registerInterceptorTypeForNamedType("Gtk", "ResponseType",ResponseType);
  registerInterceptorTypeForNamedType("Gtk", "Revealer",Revealer);
  registerInterceptorTypeForNamedType("Gtk", "RevealerTransitionType",RevealerTransitionType);
  registerInterceptorTypeForNamedType("Gtk", "Scale",Scale);
  registerInterceptorTypeForNamedType("Gtk", "ScaleAccessible",ScaleAccessible);
  registerInterceptorTypeForNamedType("Gtk", "ScaleButton",ScaleButton);
  registerInterceptorTypeForNamedType("Gtk", "ScaleButtonAccessible",ScaleButtonAccessible);
  registerInterceptorTypeForNamedType("Gtk", "ScrollStep",ScrollStep);
  registerInterceptorTypeForNamedType("Gtk", "ScrollType",ScrollType);
  registerInterceptorTypeForNamedType("Gtk", "ScrollablePolicy",ScrollablePolicy);
  registerInterceptorTypeForNamedType("Gtk", "Scrollbar",Scrollbar);
  registerInterceptorTypeForNamedType("Gtk", "ScrolledWindow",ScrolledWindow);
  registerInterceptorTypeForNamedType("Gtk", "ScrolledWindowAccessible",ScrolledWindowAccessible);
  registerInterceptorTypeForNamedType("Gtk", "SearchBar",SearchBar);
  registerInterceptorTypeForNamedType("Gtk", "SearchEntry",SearchEntry);
  registerInterceptorTypeForNamedType("Gtk", "SelectionData",SelectionData);
  registerInterceptorTypeForNamedType("Gtk", "SelectionMode",SelectionMode);
  registerInterceptorTypeForNamedType("Gtk", "SensitivityType",SensitivityType);
  registerInterceptorTypeForNamedType("Gtk", "Separator",Separator);
  registerInterceptorTypeForNamedType("Gtk", "SeparatorMenuItem",SeparatorMenuItem);
  registerInterceptorTypeForNamedType("Gtk", "SeparatorToolItem",SeparatorToolItem);
  registerInterceptorTypeForNamedType("Gtk", "Settings",Settings);
  registerInterceptorTypeForNamedType("Gtk", "SettingsValue",SettingsValue);
  registerInterceptorTypeForNamedType("Gtk", "ShadowType",ShadowType);
  registerInterceptorTypeForNamedType("Gtk", "SizeGroup",SizeGroup);
  registerInterceptorTypeForNamedType("Gtk", "SizeGroupMode",SizeGroupMode);
  registerInterceptorTypeForNamedType("Gtk", "SizeRequestMode",SizeRequestMode);
  registerInterceptorTypeForNamedType("Gtk", "Socket",Socket);
  registerInterceptorTypeForNamedType("Gtk", "SortType",SortType);
  registerInterceptorTypeForNamedType("Gtk", "SpinButton",SpinButton);
  registerInterceptorTypeForNamedType("Gtk", "SpinButtonAccessible",SpinButtonAccessible);
  registerInterceptorTypeForNamedType("Gtk", "SpinButtonUpdatePolicy",SpinButtonUpdatePolicy);
  registerInterceptorTypeForNamedType("Gtk", "SpinType",SpinType);
  registerInterceptorTypeForNamedType("Gtk", "Spinner",Spinner);
  registerInterceptorTypeForNamedType("Gtk", "SpinnerAccessible",SpinnerAccessible);
  registerInterceptorTypeForNamedType("Gtk", "Stack",Stack);
  registerInterceptorTypeForNamedType("Gtk", "StackSidebar",StackSidebar);
  registerInterceptorTypeForNamedType("Gtk", "StackSidebarPrivate",StackSidebarPrivate);
  registerInterceptorTypeForNamedType("Gtk", "StackSwitcher",StackSwitcher);
  registerInterceptorTypeForNamedType("Gtk", "StackTransitionType",StackTransitionType);
  registerInterceptorTypeForNamedType("Gtk", "StateFlags",StateFlags);
  registerInterceptorTypeForNamedType("Gtk", "StateType",StateType);
  registerInterceptorTypeForNamedType("Gtk", "StatusIcon",StatusIcon);
  registerInterceptorTypeForNamedType("Gtk", "Statusbar",Statusbar);
  registerInterceptorTypeForNamedType("Gtk", "StatusbarAccessible",StatusbarAccessible);
  registerInterceptorTypeForNamedType("Gtk", "StockItem",StockItem);
  registerInterceptorTypeForNamedType("Gtk", "Style",Style);
  registerInterceptorTypeForNamedType("Gtk", "StyleContext",StyleContext);
  registerInterceptorTypeForNamedType("Gtk", "StyleProperties",StyleProperties);
  registerInterceptorTypeForNamedType("Gtk", "Switch",Switch);
  registerInterceptorTypeForNamedType("Gtk", "SwitchAccessible",SwitchAccessible);
  registerInterceptorTypeForNamedType("Gtk", "SymbolicColor",SymbolicColor);
  registerInterceptorTypeForNamedType("Gtk", "Table",Table);
  registerInterceptorTypeForNamedType("Gtk", "TableChild",TableChild);
  registerInterceptorTypeForNamedType("Gtk", "TableRowCol",TableRowCol);
  registerInterceptorTypeForNamedType("Gtk", "TargetEntry",TargetEntry);
  registerInterceptorTypeForNamedType("Gtk", "TargetFlags",TargetFlags);
  registerInterceptorTypeForNamedType("Gtk", "TargetList",TargetList);
  registerInterceptorTypeForNamedType("Gtk", "TargetPair",TargetPair);
  registerInterceptorTypeForNamedType("Gtk", "TearoffMenuItem",TearoffMenuItem);
  registerInterceptorTypeForNamedType("Gtk", "TextAppearance",TextAppearance);
  registerInterceptorTypeForNamedType("Gtk", "TextAttributes",TextAttributes);
  registerInterceptorTypeForNamedType("Gtk", "TextBTree",TextBTree);
  registerInterceptorTypeForNamedType("Gtk", "TextBuffer",TextBuffer);
  registerInterceptorTypeForNamedType("Gtk", "TextBufferTargetInfo",TextBufferTargetInfo);
  registerInterceptorTypeForNamedType("Gtk", "TextCellAccessible",TextCellAccessible);
  registerInterceptorTypeForNamedType("Gtk", "TextChildAnchor",TextChildAnchor);
  registerInterceptorTypeForNamedType("Gtk", "TextDirection",TextDirection);
  registerInterceptorTypeForNamedType("Gtk", "TextExtendSelection",TextExtendSelection);
  registerInterceptorTypeForNamedType("Gtk", "TextIter",TextIter);
  registerInterceptorTypeForNamedType("Gtk", "TextMark",TextMark);
  registerInterceptorTypeForNamedType("Gtk", "TextSearchFlags",TextSearchFlags);
  registerInterceptorTypeForNamedType("Gtk", "TextTag",TextTag);
  registerInterceptorTypeForNamedType("Gtk", "TextTagTable",TextTagTable);
  registerInterceptorTypeForNamedType("Gtk", "TextView",TextView);
  registerInterceptorTypeForNamedType("Gtk", "TextViewAccessible",TextViewAccessible);
  registerInterceptorTypeForNamedType("Gtk", "TextViewLayer",TextViewLayer);
  registerInterceptorTypeForNamedType("Gtk", "TextWindowType",TextWindowType);
  registerInterceptorTypeForNamedType("Gtk", "ThemeEngine",ThemeEngine);
  registerInterceptorTypeForNamedType("Gtk", "ThemingEngine",ThemingEngine);
  registerInterceptorTypeForNamedType("Gtk", "ToggleAction",ToggleAction);
  registerInterceptorTypeForNamedType("Gtk", "ToggleActionEntry",ToggleActionEntry);
  registerInterceptorTypeForNamedType("Gtk", "ToggleButton",ToggleButton);
  registerInterceptorTypeForNamedType("Gtk", "ToggleButtonAccessible",ToggleButtonAccessible);
  registerInterceptorTypeForNamedType("Gtk", "ToggleToolButton",ToggleToolButton);
  registerInterceptorTypeForNamedType("Gtk", "ToolButton",ToolButton);
  registerInterceptorTypeForNamedType("Gtk", "ToolItem",ToolItem);
  registerInterceptorTypeForNamedType("Gtk", "ToolItemGroup",ToolItemGroup);
  registerInterceptorTypeForNamedType("Gtk", "ToolPalette",ToolPalette);
  registerInterceptorTypeForNamedType("Gtk", "ToolPaletteDragTargets",ToolPaletteDragTargets);
  registerInterceptorTypeForNamedType("Gtk", "Toolbar",Toolbar);
  registerInterceptorTypeForNamedType("Gtk", "ToolbarSpaceStyle",ToolbarSpaceStyle);
  registerInterceptorTypeForNamedType("Gtk", "ToolbarStyle",ToolbarStyle);
  registerInterceptorTypeForNamedType("Gtk", "Tooltip",Tooltip);
  registerInterceptorTypeForNamedType("Gtk", "ToplevelAccessible",ToplevelAccessible);
  registerInterceptorTypeForNamedType("Gtk", "TreeIter",TreeIter);
  registerInterceptorTypeForNamedType("Gtk", "TreeModelFilter",TreeModelFilter);
  registerInterceptorTypeForNamedType("Gtk", "TreeModelFlags",TreeModelFlags);
  registerInterceptorTypeForNamedType("Gtk", "TreeModelSort",TreeModelSort);
  registerInterceptorTypeForNamedType("Gtk", "TreePath",TreePath);
  registerInterceptorTypeForNamedType("Gtk", "TreeRowReference",TreeRowReference);
  registerInterceptorTypeForNamedType("Gtk", "TreeSelection",TreeSelection);
  registerInterceptorTypeForNamedType("Gtk", "TreeStore",TreeStore);
  registerInterceptorTypeForNamedType("Gtk", "TreeView",TreeView);
  registerInterceptorTypeForNamedType("Gtk", "TreeViewAccessible",TreeViewAccessible);
  registerInterceptorTypeForNamedType("Gtk", "TreeViewColumn",TreeViewColumn);
  registerInterceptorTypeForNamedType("Gtk", "TreeViewColumnSizing",TreeViewColumnSizing);
  registerInterceptorTypeForNamedType("Gtk", "TreeViewDropPosition",TreeViewDropPosition);
  registerInterceptorTypeForNamedType("Gtk", "TreeViewGridLines",TreeViewGridLines);
  registerInterceptorTypeForNamedType("Gtk", "UIManager",UIManager);
  registerInterceptorTypeForNamedType("Gtk", "UIManagerItemType",UIManagerItemType);
  registerInterceptorTypeForNamedType("Gtk", "Unit",Unit);
  registerInterceptorTypeForNamedType("Gtk", "VBox",VBox);
  registerInterceptorTypeForNamedType("Gtk", "VButtonBox",VButtonBox);
  registerInterceptorTypeForNamedType("Gtk", "VPaned",VPaned);
  registerInterceptorTypeForNamedType("Gtk", "VScale",VScale);
  registerInterceptorTypeForNamedType("Gtk", "VScrollbar",VScrollbar);
  registerInterceptorTypeForNamedType("Gtk", "VSeparator",VSeparator);
  registerInterceptorTypeForNamedType("Gtk", "Viewport",Viewport);
  registerInterceptorTypeForNamedType("Gtk", "VolumeButton",VolumeButton);
  registerInterceptorTypeForNamedType("Gtk", "Widget",Widget);
  registerInterceptorTypeForNamedType("Gtk", "WidgetAccessible",WidgetAccessible);
  registerInterceptorTypeForNamedType("Gtk", "WidgetClassPrivate",WidgetClassPrivate);
  registerInterceptorTypeForNamedType("Gtk", "WidgetHelpType",WidgetHelpType);
  registerInterceptorTypeForNamedType("Gtk", "WidgetPath",WidgetPath);
  registerInterceptorTypeForNamedType("Gtk", "Window",Window);
  registerInterceptorTypeForNamedType("Gtk", "WindowAccessible",WindowAccessible);
  registerInterceptorTypeForNamedType("Gtk", "WindowGeometryInfo",WindowGeometryInfo);
  registerInterceptorTypeForNamedType("Gtk", "WindowGroup",WindowGroup);
  registerInterceptorTypeForNamedType("Gtk", "WindowPosition",WindowPosition);
  registerInterceptorTypeForNamedType("Gtk", "WindowType",WindowType);
  registerInterceptorTypeForNamedType("Gtk", "WrapMode",WrapMode);
  registerInterceptorTypeForErrorDomain("gtk-builder-error-quark", BuilderError);
  registerInterceptorTypeForErrorDomain("gtk-css-provider-error-quark", CssProviderError);
  registerInterceptorTypeForErrorDomain("gtk-file-chooser-error-quark", FileChooserError);
  registerInterceptorTypeForErrorDomain("gtk-icon-theme-error-quark", IconThemeError);
  registerInterceptorTypeForErrorDomain("gtk-print-error-quark", PrintError);
  registerInterceptorTypeForErrorDomain("gtk-recent-chooser-error-quark", RecentChooserError);
  registerInterceptorTypeForErrorDomain("gtk-recent-manager-error-quark", RecentManagerError);
}
